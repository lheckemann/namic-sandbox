#
#   
# How to obtain the source code
#
#    

The code is in the ITK's svn repositories at the following link

http://www.na-mic.org/svn/NAMICSandBox/trunk/MultiImageRegistration/
   
If you dont have access to ITK's
svn servers, you can get read access to the repository by simply
downloading it according to the instructions in the following Wiki page:

http://wiki.na-mic.org/Wiki/index.php/Engineering:SandBox

The code should be compiled with ITK 3.16.0(or later version) - which is essential for the optimizer.

#
#
#  How to compile
#
#

Methods1: 
 Libraries:
     ITK: The code was compiled with version 3.0
        to obtain ITK libraries go to http://www.itk.org/HTML/Download.htm
   
           
 Compilation using cmake:
   The source code can be compiled using cmake. After downloading the code 
   go to the folder where the code resides. The current parser in the code 
   does not support folder names with spaces, so locate the folder in path
   without spaces.

              
   Type "ccmake ." in the command line. cmake will generate a makefile for the project. 
   Cmake can be downloaded from http://www.cmake.org/HTML/Download.html.
   
   After running "ccmake ." type "make" in command line. This will compile the code 
   and generate the following binaries
   
      GroupwiseRegistration  - Binary for groupwise registration 
      TransformImage         - Transforms an image using a transformation file generated 
                               by binaries.
      CreateImageSetAffine   - Applies random affine transforms to the input image and saves 
                               the output. Used to create a synthetic dataset for testing he code.
      CreateImageSetBspline  - Applies random bspline transforms to the input image and saves 
                               the output.
      ComputeOutputs         - Command line module to visualize registration results in 3D. This module 
                               outputs the transformed images, mean and standard deviation images
                               along with central slices.


Method2:
 Type "bash buildThis.sh ${ABI} ${buildType}" in the command line. 
   ${ABI} can be DEBUG FAST(default) OPTDEBUG PROFILE
   ${buildTyep} can be Experimental, Continous, Nightly  
#
#
# How to run testing
#
# 

Default testing makes use of the 3D images available at ITK's repositories.
Cmake will ask you about the place of the folder "BrainWeb"

Download the files at the link
http://public.kitware.com/pub/itk/Data/BrainWeb/BrainPart1.tgz
http://public.kitware.com/pub/itk/Data/BrainWeb/BrainPart2.tgz
http://public.kitware.com/pub/itk/Data/BrainWeb/BrainPart3.tgz
http://public.kitware.com/pub/itk/Data/DTI/Reconstructed/FAImage.tar.gz


Extract the images at a folder and provide cmake with the name of the folder.

After setting the name of the folder for BrainWeb data
type "ctest" at the project folder.

This will create synthetic data from the given sample image and will run the 
registration code. The results are placed under the folder
(project folder)/Testing/Temporary

#
#
# How to run the binary "GroupwiseRegistration"
#
#

Type in the command line

   GroupwiseRegistration filenames.txt parameters.txt

"filenames.txt" contains the names of the input files and the path for the output files. 
See files in folders \Testing\Temporary\ for examples.
  -i ${inputPath} # The path of the input folder for images.
  -o ${outputPath} # The path of the output folder.# All outputs are saved to this folder
  -ti ${initialTransformPath} # The path of the input folder for initial
                              #transform files
  -f ${filename1} # names of the input files
  -f ${filename2} # if inputFolder is specified, the pathname is relative to that
  -f ${filename3} # folder. Otherwise supply the full pathname
  ...
  -f ${filenameN}
  -it ${initialTransformFileName1} #names of initial Transform files if you
                                   #have these files 
  -it ${initialTransformFileName2}
  ...
  -it ${initialTransformFileNameN} 


"parameters.txt" contains the parameters of the groupwise registration. It allows you to 
select which objective function and transformation model to use. For more information
about the use of parameters check example files in folders \Testing\Temporary\. 
Most parameters have default values
so only first few parameters at the beginning of file should be changed.

       # metricType specifies which objective function to use
       # possible options:
       #
       #   entropy: congealing with entropy
       #   variance: registering to the mean template image using
       #             sum of square differences
   -metricType entropy

       # If useBpline is set off, only affine registration is done,
       # if it is on and useBspline high is off, bspline registration
       # is done with specified grid region. If useBsplineHigh is on
       # bspline registration with mesh refinement is performed
       #
       # Options to use:
       #    useBspline on/off
       #    useBsplineHigh on/off
       #
    -useBspline off
    -useBsplineHigh off

       # defines the initial bspline grid size along each dimension
    -bsplineInitialGridSize  28    
        
       # When using Bspline grid refinement, this options defines how many number of refinements to use.
       # After each level number B-spline control points are doubled (8->16->32)
    -numberOfBsplineLevel 2

       #  Set BSpline regularization on/off
    -BSplineRegularizationFlag off

       #  Set Histogram matching on/off
    -useHistogramMatching off
    -HistogramLevels 256
    -NumberOfMatchPoints 7


       # Bspline regularization
       # the width of the Gaussian kernel (in pixels)
       # higher values yield smoother deformation fields
    -gaussianFilterKernelWidth 2.0  

        # All objective functions make use of stochastic subsampline
        # following options define the number of spatial samples
        # as percentage of the total number of voxels in the image
        # (Try to increase the number of samples if the registration
        #  accuracy is poor)
    -numberOfSpatialSamplesAffinePercentage      0.0025
    -numberOfSpatialSamplesBsplinePercentage     0.02
    -numberOfSpatialSamplesBsplineHighPercentage 0.02

        # following options define number of multiresolution levels used in
        # optimization
        # if set to one no multiresolution optimization is performed.
        # Affine/Bspline/BsplineHigh define number of multiresolution levels
        # used for each registration stage
        #
        # (For high resolution anatomical images at 256x256x128 voxels
        #  we used 3 levels, decrease the number of levels if the
        #  resolution of the input image is low )

     -multiLevelAffine 3
     -multiLevelBspline 3
     -multiLevelBsplineHigh 3

        # Following options define the number iterations to be performed
        # Optimization is terminated after a fixed number of iterations
        # no other termination options are used
    -optAffineNumberOfIterations 50
    -optBsplineNumberOfIterations 10
    -optBsplineHighNumberOfIterations 10

        # Following options define the learning rate of the optimizers
        # for each stage of the registration
        # (decrease the learning rate if you get
        #  "all samples mapped outside" error
    -optAffineLearningRate  1e-4
    -optBsplineLearningRate 1e4
    -optBsplineHighLearningRate 1e4

        # Currently there are three optimizer types.
        # "gradient" is a fixed step gradient descent search.
        # "lineSearch" is gradient descent search where step size is determined using
        # line search.
        # optimizerType gradient/lineSearch/SPSA
    -optimizerType lineSearch

        #  Specifies the percentage increase in the sampling rate
        #  after each multiresolution level
    -affineMultiScaleSamplePercentageIncrease 4.0
    -bsplineMultiScaleSamplePercentageIncrease 4.0

        #  Specifies increase in the number of iterations
        #  after each resolution level
    -affineMultiScaleMaximumIterationIncrease 2.5
    -bsplineMultiScaleMaximumIterationIncrease 3.0
        
        # Specifies optimizer step length increase after each multiresolution level
    -affineMultiScaleStepLengthIncrease 4.0
    -bsplineMultiScaleStepLengthIncrease 4.0

        # the width of the parzen window to compute the entropy
        # used by all metric types computing entropy
        # This value is approximately five percent of the range of the
        # intensity values. For intensity values between 1~255, we used a
        # value of 10
    -parzenWindowStandardDeviation 10.0

        #  Use normalize filter to normalize input images
        #  to have mean zero and standard deviation 1.
    -useNormalizeFilter off

        #  Write 3D images to file.
        #  turn off to save disk space
    -write3DImages off

        # the level of registration to be started
        # Use this option if you want to start the registration
        # using the results of a previous registration
        # 0 (default): no initialization, all registrations are performed
        # 1 : Affine parameters are read from the file
        # 2 : Bspline parameters are read from file (initial size should match the
        # transform from file )
    -StartLevel 0

        # Uses a mask on the images. Only pixels inside the mask are considered during
        # the registration
        # possible options
        #     mask none/single/all
        # none: do not use mask
        # single: only use mask for the first image
        # all: use mask for all images
    -mask none

        # specifies the mask type
        # possible options
        #     maskype connectedThreshold/neighborhoodConnected/ROIAUTO
        # connectedThreshold: adds all pixels
        #                     to the mask if its value is smaller than threshold1
        #                     than add connected pixels whose value is smaller than
        #                     threshold2
        # neighborhoodConnected: same as connectedThreshold but a pixel is added
        #                        only if it is all connected within a radius of one
        # ROIAUTO: the mask is implicitly defined using an
        # ostu forground and hole filling algorithm. 
    -maskType ROIAUTO   
    -threshold1 0
    -threshold2 1

        # specifies the translation scale coefficients with respect to the affine
        # coefficients
        # smaller values mean larger step size along translation directions
        # 1/scale is used!
     -translationScaleCoeffs 1e-3

        #  Maximum number of iterations performed for a line search
        #  if the optimizer is lineSearch
    -maximumLineIteration 6


When you run GroupwiseRegistration, it displays a bunch of information to std::cout. 
You will see output like this
   
   Iter number1 number2 number3

number1 denotes total number of iterations done by the program,
number2 denotes total number of iterations done in current scale and transformation type
number3 shows the value of the objective function.(As we use stochastic subsampling, this value
        might increase for some iterations)
        
At the end of registration the binary will create a bunch of files and folders in the
output folder specified in "filenames.txt"

   Foldername:

      Affine:  Contains results for affine registration
      Bspline_Grid_#: Contains results for B-Spline registration with # denoting number of control points


#                        
#
#  About the implementation
#
#                        

All metrics are implementing in a multi-threaded fashion. The algorithm will run faster on
computers with multiple CPU's.

