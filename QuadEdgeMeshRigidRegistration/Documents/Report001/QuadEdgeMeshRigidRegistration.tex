\documentclass{InsightArticle}

\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage{listings}

\definecolor{listcomment}{rgb}{0.0,0.5,0.0}
\definecolor{listkeyword}{rgb}{0.0,0.0,0.5}
\definecolor{listnumbers}{gray}{0.65}
\definecolor{listlightgray}{gray}{0.955}
\definecolor{listwhite}{gray}{1.0}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}


\title{Rotational Registration of Spherical Surfaces Represented as QuadEdge Meshes}


% 
% NOTE: This is the last number of the "handle" URL that 
% The Insight Journal assigns to your paper as part of the
% submission process. Please replace the number "1338" with
% the actual handle number that you get assigned.
%
\newcommand{\IJhandlerIDnumber}{1338}

\lstset{frame = tb,
       framerule = 0.25pt,
       float,
       fontadjust,
       backgroundcolor={\color{listlightgray}},
       basicstyle = {\ttfamily\footnotesize},
       keywordstyle = {\ttfamily\color{listkeyword}\textbf},
       identifierstyle = {\ttfamily},
       commentstyle = {\ttfamily\color{listcomment}\textit},
       stringstyle = {\ttfamily},
       showstringspaces = false,
       showtabs = false,
       numbers = left,
       numbersep = 6pt,
       numberstyle={\ttfamily\color{listnumbers}},
       tabsize = 2,
       language=[ANSI]C++,
       floatplacement=!h
       }

\release{1.00}

\author{Luis Ibanez$^{1}$, Michel Audette$^{1}$, Thomas Yeo$^{2}$, Polina Goland$^{2}$}
\authoraddress{$^{1}$Kitware Inc., Clifton Park, NY\\
               $^{2}$CSAIL MIT, Boston, MA}

\begin{document}


%
% Add hyperlink to the web location and license of the paper.
% The argument of this command is the handler identifier given
% by the Insight Journal to this paper.
% 
\IJhandlefooter{\IJhandlerIDnumber}


\ifpdf
\else
   %
   % Commands for including Graphics when using latex
   % 
   \DeclareGraphicsExtensions{.eps,.jpg,.gif,.tiff,.bmp,.png}
   \DeclareGraphicsRule{.jpg}{eps}{.jpg.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.gif}{eps}{.gif.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.tiff}{eps}{.tiff.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.bmp}{eps}{.bmp.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.png}{eps}{.png.bb}{`convert #1 eps:-}
\fi


\maketitle


\ifhtml
\chapter*{Front Matter\label{front}}
\fi


\begin{abstract}
\noindent
This document describes a contribution to the Insight Toolkit intended to
support the process of registering two Meshes.  The methods included here are
restricted to Meshes with a Spherical geometry and topology, and with scalar
values associated to their nodes.

This paper is accompanied with the source code, input data, parameters and
output data that we used for validating the algorithm described in this paper.
This adheres to the fundamental principle that scientific publications must
facilitate \textbf{reproducibility} of the reported results.
\end{abstract}

\tableofcontents

\section{Introduction}

The Insight Toolkit already provides methods for registering

\begin{itemize}
\item Image to Image
\item PointSet to Image
\item PointSet to PointSet
\end{itemize}

but it lacks methods for registering one Mesh versus another Mesh.

In this paper we contribute new classes that can be used for performing
registration between two spherical meshes, although not all of of the classes
in this contribution are restricted to be used on spherical meshes.

\section{Overview}

The design of these classes follows very closely the one of the Image
Registration Framework in ITK.  In particular, we have the usual components

\begin{itemize}
\item Optimizer
\item Metric
\item Transform
\item Interpolator
\end{itemize}

and we have the two objects to be registered, in this case Meshes instead of
Images. The two main components that must be provided in order to support Mesh
registration are Iterpolators and Metrics.

\subsection{Mesh Interpolators}

Mesh-based Interpolators are designed here following the same structure of the
image interpolators. In particular, they derive from the \doxygen{Function}
class, and implement a sequence of 

\begin{itemize}
\item \code{itk::MeshFunction}
\item \code{itk::InterpolateMeshFunction}
\end{itemize}

 and finally, the siblings

\begin{itemize}
\item \code{itk::LinearInterpolateMeshFunction}
\item \code{itk::NearestNeighborInterpolateMeshFunction}
\end{itemize}

The diagram in Figure~\ref{fig:InterpolatorsClassHierarchy} presents the hierarchy of mesh
interpolators that are included in this contribution.

\begin{figure}
\center
\includegraphics[width=0.7\textwidth]{InterpolatorsClassHierarchy.pdf}
\itkcaption[Interpolators Class Hierarchy]{Hierarchy of new Mesh Interpolator Classes.}
\label{fig:InterpolatorsClassHierarchy}
\end{figure}

\subsection{Mesh Metrics}

Mesh metrics follow a similar structure to the existing image metrics in ITK.
Their hierarchy starts with the \code{itk::MeshToMeshMetric} that derives from
the existing ITK class \doxygen{SingleValuedCostFunction}. They currently comprise
an abstract base class and a concrete class, as follows:

\begin{itemize}
\item \code{itk::MeshToMeshMetric}
\item \code{itk::MeanSquaresMeshToMeshMetric}
\end{itemize}

It is expected that variations of Mesh metrics will be added as siblings of the
mean squares metric, just as variations of image metrics thrived in ITK.

The diagram in Figure~\ref{fig:MetricsClassHierarchy} presents the hierarchy of mesh
interpolators that are included in this contribution.

\begin{figure}
\center
\includegraphics[width=0.35\textwidth]{MetricsClassHierarchy.pdf}
\itkcaption[Metrics Class Hierarchy]{Hierarchy of new Mesh Metric Classes.}
\label{fig:MetricsClassHierarchy}
\end{figure}

\subsection{Mesh Point Locator}

One of the challenging aspects of implementing an interpolator in Meshes is the
fact that given a point in space, it is not trivial to find the Mesh cell that
contains this point in its domain. The method used here involves the use of a
\code{PointLocator} class that internally constructs a Kd-Tree in order to provide
a spatial classification of the Mesh points.

When the registration method is mapping points from the Fixed Mesh into the
Moving Mesh, this points are first mapped through the Transform and then they
are passed to the interpolator's \code{Evaluate()} method. The first action of
this method is to locate the points from the Moving Mesh that are closest to
the point given as argument of Evaluate.

The \code{PointLocator} class takes advantage of the classes

\begin{itemize}
\item \doxygen{KdTreeGenerator}
\item \doxygen{PointSetToListSampleAdaptor} 
\end{itemize}

that are already provided by the ITK Statistics framework. The KdTree is
constructed from the Moving Mesh during the initialization process of the
interpolator, that is triggered by the Initialize() method of the Metric
itself.

\subsection{Triangle Basis System}

The \code{TriangleBasisSystem} is an auxiliary class that holds a vector basis
for a triangular cell of a Mesh. This vector basis is then used as a coordinate
system in order to compute barycentric coordinates of points in a given cell.
These barycentric coordinates are commonly used as weights for a linear
interpolation of values assigned to the nodes of the triangular cell.

In a Mesh of topological dimension M that is embedded in a N-Dimensional space,
this class will contains M vector of N components each. This class is
essentially a data container and it does not provide computational
capabilities.

\subsection{Triangle Basis System Calculator}

The \code{TriangleBasisSystemCalculator} is an auxiliary class that computes
the TriangleBasisSystem of a cell from an M-Dimensional Mesh embedded in a
N-Dimensional space.  Given a set of N points, the calculator will compute the
vectors of the basis.

\subsection{Triangle List Basis System Calculator}

The \code{TriangleListBasisSystemCalculator} is an auxiliary class that will
compute the triangle basis systems for all the cells of an input mesh.

Given that in the context of Mesh to Mesh registration, the triangle basis of
all the cells have to be computed eventually it results more efficient to
pre-compute these basis at the beginning of the process, instead of having them
computed on-demand as the points are sampled.

Note however that this is a design decision based on the assumption that users
will deal most of the time with meshes that are not very large, and for which
computation time is the main concern. If you are working with very large
meshes, then it may be desirable to modify this code to avoid the memory
allocation required for storing all the vector basis, and instead pay for the
computation time of these vector set at every call of the interpolator
\code{Evaluate()} method.

\subsection{FreeSurfer Binary Surface Reader}

FreeSurfer is and application developed by the Athinoula A. Martinos Center for
Biomedical Imaging. Developement was supported in part by the National Center
for Research Resources (P41-RR14075, R01 RR16594-01A1 and the NCRR BIRN
Morphometric Project BIRN002, U24 RR021382), the National Institute for
Neurological Disorders and Stroke (R01 NS052585-01), the National Institute of
Biomedical Imaging and Bioengineering, as well as the Mental Illness and
Neuroscience Discovery (MIND) Institute and is part of the National Alliance
for Medical Image Computing (NA-MIC) funded by the National Institutes of
Health through the NIH Roadmap for Medical Research, Grant U54 EB005149. 

Although FreeSurfer binaries can be freely downloaded, the application is
unfortunately not Open Source, and it uses is restricted to non-commercial
applications.

For details, see \url{http://surfer.nmr.mgh.harvard.edu/}.

The application for which these Mesh registration classes were developed was
the registration of brain surfaces that have been mapped to spheres. Surface 
data of this type is available as part of the binary download of Freesurface.

In order to facilitate the use of data generated from FreeSurfer as input to
the Mesh to Mesh registration framework we provide here a reader class that
read FreeSurfer binary files and convert them into itkQuadEdgeMeshes.

The minimalist use of the FreeSurferBinarySurfaceReader class is illustrated by
the source code below.


\begin{lstlisting}

  #include "itkMesh.h"
  #include "itkFreeSurferBinarySurfaceReader.h"

  typedef itk::Mesh<float, 3>                 MeshType;
  typedef itk::FreeSurferBinarySurfaceReader< MeshType >  ReaderType;

  ReaderType::Pointer  surfaceReader = ReaderType::New();

  surfaceReader->SetFileName("lh.pial");
  surfaceReader->SetDataFileName("lh.curv.pial");
  
  surfaceReader->Update();

  MeshType::ConstPointer mesh = surfaceReader->GetOutput();

\end{lstlisting}

Where 

\begin{itemize}
\item ``lh.pial'' is the file containing the geometry and topology of the mesh
\item ``lh.curv.pial'' is the file containing the scalar field associated with points of the mesh
\end{itemize}

In the \code{Examples} directory of the accompanying source code you will find an example called

\begin{verbatim} 
ConvertFreeSurferBinarySurfaceToVTKSurface.cxx
\end{verbatim} 

That, as the name indicates, can read a pair of FreeSurface files and read them
into an itkQuadEdgeMesh, to then save the surface as a VTK legacy file.


\section{How to Perform Registration}

This section illustrates how to put together a Mesh to Mesh registration example. The code presented in this section is available in the subdirectory Examples, in the file

\begin{verbatim} 
MeanSquaresMeshToMeshMetricRegistration1.cxx
\end{verbatim} 

We start by including the headers of the main components of the registration framework

\begin{itemize}
\item Metric
\item Transform
\item RegistrationMethod
\item Interpolator
\item Mesh
\end{itemize}

\begin{center}
\lstinputlisting[linerange={22-27}]{../../Examples/MeanSquaresMeshToMeshMetricRegistration1.cxx}
\end{center}

Then we include headers for auxiliary classes. In particular, 

\begin{itemize}
\item The Command class that will be used to observe the progress of the registration process via events.
\item The Mesh reader that will load the meshes from files.
\end{itemize}

\begin{center}
\lstinputlisting[linerange={29-30}]{../../Examples/MeanSquaresMeshToMeshMetricRegistration1.cxx}
\end{center}

The command observer class is defined in a very similar way to what you may
have already seen in the image registration framework. The code would be almost
identical to what is shown in the ITK Software Guide \cite{ITKSoftwareGuideSecondEdition}

\begin{center}
\lstinputlisting[linerange={33-74}]{../../Examples/MeanSquaresMeshToMeshMetricRegistration1.cxx}
\end{center}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Insert the bibliography using BibTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{InsightJournal}


\end{document}
