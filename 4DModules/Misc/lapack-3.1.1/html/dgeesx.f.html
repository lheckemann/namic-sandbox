<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dgeesx.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DGEESX.1"></a><a href="dgeesx.f.html#DGEESX.1">DGEESX</a>( JOBVS, SORT, SELECT, SENSE, N, A, LDA, SDIM,
     $                   WR, WI, VS, LDVS, RCONDE, RCONDV, WORK, LWORK,
     $                   IWORK, LIWORK, BWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBVS, SENSE, SORT
      INTEGER            INFO, LDA, LDVS, LIWORK, LWORK, N, SDIM
      DOUBLE PRECISION   RCONDE, RCONDV
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      LOGICAL            BWORK( * )
      INTEGER            IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), VS( LDVS, * ), WI( * ), WORK( * ),
     $                   WR( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Function Arguments ..
</span>      LOGICAL            SELECT
      EXTERNAL           SELECT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DGEESX.28"></a><a href="dgeesx.f.html#DGEESX.1">DGEESX</a> computes for an N-by-N real nonsymmetric matrix A, the
</span><span class="comment">*</span><span class="comment">  eigenvalues, the real Schur form T, and, optionally, the matrix of
</span><span class="comment">*</span><span class="comment">  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally, it also orders the eigenvalues on the diagonal of the
</span><span class="comment">*</span><span class="comment">  real Schur form so that selected eigenvalues are at the top left;
</span><span class="comment">*</span><span class="comment">  computes a reciprocal condition number for the average of the
</span><span class="comment">*</span><span class="comment">  selected eigenvalues (RCONDE); and computes a reciprocal condition
</span><span class="comment">*</span><span class="comment">  number for the right invariant subspace corresponding to the
</span><span class="comment">*</span><span class="comment">  selected eigenvalues (RCONDV).  The leading columns of Z form an
</span><span class="comment">*</span><span class="comment">  orthonormal basis for this invariant subspace.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  For further explanation of the reciprocal condition numbers RCONDE
</span><span class="comment">*</span><span class="comment">  and RCONDV, see Section 4.10 of the LAPACK Users' Guide (where
</span><span class="comment">*</span><span class="comment">  these quantities are called s and sep respectively).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A real matrix is in real Schur form if it is upper quasi-triangular
</span><span class="comment">*</span><span class="comment">  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in
</span><span class="comment">*</span><span class="comment">  the form
</span><span class="comment">*</span><span class="comment">            [  a  b  ]
</span><span class="comment">*</span><span class="comment">            [  c  a  ]
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVS   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': Schur vectors are not computed;
</span><span class="comment">*</span><span class="comment">          = 'V': Schur vectors are computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SORT    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies whether or not to order the eigenvalues on the
</span><span class="comment">*</span><span class="comment">          diagonal of the Schur form.
</span><span class="comment">*</span><span class="comment">          = 'N': Eigenvalues are not ordered;
</span><span class="comment">*</span><span class="comment">          = 'S': Eigenvalues are ordered (see SELECT).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
</span><span class="comment">*</span><span class="comment">          SELECT must be declared EXTERNAL in the calling subroutine.
</span><span class="comment">*</span><span class="comment">          If SORT = 'S', SELECT is used to select eigenvalues to sort
</span><span class="comment">*</span><span class="comment">          to the top left of the Schur form.
</span><span class="comment">*</span><span class="comment">          If SORT = 'N', SELECT is not referenced.
</span><span class="comment">*</span><span class="comment">          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
</span><span class="comment">*</span><span class="comment">          SELECT(WR(j),WI(j)) is true; i.e., if either one of a
</span><span class="comment">*</span><span class="comment">          complex conjugate pair of eigenvalues is selected, then both
</span><span class="comment">*</span><span class="comment">          are.  Note that a selected complex eigenvalue may no longer
</span><span class="comment">*</span><span class="comment">          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
</span><span class="comment">*</span><span class="comment">          ordering may change the value of complex eigenvalues
</span><span class="comment">*</span><span class="comment">          (especially if the eigenvalue is ill-conditioned); in this
</span><span class="comment">*</span><span class="comment">          case INFO may be set to N+3 (see INFO below).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SENSE   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Determines which reciprocal condition numbers are computed.
</span><span class="comment">*</span><span class="comment">          = 'N': None are computed;
</span><span class="comment">*</span><span class="comment">          = 'E': Computed for average of selected eigenvalues only;
</span><span class="comment">*</span><span class="comment">          = 'V': Computed for selected right invariant subspace only;
</span><span class="comment">*</span><span class="comment">          = 'B': Computed for both.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E', 'V' or 'B', SORT must equal 'S'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrix A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
</span><span class="comment">*</span><span class="comment">          On entry, the N-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, A is overwritten by its real Schur form T.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SDIM    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          If SORT = 'N', SDIM = 0.
</span><span class="comment">*</span><span class="comment">          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
</span><span class="comment">*</span><span class="comment">                         for which SELECT is true. (Complex conjugate
</span><span class="comment">*</span><span class="comment">                         pairs for which SELECT is true for either
</span><span class="comment">*</span><span class="comment">                         eigenvalue count as 2.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WR      (output) DOUBLE PRECISION array, dimension (N)
</span><span class="comment">*</span><span class="comment">  WI      (output) DOUBLE PRECISION array, dimension (N)
</span><span class="comment">*</span><span class="comment">          WR and WI contain the real and imaginary parts, respectively,
</span><span class="comment">*</span><span class="comment">          of the computed eigenvalues, in the same order that they
</span><span class="comment">*</span><span class="comment">          appear on the diagonal of the output Schur form T.  Complex
</span><span class="comment">*</span><span class="comment">          conjugate pairs of eigenvalues appear consecutively with the
</span><span class="comment">*</span><span class="comment">          eigenvalue having the positive imaginary part first.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
</span><span class="comment">*</span><span class="comment">          If JOBVS = 'V', VS contains the orthogonal matrix Z of Schur
</span><span class="comment">*</span><span class="comment">          vectors.
</span><span class="comment">*</span><span class="comment">          If JOBVS = 'N', VS is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVS    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VS.  LDVS &gt;= 1, and if
</span><span class="comment">*</span><span class="comment">          JOBVS = 'V', LDVS &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDE  (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', RCONDE contains the reciprocal
</span><span class="comment">*</span><span class="comment">          condition number for the average of the selected eigenvalues.
</span><span class="comment">*</span><span class="comment">          Not referenced if SENSE = 'N' or 'V'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDV  (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          If SENSE = 'V' or 'B', RCONDV contains the reciprocal
</span><span class="comment">*</span><span class="comment">          condition number for the selected right invariant subspace.
</span><span class="comment">*</span><span class="comment">          Not referenced if SENSE = 'N' or 'E'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.  LWORK &gt;= max(1,3*N).
</span><span class="comment">*</span><span class="comment">          Also, if SENSE = 'E' or 'V' or 'B',
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= N+2*SDIM*(N-SDIM), where SDIM is the number of
</span><span class="comment">*</span><span class="comment">          selected eigenvalues computed by this routine.  Note that
</span><span class="comment">*</span><span class="comment">          N+2*SDIM*(N-SDIM) &lt;= N+N*N/2. Note also that an error is only
</span><span class="comment">*</span><span class="comment">          returned if LWORK &lt; max(1,3*N), but if SENSE = 'E' or 'V' or
</span><span class="comment">*</span><span class="comment">          'B' this may not be large enough.
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK must generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates upper bounds on the optimal sizes of the
</span><span class="comment">*</span><span class="comment">          arrays WORK and IWORK, returns these values as the first
</span><span class="comment">*</span><span class="comment">          entries of the WORK and IWORK arrays, and no error messages
</span><span class="comment">*</span><span class="comment">          related to LWORK or LIWORK are issued by <a name="XERBLA.148"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LIWORK  (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array IWORK.
</span><span class="comment">*</span><span class="comment">          LIWORK &gt;= 1; if SENSE = 'V' or 'B', LIWORK &gt;= SDIM*(N-SDIM).
</span><span class="comment">*</span><span class="comment">          Note that SDIM*(N-SDIM) &lt;= N*N/4. Note also that an error is
</span><span class="comment">*</span><span class="comment">          only returned if LIWORK &lt; 1, but if SENSE = 'V' or 'B' this
</span><span class="comment">*</span><span class="comment">          may not be large enough.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LIWORK = -1, then a workspace query is assumed; the
</span><span class="comment">*</span><span class="comment">          routine only calculates upper bounds on the optimal sizes of
</span><span class="comment">*</span><span class="comment">          the arrays WORK and IWORK, returns these values as the first
</span><span class="comment">*</span><span class="comment">          entries of the WORK and IWORK arrays, and no error messages
</span><span class="comment">*</span><span class="comment">          related to LWORK or LIWORK are issued by <a name="XERBLA.164"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BWORK   (workspace) LOGICAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          Not referenced if SORT = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0: successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0: if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0: if INFO = i, and i is
</span><span class="comment">*</span><span class="comment">             &lt;= N: the QR algorithm failed to compute all the
</span><span class="comment">*</span><span class="comment">                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
</span><span class="comment">*</span><span class="comment">                   contain those eigenvalues which have converged; if
</span><span class="comment">*</span><span class="comment">                   JOBVS = 'V', VS contains the transformation which
</span><span class="comment">*</span><span class="comment">                   reduces A to its partially converged Schur form.
</span><span class="comment">*</span><span class="comment">             = N+1: the eigenvalues could not be reordered because some
</span><span class="comment">*</span><span class="comment">                   eigenvalues were too close to separate (the problem
</span><span class="comment">*</span><span class="comment">                   is very ill-conditioned);
</span><span class="comment">*</span><span class="comment">             = N+2: after reordering, roundoff changed values of some
</span><span class="comment">*</span><span class="comment">                   complex eigenvalues so that leading eigenvalues in
</span><span class="comment">*</span><span class="comment">                   the Schur form no longer satisfy SELECT=.TRUE.  This
</span><span class="comment">*</span><span class="comment">                   could also be caused by underflow due to scaling.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            CURSL, LASTSL, LQUERY, LST2SL, SCALEA, WANTSB,
     $                   WANTSE, WANTSN, WANTST, WANTSV, WANTVS
      INTEGER            HSWORK, I, I1, I2, IBAL, ICOND, IERR, IEVAL,
     $                   IHI, ILO, INXT, IP, ITAU, IWRK, LIWRK, LWRK,
     $                   MAXWRK, MINWRK
      DOUBLE PRECISION   ANRM, BIGNUM, CSCALE, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           DCOPY, <a name="DGEBAK.204"></a><a href="dgebak.f.html#DGEBAK.1">DGEBAK</a>, <a name="DGEBAL.204"></a><a href="dgebal.f.html#DGEBAL.1">DGEBAL</a>, <a name="DGEHRD.204"></a><a href="dgehrd.f.html#DGEHRD.1">DGEHRD</a>, <a name="DHSEQR.204"></a><a href="dhseqr.f.html#DHSEQR.1">DHSEQR</a>, <a name="DLACPY.204"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>,
     $                   <a name="DLASCL.205"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="DORGHR.205"></a><a href="dorghr.f.html#DORGHR.1">DORGHR</a>, DSWAP, <a name="DTRSEN.205"></a><a href="dtrsen.f.html#DTRSEN.1">DTRSEN</a>, <a name="XERBLA.205"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.208"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.209"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.210"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.210"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
      EXTERNAL           <a name="LSAME.211"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.211"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="DLABAD.211"></a><a href="dlabad.f.html#DLABAD.1">DLABAD</a>, <a name="DLAMCH.211"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.211"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      WANTVS = <a name="LSAME.221"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVS, <span class="string">'V'</span> )
      WANTST = <a name="LSAME.222"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SORT, <span class="string">'S'</span> )
      WANTSN = <a name="LSAME.223"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'N'</span> )
      WANTSE = <a name="LSAME.224"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'E'</span> )
      WANTSV = <a name="LSAME.225"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'V'</span> )
      WANTSB = <a name="LSAME.226"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'B'</span> )
      LQUERY = ( LWORK.EQ.-1 .OR. LIWORK.EQ.-1 )
      IF( ( .NOT.WANTVS ) .AND. ( .NOT.<a name="LSAME.228"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVS, <span class="string">'N'</span> ) ) ) THEN
         INFO = -1
      ELSE IF( ( .NOT.WANTST ) .AND. ( .NOT.<a name="LSAME.230"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SORT, <span class="string">'N'</span> ) ) ) THEN
         INFO = -2
      ELSE IF( .NOT.( WANTSN .OR. WANTSE .OR. WANTSV .OR. WANTSB ) .OR.
     $         ( .NOT.WANTST .AND. .NOT.WANTSN ) ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDVS.LT.1 .OR. ( WANTVS .AND. LDVS.LT.N ) ) THEN
         INFO = -12
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;RWorkspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of real workspace needed at that point in the
</span><span class="comment">*</span><span class="comment">       code, as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       IWorkspace refers to integer workspace.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.249"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.
</span><span class="comment">*</span><span class="comment">       HSWORK refers to the workspace preferred by <a name="DHSEQR.250"></a><a href="dhseqr.f.html#DHSEQR.1">DHSEQR</a>, as
</span><span class="comment">*</span><span class="comment">       calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
</span><span class="comment">*</span><span class="comment">       the worst case.
</span><span class="comment">*</span><span class="comment">       If SENSE = 'E', 'V' or 'B', then the amount of workspace needed
</span><span class="comment">*</span><span class="comment">       depends on SDIM, which is computed by the routine <a name="DTRSEN.254"></a><a href="dtrsen.f.html#DTRSEN.1">DTRSEN</a> later
</span><span class="comment">*</span><span class="comment">       in the code.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         LIWRK = 1
         IF( N.EQ.0 ) THEN
            MINWRK = 1
            LWRK = 1
         ELSE
            MAXWRK = 2*N + N*<a name="ILAENV.263"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEHRD.263"></a><a href="dgehrd.f.html#DGEHRD.1">DGEHRD</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 )
            MINWRK = 3*N
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="DHSEQR.266"></a><a href="dhseqr.f.html#DHSEQR.1">DHSEQR</a>( <span class="string">'S'</span>, JOBVS, N, 1, N, A, LDA, WR, WI, VS, LDVS,
     $             WORK, -1, IEVAL )
            HSWORK = WORK( 1 )
<span class="comment">*</span><span class="comment">
</span>            IF( .NOT.WANTVS ) THEN
               MAXWRK = MAX( MAXWRK, N + HSWORK )
            ELSE
               MAXWRK = MAX( MAXWRK, 2*N + ( N - 1 )*<a name="ILAENV.273"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="DORGHR.274"></a><a href="dorghr.f.html#DORGHR.1">DORGHR</a>'</span>, <span class="string">' '</span>, N, 1, N, -1 ) )
               MAXWRK = MAX( MAXWRK, N + HSWORK )
            END IF
            LWRK = MAXWRK
            IF( .NOT.WANTSN )
     $         LWRK = MAX( LWRK, N + ( N*N )/2 )
            IF( WANTSV .OR. WANTSB )
     $         LIWRK = ( N*N )/4
         END IF
         IWORK( 1 ) = LIWRK
         WORK( 1 ) = LWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -16
         ELSE IF( LIWORK.LT.1 .AND. .NOT.LQUERY ) THEN
            INFO = -18
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.294"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DGEESX.294"></a><a href="dgeesx.f.html#DGEESX.1">DGEESX</a>'</span>, -INFO )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 ) THEN
         SDIM = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.307"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="DLAMCH.308"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> )
      BIGNUM = ONE / SMLNUM
      CALL <a name="DLABAD.310"></a><a href="dlabad.f.html#DLABAD.1">DLABAD</a>( SMLNUM, BIGNUM )
      SMLNUM = SQRT( SMLNUM ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="DLANGE.316"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>( <span class="string">'M'</span>, N, N, A, LDA, DUM )
      SCALEA = .FALSE.
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         SCALEA = .TRUE.
         CSCALE = SMLNUM
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         SCALEA = .TRUE.
         CSCALE = BIGNUM
      END IF
      IF( SCALEA )
     $   CALL <a name="DLASCL.326"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, CSCALE, N, N, A, LDA, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Permute the matrix to make it more nearly triangular
</span><span class="comment">*</span><span class="comment">     (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>      IBAL = 1
      CALL <a name="DGEBAL.332"></a><a href="dgebal.f.html#DGEBAL.1">DGEBAL</a>( <span class="string">'P'</span>, N, A, LDA, ILO, IHI, WORK( IBAL ), IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce to upper Hessenberg form
</span><span class="comment">*</span><span class="comment">     (RWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      ITAU = N + IBAL
      IWRK = N + ITAU
      CALL <a name="DGEHRD.339"></a><a href="dgehrd.f.html#DGEHRD.1">DGEHRD</a>( N, ILO, IHI, A, LDA, WORK( ITAU ), WORK( IWRK ),
     $             LWORK-IWRK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Copy Householder vectors to VS
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLACPY.346"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, N, N, A, LDA, VS, LDVS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate orthogonal matrix in VS
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORGHR.351"></a><a href="dorghr.f.html#DORGHR.1">DORGHR</a>( N, ILO, IHI, VS, LDVS, WORK( ITAU ), WORK( IWRK ),
     $                LWORK-IWRK+1, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      SDIM = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Perform QR iteration, accumulating Schur vectors in VS if desired
</span><span class="comment">*</span><span class="comment">     (RWorkspace: need N+1, prefer N+HSWORK (see comments) )
</span><span class="comment">*</span><span class="comment">
</span>      IWRK = ITAU
      CALL <a name="DHSEQR.361"></a><a href="dhseqr.f.html#DHSEQR.1">DHSEQR</a>( <span class="string">'S'</span>, JOBVS, N, ILO, IHI, A, LDA, WR, WI, VS, LDVS,
     $             WORK( IWRK ), LWORK-IWRK+1, IEVAL )
      IF( IEVAL.GT.0 )
     $   INFO = IEVAL
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Sort eigenvalues if desired
</span><span class="comment">*</span><span class="comment">
</span>      IF( WANTST .AND. INFO.EQ.0 ) THEN
         IF( SCALEA ) THEN
            CALL <a name="DLASCL.370"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, N, 1, WR, N, IERR )
            CALL <a name="DLASCL.371"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, N, 1, WI, N, IERR )
         END IF
         DO 10 I = 1, N
            BWORK( I ) = SELECT( WR( I ), WI( I ) )
   10    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Reorder eigenvalues, transform Schur vectors, and compute
</span><span class="comment">*</span><span class="comment">        reciprocal condition numbers
</span><span class="comment">*</span><span class="comment">        (RWorkspace: if SENSE is not 'N', need N+2*SDIM*(N-SDIM)
</span><span class="comment">*</span><span class="comment">                     otherwise, need N )
</span><span class="comment">*</span><span class="comment">        (IWorkspace: if SENSE is 'V' or 'B', need SDIM*(N-SDIM)
</span><span class="comment">*</span><span class="comment">                     otherwise, need 0 )
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DTRSEN.384"></a><a href="dtrsen.f.html#DTRSEN.1">DTRSEN</a>( SENSE, JOBVS, BWORK, N, A, LDA, VS, LDVS, WR, WI,
     $                SDIM, RCONDE, RCONDV, WORK( IWRK ), LWORK-IWRK+1,
     $                IWORK, LIWORK, ICOND )
         IF( .NOT.WANTSN )
     $      MAXWRK = MAX( MAXWRK, N+2*SDIM*( N-SDIM ) )
         IF( ICOND.EQ.-15 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Not enough real workspace
</span><span class="comment">*</span><span class="comment">
</span>            INFO = -16
         ELSE IF( ICOND.EQ.-17 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Not enough integer workspace
</span><span class="comment">*</span><span class="comment">
</span>            INFO = -18
         ELSE IF( ICOND.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           <a name="DTRSEN.401"></a><a href="dtrsen.f.html#DTRSEN.1">DTRSEN</a> failed to reorder or to restore standard Schur form
</span><span class="comment">*</span><span class="comment">
</span>            INFO = ICOND + N
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo balancing
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DGEBAK.412"></a><a href="dgebak.f.html#DGEBAK.1">DGEBAK</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, N, ILO, IHI, WORK( IBAL ), N, VS, LDVS,
     $                IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( SCALEA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo scaling for the Schur form of A
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASCL.420"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'H'</span>, 0, 0, CSCALE, ANRM, N, N, A, LDA, IERR )
         CALL DCOPY( N, A, LDA+1, WR, 1 )
         IF( ( WANTSV .OR. WANTSB ) .AND. INFO.EQ.0 ) THEN
            DUM( 1 ) = RCONDV
            CALL <a name="DLASCL.424"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, 1, 1, DUM, 1, IERR )
            RCONDV = DUM( 1 )
         END IF
         IF( CSCALE.EQ.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           If scaling back towards underflow, adjust WI if an
</span><span class="comment">*</span><span class="comment">           offdiagonal element of a 2-by-2 block in the Schur form
</span><span class="comment">*</span><span class="comment">           underflows.
</span><span class="comment">*</span><span class="comment">
</span>            IF( IEVAL.GT.0 ) THEN
               I1 = IEVAL + 1
               I2 = IHI - 1
               CALL <a name="DLASCL.436"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, ILO-1, 1, WI, N,
     $                      IERR )
            ELSE IF( WANTST ) THEN
               I1 = 1
               I2 = N - 1
            ELSE
               I1 = ILO
               I2 = IHI - 1
            END IF
            INXT = I1 - 1
            DO 20 I = I1, I2
               IF( I.LT.INXT )
     $            GO TO 20
               IF( WI( I ).EQ.ZERO ) THEN
                  INXT = I + 1
               ELSE
                  IF( A( I+1, I ).EQ.ZERO ) THEN
                     WI( I ) = ZERO
                     WI( I+1 ) = ZERO
                  ELSE IF( A( I+1, I ).NE.ZERO .AND. A( I, I+1 ).EQ.
     $                     ZERO ) THEN
                     WI( I ) = ZERO
                     WI( I+1 ) = ZERO
                     IF( I.GT.1 )
     $                  CALL DSWAP( I-1, A( 1, I ), 1, A( 1, I+1 ), 1 )
                     IF( N.GT.I+1 )
     $                  CALL DSWAP( N-I-1, A( I, I+2 ), LDA,
     $                              A( I+1, I+2 ), LDA )
                     CALL DSWAP( N, VS( 1, I ), 1, VS( 1, I+1 ), 1 )
                     A( I, I+1 ) = A( I+1, I )
                     A( I+1, I ) = ZERO
                  END IF
                  INXT = I + 2
               END IF
   20       CONTINUE
         END IF
         CALL <a name="DLASCL.472"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, N-IEVAL, 1,
     $                WI( IEVAL+1 ), MAX( N-IEVAL, 1 ), IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( WANTST .AND. INFO.EQ.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check if reordering successful
</span><span class="comment">*</span><span class="comment">
</span>         LASTSL = .TRUE.
         LST2SL = .TRUE.
         SDIM = 0
         IP = 0
         DO 30 I = 1, N
            CURSL = SELECT( WR( I ), WI( I ) )
            IF( WI( I ).EQ.ZERO ) THEN
               IF( CURSL )
     $            SDIM = SDIM + 1
               IP = 0
               IF( CURSL .AND. .NOT.LASTSL )
     $            INFO = N + 2
            ELSE
               IF( IP.EQ.1 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Last eigenvalue of conjugate pair
</span><span class="comment">*</span><span class="comment">
</span>                  CURSL = CURSL .OR. LASTSL
                  LASTSL = CURSL
                  IF( CURSL )
     $               SDIM = SDIM + 2
                  IP = -1
                  IF( CURSL .AND. .NOT.LST2SL )
     $               INFO = N + 2
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 First eigenvalue of conjugate pair
</span><span class="comment">*</span><span class="comment">
</span>                  IP = 1
               END IF
            END IF
            LST2SL = LASTSL
            LASTSL = CURSL
   30    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
      IF( WANTSV .OR. WANTSB ) THEN
         IWORK( 1 ) = MAX( 1, SDIM*( N-SDIM ) )
      ELSE
         IWORK( 1 ) = 1
      END IF
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DGEESX.525"></a><a href="dgeesx.f.html#DGEESX.1">DGEESX</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
