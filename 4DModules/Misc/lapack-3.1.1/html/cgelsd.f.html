<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>cgelsd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="CGELSD.1"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a>( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
     $                   WORK, LWORK, RWORK, IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
      REAL               RCOND
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      REAL               RWORK( * ), S( * )
      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="CGELSD.21"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a> computes the minimum-norm solution to a real linear least
</span><span class="comment">*</span><span class="comment">  squares problem:
</span><span class="comment">*</span><span class="comment">      minimize 2-norm(| b - A*x |)
</span><span class="comment">*</span><span class="comment">  using the singular value decomposition (SVD) of A. A is an M-by-N
</span><span class="comment">*</span><span class="comment">  matrix which may be rank-deficient.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Several right hand side vectors b and solution vectors x can be
</span><span class="comment">*</span><span class="comment">  handled in a single call; they are stored as the columns of the
</span><span class="comment">*</span><span class="comment">  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
</span><span class="comment">*</span><span class="comment">  matrix X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The problem is solved in three steps:
</span><span class="comment">*</span><span class="comment">  (1) Reduce the coefficient matrix A to bidiagonal form with
</span><span class="comment">*</span><span class="comment">      Householder tranformations, reducing the original problem
</span><span class="comment">*</span><span class="comment">      into a &quot;bidiagonal least squares problem&quot; (BLS)
</span><span class="comment">*</span><span class="comment">  (2) Solve the BLS using a divide and conquer approach.
</span><span class="comment">*</span><span class="comment">  (3) Apply back all the Householder tranformations to solve
</span><span class="comment">*</span><span class="comment">      the original least squares problem.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The effective rank of A is determined by treating as zero those
</span><span class="comment">*</span><span class="comment">  singular values which are less than RCOND times the largest singular
</span><span class="comment">*</span><span class="comment">  value.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The divide and conquer algorithm makes very mild assumptions about
</span><span class="comment">*</span><span class="comment">  floating point arithmetic. It will work on machines with a guard
</span><span class="comment">*</span><span class="comment">  digit in add/subtract, or on those binary machines without guard
</span><span class="comment">*</span><span class="comment">  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
</span><span class="comment">*</span><span class="comment">  Cray-2. It could conceivably fail on hexadecimal or decimal machines
</span><span class="comment">*</span><span class="comment">  without guard digits, but we know of none.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the matrix A. M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the matrix A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  NRHS    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of right hand sides, i.e., the number of columns
</span><span class="comment">*</span><span class="comment">          of the matrices B and X. NRHS &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, A has been destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-NRHS right hand side matrix B.
</span><span class="comment">*</span><span class="comment">          On exit, B is overwritten by the N-by-NRHS solution matrix X.
</span><span class="comment">*</span><span class="comment">          If m &gt;= n and RANK = n, the residual sum-of-squares for
</span><span class="comment">*</span><span class="comment">          the solution in the i-th column is given by the sum of
</span><span class="comment">*</span><span class="comment">          squares of the modulus of elements n+1:m in that column.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B.  LDB &gt;= max(1,M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) REAL array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A in decreasing order.
</span><span class="comment">*</span><span class="comment">          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCOND   (input) REAL
</span><span class="comment">*</span><span class="comment">          RCOND is used to determine the effective rank of A.
</span><span class="comment">*</span><span class="comment">          Singular values S(i) &lt;= RCOND*S(1) are treated as zero.
</span><span class="comment">*</span><span class="comment">          If RCOND &lt; 0, machine precision is used instead.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RANK    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The effective rank of A, i.e., the number of singular values
</span><span class="comment">*</span><span class="comment">          which are greater than RCOND*S(1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK must be at least 1.
</span><span class="comment">*</span><span class="comment">          The exact minimum amount of workspace needed depends on M,
</span><span class="comment">*</span><span class="comment">          N and NRHS. As long as LWORK is at least
</span><span class="comment">*</span><span class="comment">              2 * N + N * NRHS
</span><span class="comment">*</span><span class="comment">          if M is greater than or equal to N or
</span><span class="comment">*</span><span class="comment">              2 * M + M * NRHS
</span><span class="comment">*</span><span class="comment">          if M is less than N, the code will execute correctly.
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the array WORK and the
</span><span class="comment">*</span><span class="comment">          minimum sizes of the arrays RWORK and IWORK, and returns
</span><span class="comment">*</span><span class="comment">          these values as the first entries of the WORK, RWORK and
</span><span class="comment">*</span><span class="comment">          IWORK arrays, and no error message related to LWORK is issued
</span><span class="comment">*</span><span class="comment">          by <a name="XERBLA.112"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))
</span><span class="comment">*</span><span class="comment">          LRWORK &gt;=
</span><span class="comment">*</span><span class="comment">             10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
</span><span class="comment">*</span><span class="comment">             (SMLSIZ+1)**2
</span><span class="comment">*</span><span class="comment">          if M is greater than or equal to N or
</span><span class="comment">*</span><span class="comment">             10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
</span><span class="comment">*</span><span class="comment">             (SMLSIZ+1)**2
</span><span class="comment">*</span><span class="comment">          if M is less than N, the code will execute correctly.
</span><span class="comment">*</span><span class="comment">          SMLSIZ is returned by <a name="ILAENV.122"></a><a href="hfy-index.html#ILAENV">ILAENV</a> and is equal to the maximum
</span><span class="comment">*</span><span class="comment">          size of the subproblems at the bottom of the computation
</span><span class="comment">*</span><span class="comment">          tree (usually about 25), and
</span><span class="comment">*</span><span class="comment">             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
</span><span class="comment">*</span><span class="comment">          LIWORK &gt;= max(1, 3*MINMN*NLVL + 11*MINMN),
</span><span class="comment">*</span><span class="comment">          where MINMN = MIN( M,N ).
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0: successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0: if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  the algorithm for computing the SVD failed to converge;
</span><span class="comment">*</span><span class="comment">                if INFO = i, i off-diagonal elements of an intermediate
</span><span class="comment">*</span><span class="comment">                bidiagonal form did not converge to zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Ming Gu and Ren-Cang Li, Computer Science Division, University of
</span><span class="comment">*</span><span class="comment">       California at Berkeley, USA
</span><span class="comment">*</span><span class="comment">     Osni Marques, LBNL/NERSC, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE, TWO
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0, TWO = 2.0E+0 )
      COMPLEX            CZERO
      PARAMETER          ( CZERO = ( 0.0E+0, 0.0E+0 ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY
      INTEGER            IASCL, IBSCL, IE, IL, ITAU, ITAUP, ITAUQ,
     $                   LDWORK, LIWORK, LRWORK, MAXMN, MAXWRK, MINMN,
     $                   MINWRK, MM, MNTHR, NLVL, NRWORK, NWORK, SMLSIZ
      REAL               ANRM, BIGNUM, BNRM, EPS, SFMIN, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="CGEBRD.164"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>, <a name="CGELQF.164"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>, <a name="CGEQRF.164"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CLACPY.164"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>,
     $                   <a name="CLALSD.165"></a><a href="clalsd.f.html#CLALSD.1">CLALSD</a>, <a name="CLASCL.165"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>, <a name="CLASET.165"></a><a href="claset.f.html#CLASET.1">CLASET</a>, <a name="CUNMBR.165"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>,
     $                   <a name="CUNMLQ.166"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>, <a name="CUNMQR.166"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, <a name="SLABAD.166"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>, <a name="SLASCL.166"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>,
     $                   <a name="SLASET.167"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="XERBLA.167"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.170"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="CLANGE.171"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.171"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      EXTERNAL           <a name="CLANGE.172"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.172"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="ILAENV.172"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          INT, LOG, MAX, MIN, REAL
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments.
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      MAXMN = MAX( M, N )
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, MAXMN ) ) THEN
         INFO = -7
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace.
</span><span class="comment">*</span><span class="comment">     (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">     minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">     as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">     NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">     following subroutine, as returned by <a name="ILAENV.202"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         LIWORK = 1
         LRWORK = 1
         IF( MINMN.GT.0 ) THEN
            SMLSIZ = <a name="ILAENV.210"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 9, <span class="string">'<a name="CGELSD.210"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a>'</span>, <span class="string">' '</span>, 0, 0, 0, 0 )
            MNTHR = <a name="ILAENV.211"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="CGELSD.211"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a>'</span>, <span class="string">' '</span>, M, N, NRHS, -1 )
            NLVL = MAX( INT( LOG( REAL( MINMN ) / REAL( SMLSIZ + 1 ) ) /
     $                  LOG( TWO ) ) + 1, 0 )
            LIWORK = 3*MINMN*NLVL + 11*MINMN
            MM = M
            IF( M.GE.N .AND. M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1a - overdetermined, with many more rows than
</span><span class="comment">*</span><span class="comment">                        columns.
</span><span class="comment">*</span><span class="comment">
</span>               MM = N
               MAXWRK = MAX( MAXWRK, N*<a name="ILAENV.222"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEQRF.222"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>'</span>, <span class="string">' '</span>, M, N,
     $                       -1, -1 ) )
               MAXWRK = MAX( MAXWRK, NRHS*<a name="ILAENV.224"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMQR.224"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>'</span>, <span class="string">'LC'</span>, M,
     $                       NRHS, N, -1 ) )
            END IF
            IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 - overdetermined or exactly determined.
</span><span class="comment">*</span><span class="comment">
</span>               LRWORK = 10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +
     $                  ( SMLSIZ + 1 )**2
               MAXWRK = MAX( MAXWRK, 2*N + ( MM + N )*<a name="ILAENV.233"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="CGEBRD.234"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, MM, N, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, 2*N + NRHS*<a name="ILAENV.235"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMBR.235"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>,
     $                       <span class="string">'QLC'</span>, MM, NRHS, N, -1 ) )
               MAXWRK = MAX( MAXWRK, 2*N + ( N - 1 )*<a name="ILAENV.237"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="CUNMBR.238"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>, <span class="string">'PLN'</span>, N, NRHS, N, -1 ) )
               MAXWRK = MAX( MAXWRK, 2*N + N*NRHS )
               MINWRK = MAX( 2*N + MM, 2*N + N*NRHS )
            END IF
            IF( N.GT.M ) THEN
               LRWORK = 10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +
     $                  ( SMLSIZ + 1 )**2
               IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2a - underdetermined, with many more columns
</span><span class="comment">*</span><span class="comment">                           than rows.
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.250"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGELQF.250"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + 2*M*<a name="ILAENV.252"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CGEBRD.253"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + NRHS*<a name="ILAENV.254"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CUNMBR.255"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>, <span class="string">'QLC'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + ( M - 1 )*<a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CUNMLQ.257"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>'</span>, <span class="string">'LC'</span>, N, NRHS, M, -1 ) )
                  IF( NRHS.GT.1 ) THEN
                     MAXWRK = MAX( MAXWRK, M*M + M + M*NRHS )
                  ELSE
                     MAXWRK = MAX( MAXWRK, M*M + 2*M )
                  END IF
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + M*NRHS )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 - underdetermined.
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = 2*M + ( N + M )*<a name="ILAENV.268"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEBRD.268"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, M,
     $                     N, -1, -1 )
                  MAXWRK = MAX( MAXWRK, 2*M + NRHS*<a name="ILAENV.270"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMBR.270"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>,
     $                          <span class="string">'QLC'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M + M*<a name="ILAENV.272"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMBR.272"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>,
     $                          <span class="string">'PLN'</span>, N, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M + M*NRHS )
               END IF
               MINWRK = MAX( 2*M + N, 2*M + M*NRHS )
            END IF
         END IF
         MINWRK = MIN( MINWRK, MAXWRK )
         WORK( 1 ) = MAXWRK
         IWORK( 1 ) = LIWORK
         RWORK( 1 ) = LRWORK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -12
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.290"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="CGELSD.290"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RANK = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine parameters.
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.305"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SFMIN = <a name="SLAMCH.306"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      SMLNUM = SFMIN / EPS
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.309"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max entry outside range [SMLNUM,BIGNUM].
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="CLANGE.313"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, RWORK )
      IASCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.319"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, INFO )
         IASCL = 1
      ELSE IF( ANRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.325"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, INFO )
         IASCL = 2
      ELSE IF( ANRM.EQ.ZERO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Matrix all zero. Return zero solution.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASET.331"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, MAX( M, N ), NRHS, CZERO, CZERO, B, LDB )
         CALL <a name="SLASET.332"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, MINMN, 1, ZERO, ZERO, S, 1 )
         RANK = 0
         GO TO 10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max entry outside range [SMLNUM,BIGNUM].
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="CLANGE.339"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, M, NRHS, B, LDB, RWORK )
      IBSCL = 0
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.345"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, SMLNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 1
      ELSE IF( BNRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.351"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BIGNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 2
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If M &lt; N make sure B(M+1:N,:) = 0
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.LT.N )
     $   CALL <a name="CLASET.358"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, N-M, NRHS, CZERO, CZERO, B( M+1, 1 ), LDB )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Overdetermined case.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 1 - overdetermined or exactly determined.
</span><span class="comment">*</span><span class="comment">
</span>         MM = M
         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1a - overdetermined, with many more rows than columns
</span><span class="comment">*</span><span class="comment">
</span>            MM = N
            ITAU = 1
            NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute A=Q*R.
</span><span class="comment">*</span><span class="comment">           (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="CGEQRF.379"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                   LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Multiply B by transpose(Q).
</span><span class="comment">*</span><span class="comment">           (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need NRHS, prefer NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="CUNMQR.386"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, N, A, LDA, WORK( ITAU ), B,
     $                   LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Zero out below R.
</span><span class="comment">*</span><span class="comment">
</span>            IF( N.GT.1 ) THEN
               CALL <a name="CLASET.392"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, A( 2, 1 ),
     $                      LDA )
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         ITAUQ = 1
         ITAUP = ITAUQ + N
         NWORK = ITAUP + N
         IE = 1
         NRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize R in A.
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N+MM, prefer 2*N+(MM+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.407"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( MM, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of R.
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N+NRHS, prefer 2*N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.414"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, MM, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLALSD.419"></a><a href="clalsd.f.html#CLALSD.1">CLALSD</a>( <span class="string">'U'</span>, SMLSIZ, N, NRHS, S, RWORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), RWORK( NRWORK ),
     $                IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of R.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.428"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, NRHS, N, A, LDA, WORK( ITAUP ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( N.GE.MNTHR .AND. LWORK.GE.4*M+M*M+
     $         MAX( M, 2*M-4, NRHS, N-3*M ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2a - underdetermined, with many more columns than rows
</span><span class="comment">*</span><span class="comment">        and sufficient workspace for an efficient algorithm.
</span><span class="comment">*</span><span class="comment">
</span>         LDWORK = M
         IF( LWORK.GE.MAX( 4*M+M*LDA+MAX( M, 2*M-4, NRHS, N-3*M ),
     $       M*LDA+M+M*NRHS ) )LDWORK = LDA
         ITAU = 1
         NWORK = M + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute A=L*Q.
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGELQF.446"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
         IL = NWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Copy L to WORK(IL), zeroing out above its diagonal.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLACPY.452"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWORK )
         CALL <a name="CLASET.453"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, WORK( IL+LDWORK ),
     $                LDWORK )
         ITAUQ = IL + LDWORK*M
         ITAUP = ITAUQ + M
         NWORK = ITAUP + M
         IE = 1
         NRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize L in WORK(IL).
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+4*M, prefer M*M+4*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.465"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( M, M, WORK( IL ), LDWORK, S, RWORK( IE ),
     $                WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of L.
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.472"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUQ ), B, LDB, WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLALSD.478"></a><a href="clalsd.f.html#CLALSD.1">CLALSD</a>( <span class="string">'U'</span>, SMLSIZ, M, NRHS, S, RWORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), RWORK( NRWORK ),
     $                IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of L.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.487"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUP ), B, LDB, WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Zero out below first M rows of B.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASET.493"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, N-M, NRHS, CZERO, CZERO, B( M+1, 1 ), LDB )
         NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply transpose(Q) by B.
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need NRHS, prefer NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMLQ.499"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, N, NRHS, M, A, LDA, WORK( ITAU ), B,
     $                LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2 - remaining underdetermined cases.
</span><span class="comment">*</span><span class="comment">
</span>         ITAUQ = 1
         ITAUP = ITAUQ + M
         NWORK = ITAUP + M
         IE = 1
         NRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize A.
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.516"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors.
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*M+NRHS, prefer 2*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.523"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLALSD.528"></a><a href="clalsd.f.html#CLALSD.1">CLALSD</a>( <span class="string">'L'</span>, SMLSIZ, M, NRHS, S, RWORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), RWORK( NRWORK ),
     $                IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of A.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.537"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, NRHS, M, A, LDA, WORK( ITAUP ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling.
</span><span class="comment">*</span><span class="comment">
</span>      IF( IASCL.EQ.1 ) THEN
         CALL <a name="CLASCL.545"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.546"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      ELSE IF( IASCL.EQ.2 ) THEN
         CALL <a name="CLASCL.549"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.550"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      END IF
      IF( IBSCL.EQ.1 ) THEN
         CALL <a name="CLASCL.554"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, BNRM, N, NRHS, B, LDB, INFO )
      ELSE IF( IBSCL.EQ.2 ) THEN
         CALL <a name="CLASCL.556"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, BNRM, N, NRHS, B, LDB, INFO )
      END IF
<span class="comment">*</span><span class="comment">
</span>   10 CONTINUE
      WORK( 1 ) = MAXWRK
      IWORK( 1 ) = LIWORK
      RWORK( 1 ) = LRWORK
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="CGELSD.565"></a><a href="cgelsd.f.html#CGELSD.1">CGELSD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
