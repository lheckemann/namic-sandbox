<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>zgesvd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="ZGESVD.1"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a>( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
     $                   WORK, LWORK, RWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBU, JOBVT
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      DOUBLE PRECISION   RWORK( * ), S( * )
      COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),
     $                   WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZGESVD.21"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a> computes the singular value decomposition (SVD) of a complex
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and/or right singular
</span><span class="comment">*</span><span class="comment">  vectors. The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * conjugate-transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns V**H, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBU    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U are returned in array U:
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array U;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U (no left singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVT   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix
</span><span class="comment">*</span><span class="comment">          V**H:
</span><span class="comment">*</span><span class="comment">          = 'A':  all N rows of V**H are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) rows of V**H (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) rows of V**H (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no rows of V**H (no right singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          JOBVT and JOBU cannot both be 'O'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBU = 'O',  A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          columns of U (the left singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'O', A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          rows of V**H (the right singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
</span><span class="comment">*</span><span class="comment">                          are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBU = 'A', U contains the M-by-M unitary matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBU = 'S', U contains the first min(m,n) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBU = 'N' or 'O', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBU = 'S' or 'A', LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) COMPLEX*16 array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBVT = 'A', VT contains the N-by-N unitary matrix
</span><span class="comment">*</span><span class="comment">          V**H;
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'S', VT contains the first min(m,n) rows of
</span><span class="comment">*</span><span class="comment">          V**H (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'N' or 'O', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.
</span><span class="comment">*</span><span class="comment">          LWORK &gt;=  MAX(1,2*MIN(M,N)+MAX(M,N)).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.119"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO &gt; 0, RWORK(1:MIN(M,N)-1) contains the
</span><span class="comment">*</span><span class="comment">          unconverged superdiagonal elements of an upper bidiagonal
</span><span class="comment">*</span><span class="comment">          matrix B whose diagonal is in S (not necessarily sorted).
</span><span class="comment">*</span><span class="comment">          B satisfies A = U * B * VT, so it has the same singular
</span><span class="comment">*</span><span class="comment">          values as A, and singular vectors related by U and VT.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  if <a name="ZBDSQR.131"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a> did not converge, INFO specifies how many
</span><span class="comment">*</span><span class="comment">                superdiagonals of an intermediate bidiagonal form B
</span><span class="comment">*</span><span class="comment">                did not converge to zero. See the description of RWORK
</span><span class="comment">*</span><span class="comment">                above for details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      COMPLEX*16         CZERO, CONE
      PARAMETER          ( CZERO = ( 0.0D0, 0.0D0 ),
     $                   CONE = ( 1.0D0, 0.0D0 ) )
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, WNTUA, WNTUAS, WNTUN, WNTUO, WNTUS,
     $                   WNTVA, WNTVAS, WNTVN, WNTVO, WNTVS
      INTEGER            BLK, CHUNK, I, IE, IERR, IR, IRWORK, ISCL,
     $                   ITAU, ITAUP, ITAUQ, IU, IWORK, LDWRKR, LDWRKU,
     $                   MAXWRK, MINMN, MINWRK, MNTHR, NCU, NCVT, NRU,
     $                   NRVT, WRKBL
      DOUBLE PRECISION   ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   DUM( 1 )
      COMPLEX*16         CDUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DLASCL.159"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="XERBLA.159"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>, <a name="ZBDSQR.159"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>, <a name="ZGEBRD.159"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>, <a name="ZGELQF.159"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>, ZGEMM,
     $                   <a name="ZGEQRF.160"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>, <a name="ZLACPY.160"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>, <a name="ZLASCL.160"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>, <a name="ZLASET.160"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>, <a name="ZUNGBR.160"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>, <a name="ZUNGLQ.160"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>,
     $                   <a name="ZUNGQR.161"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>, <a name="ZUNMBR.161"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.164"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.165"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.166"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="ZLANGE.166"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>
      EXTERNAL           <a name="LSAME.167"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.167"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="DLAMCH.167"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="ZLANGE.167"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      WNTUA = <a name="LSAME.178"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'A'</span> )
      WNTUS = <a name="LSAME.179"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'S'</span> )
      WNTUAS = WNTUA .OR. WNTUS
      WNTUO = <a name="LSAME.181"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'O'</span> )
      WNTUN = <a name="LSAME.182"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'N'</span> )
      WNTVA = <a name="LSAME.183"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'A'</span> )
      WNTVS = <a name="LSAME.184"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'S'</span> )
      WNTVAS = WNTVA .OR. WNTVS
      WNTVO = <a name="LSAME.186"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'O'</span> )
      WNTVN = <a name="LSAME.187"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTUA .OR. WNTUS .OR. WNTUO .OR. WNTUN ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( WNTVA .OR. WNTVS .OR. WNTVO .OR. WNTVN ) .OR.
     $         ( WNTVO .AND. WNTUO ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LDU.LT.1 .OR. ( WNTUAS .AND. LDU.LT.M ) ) THEN
         INFO = -9
      ELSE IF( LDVT.LT.1 .OR. ( WNTVA .AND. LDVT.LT.N ) .OR.
     $         ( WNTVS .AND. LDVT.LT.MINMN ) ) THEN
         INFO = -11
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       CWorkspace refers to complex workspace, and RWorkspace to
</span><span class="comment">*</span><span class="comment">       real workspace. NB refers to the optimal block size for the
</span><span class="comment">*</span><span class="comment">       immediately following subroutine, as returned by <a name="ILAENV.214"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Space needed for <a name="ZBDSQR.221"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a> is BDSPAC = 5*N
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.223"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="ZGESVD.223"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            IF( M.GE.MNTHR ) THEN
               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = N + N*<a name="ILAENV.229"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.229"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 2*N+2*N*
     $                     <a name="ILAENV.232"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.232"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  IF( WNTVO .OR. WNTVAS )
     $               MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*
     $                        <a name="ILAENV.235"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.235"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MINWRK = 3*N
               ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.241"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.242"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.242"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.245"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.245"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.247"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.247"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N )
                  MINWRK = 2*N + M
               ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.255"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.255"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.256"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.259"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.259"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.261"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.261"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*
     $                    <a name="ILAENV.263"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.263"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N )
                  MINWRK = 2*N + M
               ELSE IF( WNTUS .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.270"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.270"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.271"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.271"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.274"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.274"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.276"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.276"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = 2*N + M
               ELSE IF( WNTUS .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.283"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.283"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.284"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.284"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.287"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.287"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.289"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.289"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*
     $                    <a name="ILAENV.291"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.291"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = 2*N + M
               ELSE IF( WNTUS .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.299"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.299"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.300"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.300"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.303"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.303"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.305"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.305"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*
     $                    <a name="ILAENV.307"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.307"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = 2*N + M
               ELSE IF( WNTUA .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.314"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.314"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.315"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.315"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.318"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.318"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.320"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.320"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = 2*N + M
               ELSE IF( WNTUA .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.327"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.327"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.328"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.328"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.331"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.331"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.333"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.333"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*
     $                    <a name="ILAENV.335"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.335"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = 2*N + M
               ELSE IF( WNTUA .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.343"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.343"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.344"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.344"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.347"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.347"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.349"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.349"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+( N-1 )*
     $                    <a name="ILAENV.351"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.351"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = 2*N + M
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*N + ( M+N )*<a name="ILAENV.359"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.359"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTUS .OR. WNTUO )
     $            MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.363"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.363"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, N, N, -1 ) )
               IF( WNTUA )
     $            MAXWRK = MAX( MAXWRK, 2*N+M*
     $                     <a name="ILAENV.366"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.366"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               IF( .NOT.WNTVN )
     $            MAXWRK = MAX( MAXWRK, 2*N+( N-1 )*
     $                     <a name="ILAENV.369"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.369"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
               MINWRK = 2*N + M
            END IF
         ELSE IF( MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Space needed for <a name="ZBDSQR.374"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a> is BDSPAC = 5*M
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.376"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="ZGESVD.376"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            IF( N.GE.MNTHR ) THEN
               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.382"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.382"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 2*M+2*M*
     $                     <a name="ILAENV.385"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.385"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  IF( WNTUO .OR. WNTUAS )
     $               MAXWRK = MAX( MAXWRK, 2*M+M*
     $                        <a name="ILAENV.388"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.388"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MINWRK = 3*M
               ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.394"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.394"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.395"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.395"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.398"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.398"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.400"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.400"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N )
                  MINWRK = 2*M + N
               ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.408"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.408"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.409"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.409"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.412"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.412"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.414"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.416"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.416"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N )
                  MINWRK = 2*M + N
               ELSE IF( WNTVS .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.423"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.423"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.424"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.424"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.427"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.427"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.429"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.429"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = 2*M + N
               ELSE IF( WNTVS .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.436"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.436"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.437"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.437"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.440"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.440"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.442"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.442"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.444"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.444"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = 2*M + N
               ELSE IF( WNTVS .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.452"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.452"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.453"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.453"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.456"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.456"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.458"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.458"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.460"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.460"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = 2*M + N
               ELSE IF( WNTVA .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.467"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.467"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.468"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.468"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.471"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.471"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.473"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.473"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = 2*M + N
               ELSE IF( WNTVA .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.480"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.480"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.481"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.481"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.484"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.484"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.486"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.486"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.488"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.488"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = 2*M + N
               ELSE IF( WNTVA .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.496"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.496"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.497"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.497"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.500"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.500"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+( M-1 )*
     $                    <a name="ILAENV.502"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.502"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.504"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.504"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = 2*M + N
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*M + ( M+N )*<a name="ILAENV.512"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.512"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTVS .OR. WNTVO )
     $            MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.516"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.516"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, N, M, -1 ) )
               IF( WNTVA )
     $            MAXWRK = MAX( MAXWRK, 2*M+N*
     $                     <a name="ILAENV.519"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.519"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, M, -1 ) )
               IF( .NOT.WNTUN )
     $            MAXWRK = MAX( MAXWRK, 2*M+( M-1 )*
     $                     <a name="ILAENV.522"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.522"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
               MINWRK = 2*M + N
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -13
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.535"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="ZGESVD.535"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.549"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="DLAMCH.550"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="ZLANGE.555"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="ZLASCL.559"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="ZLASCL.562"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">              No left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEQRF.585"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.590"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, A( 2, 1 ),
     $                      LDA )
               IE = 1
               ITAUQ = 1
               ITAUP = ITAUQ + N
               IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.601"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               NCVT = 0
               IF( WNTVO .OR. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If right singular vectors desired, generate P'.
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.611"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  NCVT = N
               END IF
               IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.622"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, NCVT, 0, 0, S, RWORK( IE ), A, LDA,
     $                      CDUM, 1, CDUM, 1, RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTVAS )
     $            CALL <a name="ZLACPY.628"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEQRF.667"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to WORK(IR) and zero out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.672"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="ZLASET.673"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                         WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGQR.680"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.691"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.699"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.709"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, RWORK( IE ), CDUM, 1,
     $                         WORK( IR ), LDWRKR, CDUM, 1,
     $                         RWORK( IRWORK ), INFO )
                  IU = ITAUQ
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 10 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, CONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, CZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="ZLACPY.724"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   10             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = 1
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: N)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.741"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.749"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.758"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, RWORK( IE ), CDUM, 1,
     $                         A, LDA, CDUM, 1, RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEQRF.800"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.805"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="ZLASET.807"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGQR.814"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.825"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, VT, LDVT, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="ZLACPY.828"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, N, N, VT, LDVT, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.834"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+3*N-1, prefer N*N+2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.842"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR) and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.852"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, RWORK( IE ), VT,
     $                         LDVT, WORK( IR ), LDWRKR, CDUM, 1,
     $                         RWORK( IRWORK ), INFO )
                  IU = ITAUQ
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N+N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 20 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, CONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, CZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="ZLACPY.867"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEQRF.882"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.887"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="ZLASET.889"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGQR.896"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: N)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.907"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, VT, LDVT, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNMBR.915"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                         WORK( ITAUQ ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.923"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.933"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, RWORK( IE ), VT,
     $                         LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),
     $                         INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.970"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.975"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="ZLASET.977"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.984"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.995"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1004"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1014"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, RWORK( IE ), CDUM,
     $                            1, WORK( IR ), LDWRKR, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, A, LDA,
     $                           WORK( IR ), LDWRKR, CZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1037"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1039"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1045"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.1054"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            A( 2, 1 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1061"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1069"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1079"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, RWORK( IE ), CDUM,
     $                            1, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1125"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1130"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.1132"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1139"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*N*N+3*N,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need   N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1152"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1156"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1163"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*N*N+3*N-1,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*N*N+2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1172"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1183"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, RWORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, A, LDA,
     $                           WORK( IU ), LDWRKU, CZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R to A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1200"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1214"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1216"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1222"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.1231"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            A( 2, 1 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1238"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1246"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing R in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1254"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1264"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, RWORK( IE ), A,
     $                            LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1300"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1305"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.1307"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1314"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1325"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1329"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1336"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   N*N+3*N-1,
</span><span class="comment">*</span><span class="comment">                                 prefer N*N+2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1345"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1355"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, RWORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, A, LDA,
     $                           WORK( IU ), LDWRKU, CZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1378"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1380"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1386"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1391"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="ZLASET.1393"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1404"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, VT, LDVT, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1413"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1421"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1431"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 3*N ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1470"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1472"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1476"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="ZLASET.1478"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1485"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1496"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1505"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1515"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, RWORK( IE ), CDUM,
     $                            1, WORK( IR ), LDWRKR, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, U, LDU,
     $                           WORK( IR ), LDWRKR, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1529"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1542"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1544"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1550"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.1559"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            A( 2, 1 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1566"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1575"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1585"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, RWORK( IE ), CDUM,
     $                            1, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+MAX( N+M, 3*N ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1631"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1633"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1639"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1644"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.1646"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*N*N+3*N,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need   N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1659"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1663"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1670"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*N*N+3*N-1,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*N*N+2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1679"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1690"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, RWORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, U, LDU,
     $                           WORK( IU ), LDWRKU, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1705"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1709"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1723"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1725"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1731"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.1740"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            A( 2, 1 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1747"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1756"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1764"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1774"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, RWORK( IE ), A,
     $                            LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 3*N ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1810"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1812"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1818"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1823"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.1825"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1836"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1840"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1847"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   N*N+3*N-1,
</span><span class="comment">*</span><span class="comment">                                 prefer N*N+2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need   0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1856"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1866"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, RWORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, U, LDU,
     $                           WORK( IU ), LDWRKU, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1880"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEQRF.1893"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.1895"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGQR.1901"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R from A to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.1906"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="ZLASET.1908"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.1919"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, VT, LDVT, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.1928"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.1936"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.1946"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = 1
            ITAUP = ITAUQ + N
            IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.1972"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N+NCU, prefer 2*N+NCU*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1982"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
               IF( WNTUS )
     $            NCU = N
               IF( WNTUA )
     $            NCU = M
               CALL <a name="ZUNGBR.1987"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, NCU, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1997"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.1998"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.2008"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.2018"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IRWORK = IE + N
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.2038"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, RWORK( IE ), VT,
     $                      LDVT, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.2049"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, RWORK( IE ), A,
     $                      LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.2060"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, RWORK( IE ), VT,
     $                      LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">              No right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGELQF.2087"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.2092"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, A( 1, 2 ),
     $                      LDA )
               IE = 1
               ITAUQ = 1
               ITAUP = ITAUQ + M
               IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.2103"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               IF( WNTUO .OR. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If left singular vectors desired, generate Q
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2112"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
               END IF
               IRWORK = IE + M
               NRU = 0
               IF( WNTUO .OR. WNTUAS )
     $            NRU = M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing left singular
</span><span class="comment">*</span><span class="comment">              vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.2125"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, 0, NRU, 0, S, RWORK( IE ), CDUM, 1,
     $                      A, LDA, CDUM, 1, RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTUAS )
     $            CALL <a name="ZLACPY.2131"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGELQF.2173"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to WORK(IR) and zero out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.2178"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="ZLASET.2179"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                         WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGLQ.2186"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.2197"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IR ), LDWRKR, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2205"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.2215"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, RWORK( IE ),
     $                         WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,
     $                         RWORK( IRWORK ), INFO )
                  IU = ITAUQ
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+M, prefer M*M+M*N)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 30 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, CONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, CZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="ZLACPY.2230"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   30             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = 1
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.2247"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2255"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.2264"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'L'</span>, M, N, 0, 0, S, RWORK( IE ), A, LDA,
     $                         CDUM, 1, CDUM, 1, RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGELQF.2309"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.2314"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="ZLASET.2315"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGLQ.2322"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.2333"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, U, LDU, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="ZLACPY.2336"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, M, U, LDU, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+3*M-1, prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2342"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2350"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in U, and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.2360"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, RWORK( IE ),
     $                         WORK( IR ), LDWRKR, U, LDU, CDUM, 1,
     $                         RWORK( IRWORK ), INFO )
                  IU = ITAUQ
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M+M, prefer M*M+M*N))
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, CONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, CZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="ZLACPY.2375"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   40             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGELQF.2390"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACPY.2395"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="ZLASET.2396"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGLQ.2403"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = 1
                  ITAUQ = ITAU
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZGEBRD.2414"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, U, LDU, S, RWORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right vectors bidiagonalizing L by Q in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNMBR.2422"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, U, LDU,
     $                         WORK( ITAUP ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.2430"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                 (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZBDSQR.2440"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, RWORK( IE ), A, LDA,
     $                         U, LDU, CDUM, 1, RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2476"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2481"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="ZLASET.2483"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2490"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2501"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing L in
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2511"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2521"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, RWORK( IE ),
     $                            WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IR ),
     $                           LDWRKR, A, LDA, CZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2544"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy result to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2549"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2555"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.2564"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            A( 1, 2 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2571"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.2579"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2589"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, RWORK( IE ), VT,
     $                            LDVT, CDUM, 1, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2635"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2640"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.2642"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2649"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*M*M+3*M,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need   M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2662"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.2666"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*M*M+3*M-1,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2674"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2682"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2693"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, RWORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IU ),
     $                           LDWRKU, A, LDA, CZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of L to A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2710"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2724"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.2726"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2732"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.2741"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            A( 1, 2 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2748"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.2756"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors of L in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2764"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2774"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, A, LDA, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2810"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2815"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.2817"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2824"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2835"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.2839"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   M*M+3*M-1,
</span><span class="comment">*</span><span class="comment">                                 prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2847"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2855"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2865"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, RWORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IU ),
     $                           LDWRKU, A, LDA, CZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2888"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.2890"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2896"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2901"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="ZLASET.2902"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            U( 1, 2 ), LDU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.2913"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, U, LDU, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.2922"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.2930"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.2940"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 3*M ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.2979"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.2981"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.2985"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="ZLASET.2987"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.2994"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3005"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   M*M+3*M-1,
</span><span class="comment">*</span><span class="comment">                                 prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3015"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3025"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, RWORK( IE ),
     $                            WORK( IR ), LDWRKR, CDUM, 1, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IR ),
     $                           LDWRKR, VT, LDVT, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3039"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.3052"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3054"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.3060"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.3069"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            A( 1, 2 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3076"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.3085"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3095"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, RWORK( IE ), VT,
     $                            LDVT, CDUM, 1, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+MAX( N+M, 3*M ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.3141"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3143"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.3149"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3154"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.3156"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*M*M+3*M,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need   M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3169"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3173"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need   2*M*M+3*M-1,
</span><span class="comment">*</span><span class="comment">                                 prefer 2*M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3181"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3189"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3200"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, RWORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, CDUM, 1, RWORK( IRWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3215"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3219"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.3233"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3235"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.3241"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLASET.3250"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            A( 1, 2 ), LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3257"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.3266"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3274"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3284"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, A, LDA, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 3*M ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.3320"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3322"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.3328"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3333"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="ZLASET.3335"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3346"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            RWORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3350"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3357"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3365"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3375"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, RWORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3389"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGELQF.3402"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="ZLACPY.3404"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGLQ.3410"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZLACPY.3415"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="ZLASET.3416"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                            U( 1, 2 ), LDU )
                     IE = 1
                     ITAUQ = ITAU
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZGEBRD.3427"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, U, LDU, S, RWORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNMBR.3436"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZUNGBR.3444"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">                    (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="ZBDSQR.3454"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, RWORK( IE ), VT,
     $                            LDVT, U, LDU, CDUM, 1,
     $                            RWORK( IRWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = 1
            ITAUP = ITAUQ + M
            IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: M)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.3480"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.3490"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.3491"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M+NRVT, prefer 2*M+NRVT*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.3501"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
               IF( WNTVA )
     $            NRVT = N
               IF( WNTVS )
     $            NRVT = M
               CALL <a name="ZUNGBR.3506"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, NRVT, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M-1, prefer 2*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.3516"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.3526"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IRWORK = IE + M
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.3546"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, RWORK( IE ), VT,
     $                      LDVT, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.3557"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, RWORK( IE ), A,
     $                      LDA, U, LDU, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZBDSQR.3568"></a><a href="zbdsqr.f.html#ZBDSQR.1">ZBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, RWORK( IE ), VT,
     $                      LDVT, A, LDA, CDUM, 1, RWORK( IRWORK ),
     $                      INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.3581"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.3584"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN-1, 1,
     $                   RWORK( IE ), MINMN, IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.3587"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.3590"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN-1, 1,
     $                   RWORK( IE ), MINMN, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="ZGESVD.3600"></a><a href="zgesvd.f.html#ZGESVD.1">ZGESVD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
