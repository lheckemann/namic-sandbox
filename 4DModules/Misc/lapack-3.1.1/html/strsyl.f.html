<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>strsyl.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="STRSYL.1"></a><a href="strsyl.f.html#STRSYL.1">STRSYL</a>( TRANA, TRANB, ISGN, M, N, A, LDA, B, LDB, C,
     $                   LDC, SCALE, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          TRANA, TRANB
      INTEGER            INFO, ISGN, LDA, LDB, LDC, M, N
      REAL               SCALE
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               A( LDA, * ), B( LDB, * ), C( LDC, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="STRSYL.20"></a><a href="strsyl.f.html#STRSYL.1">STRSYL</a> solves the real Sylvester matrix equation:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     op(A)*X + X*op(B) = scale*C or
</span><span class="comment">*</span><span class="comment">     op(A)*X - X*op(B) = scale*C,
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where op(A) = A or A**T, and  A and B are both upper quasi-
</span><span class="comment">*</span><span class="comment">  triangular. A is M-by-M and B is N-by-N; the right hand side C and
</span><span class="comment">*</span><span class="comment">  the solution X are M-by-N; and scale is an output scale factor, set
</span><span class="comment">*</span><span class="comment">  &lt;= 1 to avoid overflow in X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A and B must be in Schur canonical form (as returned by <a name="SHSEQR.30"></a><a href="shseqr.f.html#SHSEQR.1">SHSEQR</a>), that
</span><span class="comment">*</span><span class="comment">  is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
</span><span class="comment">*</span><span class="comment">  each 2-by-2 diagonal block has its diagonal elements equal and its
</span><span class="comment">*</span><span class="comment">  off-diagonal elements of opposite sign.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  TRANA   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies the option op(A):
</span><span class="comment">*</span><span class="comment">          = 'N': op(A) = A    (No transpose)
</span><span class="comment">*</span><span class="comment">          = 'T': op(A) = A**T (Transpose)
</span><span class="comment">*</span><span class="comment">          = 'C': op(A) = A**H (Conjugate transpose = Transpose)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  TRANB   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies the option op(B):
</span><span class="comment">*</span><span class="comment">          = 'N': op(B) = B    (No transpose)
</span><span class="comment">*</span><span class="comment">          = 'T': op(B) = B**T (Transpose)
</span><span class="comment">*</span><span class="comment">          = 'C': op(B) = B**H (Conjugate transpose = Transpose)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ISGN    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          Specifies the sign in the equation:
</span><span class="comment">*</span><span class="comment">          = +1: solve op(A)*X + X*op(B) = scale*C
</span><span class="comment">*</span><span class="comment">          = -1: solve op(A)*X - X*op(B) = scale*C
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrix A, and the number of rows in the
</span><span class="comment">*</span><span class="comment">          matrices X and C. M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrix B, and the number of columns in the
</span><span class="comment">*</span><span class="comment">          matrices X and C. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input) REAL array, dimension (LDA,M)
</span><span class="comment">*</span><span class="comment">          The upper quasi-triangular matrix A, in Schur canonical form.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input) REAL array, dimension (LDB,N)
</span><span class="comment">*</span><span class="comment">          The upper quasi-triangular matrix B, in Schur canonical form.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  C       (input/output) REAL array, dimension (LDC,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N right hand side matrix C.
</span><span class="comment">*</span><span class="comment">          On exit, C is overwritten by the solution matrix X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDC     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array C. LDC &gt;= max(1,M)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SCALE   (output) REAL
</span><span class="comment">*</span><span class="comment">          The scale factor, scale, set &lt;= 1 to avoid overflow in X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0: successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0: if INFO = -i, the i-th argument had an illegal value
</span><span class="comment">*</span><span class="comment">          = 1: A and B have common or very close eigenvalues; perturbed
</span><span class="comment">*</span><span class="comment">               values were used to solve the equation (but the matrices
</span><span class="comment">*</span><span class="comment">               A and B are unchanged).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            NOTRNA, NOTRNB
      INTEGER            IERR, J, K, K1, K2, KNEXT, L, L1, L2, LNEXT
      REAL               A11, BIGNUM, DA11, DB, EPS, SCALOC, SGN, SMIN,
     $                   SMLNUM, SUML, SUMR, XNORM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      REAL               DUM( 1 ), VEC( 2, 2 ), X( 2, 2 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.108"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      REAL               SDOT, <a name="SLAMCH.109"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.109"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
      EXTERNAL           <a name="LSAME.110"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, SDOT, <a name="SLAMCH.110"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.110"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="SLABAD.113"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>, <a name="SLALN2.113"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>, <a name="SLASY2.113"></a><a href="slasy2.f.html#SLASY2.1">SLASY2</a>, SSCAL, <a name="XERBLA.113"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, MAX, MIN, REAL
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode and Test input parameters
</span><span class="comment">*</span><span class="comment">
</span>      NOTRNA = <a name="LSAME.122"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANA, <span class="string">'N'</span> )
      NOTRNB = <a name="LSAME.123"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANB, <span class="string">'N'</span> )
<span class="comment">*</span><span class="comment">
</span>      INFO = 0
      IF( .NOT.NOTRNA .AND. .NOT.<a name="LSAME.126"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANA, <span class="string">'T'</span> ) .AND. .NOT.
     $    <a name="LSAME.127"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANA, <span class="string">'C'</span> ) ) THEN
         INFO = -1
      ELSE IF( .NOT.NOTRNB .AND. .NOT.<a name="LSAME.129"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANB, <span class="string">'T'</span> ) .AND. .NOT.
     $         <a name="LSAME.130"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANB, <span class="string">'C'</span> ) ) THEN
         INFO = -2
      ELSE IF( ISGN.NE.1 .AND. ISGN.NE.-1 ) THEN
         INFO = -3
      ELSE IF( M.LT.0 ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -9
      ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
         INFO = -11
      END IF
      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.146"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="STRSYL.146"></a><a href="strsyl.f.html#STRSYL.1">STRSYL</a>'</span>, -INFO )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Set constants to control overflow
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.157"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="SLAMCH.158"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.160"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
      SMLNUM = SMLNUM*REAL( M*N ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span>      SMIN = MAX( SMLNUM, EPS*<a name="SLANGE.164"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, M, M, A, LDA, DUM ),
     $       EPS*<a name="SLANGE.165"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, N, N, B, LDB, DUM ) )
<span class="comment">*</span><span class="comment">
</span>      SCALE = ONE
      SGN = ISGN
<span class="comment">*</span><span class="comment">
</span>      IF( NOTRNA .AND. NOTRNB ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve    A*X + ISGN*X*B = scale*C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        The (K,L)th block of X is determined starting from
</span><span class="comment">*</span><span class="comment">        bottom-left corner column by column by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         A(K,K)*X(K,L) + ISGN*X(K,L)*B(L,L) = C(K,L) - R(K,L)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Where
</span><span class="comment">*</span><span class="comment">                  M                         L-1
</span><span class="comment">*</span><span class="comment">        R(K,L) = SUM [A(K,I)*X(I,L)] + ISGN*SUM [X(K,J)*B(J,L)].
</span><span class="comment">*</span><span class="comment">                I=K+1                       J=1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Start column loop (index = L)
</span><span class="comment">*</span><span class="comment">        L1 (L2) : column index of the first (first) row of X(K,L).
</span><span class="comment">*</span><span class="comment">
</span>         LNEXT = 1
         DO 70 L = 1, N
            IF( L.LT.LNEXT )
     $         GO TO 70
            IF( L.EQ.N ) THEN
               L1 = L
               L2 = L
            ELSE
               IF( B( L+1, L ).NE.ZERO ) THEN
                  L1 = L
                  L2 = L + 1
                  LNEXT = L + 2
               ELSE
                  L1 = L
                  L2 = L
                  LNEXT = L + 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Start row loop (index = K)
</span><span class="comment">*</span><span class="comment">           K1 (K2): row index of the first (last) row of X(K,L).
</span><span class="comment">*</span><span class="comment">
</span>            KNEXT = M
            DO 60 K = M, 1, -1
               IF( K.GT.KNEXT )
     $            GO TO 60
               IF( K.EQ.1 ) THEN
                  K1 = K
                  K2 = K
               ELSE
                  IF( A( K, K-1 ).NE.ZERO ) THEN
                     K1 = K - 1
                     K2 = K
                     KNEXT = K - 2
                  ELSE
                     K1 = K
                     K2 = K
                     KNEXT = K - 1
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               IF( L1.EQ.L2 .AND. K1.EQ.K2 ) THEN
                  SUML = SDOT( M-K1, A( K1, MIN( K1+1, M ) ), LDA,
     $                         C( MIN( K1+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
                  SCALOC = ONE
<span class="comment">*</span><span class="comment">
</span>                  A11 = A( K1, K1 ) + SGN*B( L1, L1 )
                  DA11 = ABS( A11 )
                  IF( DA11.LE.SMIN ) THEN
                     A11 = SMIN
                     DA11 = SMIN
                     INFO = 1
                  END IF
                  DB = ABS( VEC( 1, 1 ) )
                  IF( DA11.LT.ONE .AND. DB.GT.ONE ) THEN
                     IF( DB.GT.BIGNUM*DA11 )
     $                  SCALOC = ONE / DB
                  END IF
                  X( 1, 1 ) = ( VEC( 1, 1 )*SCALOC ) / A11
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 10 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   10                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.EQ.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.269"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .FALSE., 2, 1, SMIN, ONE, A( K1, K1 ),
     $                         LDA, ONE, ONE, VEC, 2, -SGN*B( L1, L1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 20 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   20                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K2, L1 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.EQ.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K1, A( K1, MIN( K1+1, M ) ), LDA,
     $                         C( MIN( K1+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = SGN*( C( K1, L1 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K1, A( K1, MIN( K1+1, M ) ), LDA,
     $                         C( MIN( K1+1, M ), L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 2, 1 ) = SGN*( C( K1, L2 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.296"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .TRUE., 2, 1, SMIN, ONE, B( L1, L1 ),
     $                         LDB, ONE, ONE, VEC, 2, -SGN*A( K1, K1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 40 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   40                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 1, 2 ) = C( K1, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 2, 2 ) = C( K2, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASY2.333"></a><a href="slasy2.f.html#SLASY2.1">SLASY2</a>( .FALSE., .FALSE., ISGN, 2, 2,
     $                         A( K1, K1 ), LDA, B( L1, L1 ), LDB, VEC,
     $                         2, SCALOC, X, 2, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 50 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   50                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 1, 2 )
                  C( K2, L1 ) = X( 2, 1 )
                  C( K2, L2 ) = X( 2, 2 )
               END IF
<span class="comment">*</span><span class="comment">
</span>   60       CONTINUE
<span class="comment">*</span><span class="comment">
</span>   70    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( .NOT.NOTRNA .AND. NOTRNB ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve    A' *X + ISGN*X*B = scale*C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        The (K,L)th block of X is determined starting from
</span><span class="comment">*</span><span class="comment">        upper-left corner column by column by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          A(K,K)'*X(K,L) + ISGN*X(K,L)*B(L,L) = C(K,L) - R(K,L)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Where
</span><span class="comment">*</span><span class="comment">                   K-1                        L-1
</span><span class="comment">*</span><span class="comment">          R(K,L) = SUM [A(I,K)'*X(I,L)] +ISGN*SUM [X(K,J)*B(J,L)]
</span><span class="comment">*</span><span class="comment">                   I=1                        J=1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Start column loop (index = L)
</span><span class="comment">*</span><span class="comment">        L1 (L2): column index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>         LNEXT = 1
         DO 130 L = 1, N
            IF( L.LT.LNEXT )
     $         GO TO 130
            IF( L.EQ.N ) THEN
               L1 = L
               L2 = L
            ELSE
               IF( B( L+1, L ).NE.ZERO ) THEN
                  L1 = L
                  L2 = L + 1
                  LNEXT = L + 2
               ELSE
                  L1 = L
                  L2 = L
                  LNEXT = L + 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Start row loop (index = K)
</span><span class="comment">*</span><span class="comment">           K1 (K2): row index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>            KNEXT = 1
            DO 120 K = 1, M
               IF( K.LT.KNEXT )
     $            GO TO 120
               IF( K.EQ.M ) THEN
                  K1 = K
                  K2 = K
               ELSE
                  IF( A( K+1, K ).NE.ZERO ) THEN
                     K1 = K
                     K2 = K + 1
                     KNEXT = K + 2
                  ELSE
                     K1 = K
                     K2 = K
                     KNEXT = K + 1
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               IF( L1.EQ.L2 .AND. K1.EQ.K2 ) THEN
                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
                  SCALOC = ONE
<span class="comment">*</span><span class="comment">
</span>                  A11 = A( K1, K1 ) + SGN*B( L1, L1 )
                  DA11 = ABS( A11 )
                  IF( DA11.LE.SMIN ) THEN
                     A11 = SMIN
                     DA11 = SMIN
                     INFO = 1
                  END IF
                  DB = ABS( VEC( 1, 1 ) )
                  IF( DA11.LT.ONE .AND. DB.GT.ONE ) THEN
                     IF( DB.GT.BIGNUM*DA11 )
     $                  SCALOC = ONE / DB
                  END IF
                  X( 1, 1 ) = ( VEC( 1, 1 )*SCALOC ) / A11
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 80 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   80                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.EQ.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.451"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .TRUE., 2, 1, SMIN, ONE, A( K1, K1 ),
     $                         LDA, ONE, ONE, VEC, 2, -SGN*B( L1, L1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 90 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
   90                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K2, L1 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.EQ.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = SGN*( C( K1, L1 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 2, 1 ) = SGN*( C( K1, L2 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.476"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .TRUE., 2, 1, SMIN, ONE, B( L1, L1 ),
     $                         LDB, ONE, ONE, VEC, 2, -SGN*A( K1, K1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 100 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  100                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K1, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 1, 2 ) = C( K1, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L1 ), 1 )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( L1-1, C( K2, 1 ), LDC, B( 1, L2 ), 1 )
                  VEC( 2, 2 ) = C( K2, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASY2.509"></a><a href="slasy2.f.html#SLASY2.1">SLASY2</a>( .TRUE., .FALSE., ISGN, 2, 2, A( K1, K1 ),
     $                         LDA, B( L1, L1 ), LDB, VEC, 2, SCALOC, X,
     $                         2, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 110 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  110                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 1, 2 )
                  C( K2, L1 ) = X( 2, 1 )
                  C( K2, L2 ) = X( 2, 2 )
               END IF
<span class="comment">*</span><span class="comment">
</span>  120       CONTINUE
  130    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( .NOT.NOTRNA .AND. .NOT.NOTRNB ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve    A'*X + ISGN*X*B' = scale*C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        The (K,L)th block of X is determined starting from
</span><span class="comment">*</span><span class="comment">        top-right corner column by column by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           A(K,K)'*X(K,L) + ISGN*X(K,L)*B(L,L)' = C(K,L) - R(K,L)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Where
</span><span class="comment">*</span><span class="comment">                     K-1                          N
</span><span class="comment">*</span><span class="comment">            R(K,L) = SUM [A(I,K)'*X(I,L)] + ISGN*SUM [X(K,J)*B(L,J)'].
</span><span class="comment">*</span><span class="comment">                     I=1                        J=L+1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Start column loop (index = L)
</span><span class="comment">*</span><span class="comment">        L1 (L2): column index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>         LNEXT = N
         DO 190 L = N, 1, -1
            IF( L.GT.LNEXT )
     $         GO TO 190
            IF( L.EQ.1 ) THEN
               L1 = L
               L2 = L
            ELSE
               IF( B( L, L-1 ).NE.ZERO ) THEN
                  L1 = L - 1
                  L2 = L
                  LNEXT = L - 2
               ELSE
                  L1 = L
                  L2 = L
                  LNEXT = L - 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Start row loop (index = K)
</span><span class="comment">*</span><span class="comment">           K1 (K2): row index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>            KNEXT = 1
            DO 180 K = 1, M
               IF( K.LT.KNEXT )
     $            GO TO 180
               IF( K.EQ.M ) THEN
                  K1 = K
                  K2 = K
               ELSE
                  IF( A( K+1, K ).NE.ZERO ) THEN
                     K1 = K
                     K2 = K + 1
                     KNEXT = K + 2
                  ELSE
                     K1 = K
                     K2 = K
                     KNEXT = K + 1
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               IF( L1.EQ.L2 .AND. K1.EQ.K2 ) THEN
                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L1, C( K1, MIN( L1+1, N ) ), LDC,
     $                         B( L1, MIN( L1+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
                  SCALOC = ONE
<span class="comment">*</span><span class="comment">
</span>                  A11 = A( K1, K1 ) + SGN*B( L1, L1 )
                  DA11 = ABS( A11 )
                  IF( DA11.LE.SMIN ) THEN
                     A11 = SMIN
                     DA11 = SMIN
                     INFO = 1
                  END IF
                  DB = ABS( VEC( 1, 1 ) )
                  IF( DA11.LT.ONE .AND. DB.GT.ONE ) THEN
                     IF( DB.GT.BIGNUM*DA11 )
     $                  SCALOC = ONE / DB
                  END IF
                  X( 1, 1 ) = ( VEC( 1, 1 )*SCALOC ) / A11
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 140 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  140                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.EQ.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.629"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .TRUE., 2, 1, SMIN, ONE, A( K1, K1 ),
     $                         LDA, ONE, ONE, VEC, 2, -SGN*B( L1, L1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 150 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  150                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K2, L1 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.EQ.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = SGN*( C( K1, L1 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = SGN*( C( K1, L2 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.656"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .FALSE., 2, 1, SMIN, ONE, B( L1, L1 ),
     $                         LDB, ONE, ONE, VEC, 2, -SGN*A( K1, K1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 160 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  160                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K1 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 2 ) = C( K1, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( K1-1, A( 1, K2 ), 1, C( 1, L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN(L2+1, N ) ), LDB )
                  VEC( 2, 2 ) = C( K2, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASY2.693"></a><a href="slasy2.f.html#SLASY2.1">SLASY2</a>( .TRUE., .TRUE., ISGN, 2, 2, A( K1, K1 ),
     $                         LDA, B( L1, L1 ), LDB, VEC, 2, SCALOC, X,
     $                         2, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 170 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  170                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 1, 2 )
                  C( K2, L1 ) = X( 2, 1 )
                  C( K2, L2 ) = X( 2, 2 )
               END IF
<span class="comment">*</span><span class="comment">
</span>  180       CONTINUE
  190    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( NOTRNA .AND. .NOT.NOTRNB ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve    A*X + ISGN*X*B' = scale*C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        The (K,L)th block of X is determined starting from
</span><span class="comment">*</span><span class="comment">        bottom-right corner column by column by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">            A(K,K)*X(K,L) + ISGN*X(K,L)*B(L,L)' = C(K,L) - R(K,L)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Where
</span><span class="comment">*</span><span class="comment">                      M                          N
</span><span class="comment">*</span><span class="comment">            R(K,L) = SUM [A(K,I)*X(I,L)] + ISGN*SUM [X(K,J)*B(L,J)'].
</span><span class="comment">*</span><span class="comment">                    I=K+1                      J=L+1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Start column loop (index = L)
</span><span class="comment">*</span><span class="comment">        L1 (L2): column index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>         LNEXT = N
         DO 250 L = N, 1, -1
            IF( L.GT.LNEXT )
     $         GO TO 250
            IF( L.EQ.1 ) THEN
               L1 = L
               L2 = L
            ELSE
               IF( B( L, L-1 ).NE.ZERO ) THEN
                  L1 = L - 1
                  L2 = L
                  LNEXT = L - 2
               ELSE
                  L1 = L
                  L2 = L
                  LNEXT = L - 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Start row loop (index = K)
</span><span class="comment">*</span><span class="comment">           K1 (K2): row index of the first (last) row of X(K,L)
</span><span class="comment">*</span><span class="comment">
</span>            KNEXT = M
            DO 240 K = M, 1, -1
               IF( K.GT.KNEXT )
     $            GO TO 240
               IF( K.EQ.1 ) THEN
                  K1 = K
                  K2 = K
               ELSE
                  IF( A( K, K-1 ).NE.ZERO ) THEN
                     K1 = K - 1
                     K2 = K
                     KNEXT = K - 2
                  ELSE
                     K1 = K
                     K2 = K
                     KNEXT = K - 1
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               IF( L1.EQ.L2 .AND. K1.EQ.K2 ) THEN
                  SUML = SDOT( M-K1, A( K1, MIN(K1+1, M ) ), LDA,
     $                   C( MIN( K1+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L1, C( K1, MIN( L1+1, N ) ), LDC,
     $                         B( L1, MIN( L1+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
                  SCALOC = ONE
<span class="comment">*</span><span class="comment">
</span>                  A11 = A( K1, K1 ) + SGN*B( L1, L1 )
                  DA11 = ABS( A11 )
                  IF( DA11.LE.SMIN ) THEN
                     A11 = SMIN
                     DA11 = SMIN
                     INFO = 1
                  END IF
                  DB = ABS( VEC( 1, 1 ) )
                  IF( DA11.LT.ONE .AND. DB.GT.ONE ) THEN
                     IF( DB.GT.BIGNUM*DA11 )
     $                  SCALOC = ONE / DB
                  END IF
                  X( 1, 1 ) = ( VEC( 1, 1 )*SCALOC ) / A11
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 200 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  200                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.EQ.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.816"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .FALSE., 2, 1, SMIN, ONE, A( K1, K1 ),
     $                         LDA, ONE, ONE, VEC, 2, -SGN*B( L1, L1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 210 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  210                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K2, L1 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.EQ.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K1, A( K1, MIN( K1+1, M ) ), LDA,
     $                         C( MIN( K1+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = SGN*( C( K1, L1 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K1, A( K1, MIN( K1+1, M ) ), LDA,
     $                         C( MIN( K1+1, M ), L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = SGN*( C( K1, L2 )-( SUML+SGN*SUMR ) )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLALN2.845"></a><a href="slaln2.f.html#SLALN2.1">SLALN2</a>( .FALSE., 2, 1, SMIN, ONE, B( L1, L1 ),
     $                         LDB, ONE, ONE, VEC, 2, -SGN*A( K1, K1 ),
     $                         ZERO, X, 2, SCALOC, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 220 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  220                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 2, 1 )
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( L1.NE.L2 .AND. K1.NE.K2 ) THEN
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 1 ) = C( K1, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K1, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K1, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN( L2+1, N ) ), LDB )
                  VEC( 1, 2 ) = C( K1, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L1 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L1, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 1 ) = C( K2, L1 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  SUML = SDOT( M-K2, A( K2, MIN( K2+1, M ) ), LDA,
     $                         C( MIN( K2+1, M ), L2 ), 1 )
                  SUMR = SDOT( N-L2, C( K2, MIN( L2+1, N ) ), LDC,
     $                         B( L2, MIN( L2+1, N ) ), LDB )
                  VEC( 2, 2 ) = C( K2, L2 ) - ( SUML+SGN*SUMR )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASY2.886"></a><a href="slasy2.f.html#SLASY2.1">SLASY2</a>( .FALSE., .TRUE., ISGN, 2, 2, A( K1, K1 ),
     $                         LDA, B( L1, L1 ), LDB, VEC, 2, SCALOC, X,
     $                         2, XNORM, IERR )
                  IF( IERR.NE.0 )
     $               INFO = 1
<span class="comment">*</span><span class="comment">
</span>                  IF( SCALOC.NE.ONE ) THEN
                     DO 230 J = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, J ), 1 )
  230                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
                  C( K1, L1 ) = X( 1, 1 )
                  C( K1, L2 ) = X( 1, 2 )
                  C( K2, L1 ) = X( 2, 1 )
                  C( K2, L2 ) = X( 2, 2 )
               END IF
<span class="comment">*</span><span class="comment">
</span>  240       CONTINUE
  250    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="STRSYL.911"></a><a href="strsyl.f.html#STRSYL.1">STRSYL</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
