<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dlatzm.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DLATZM.1"></a><a href="dlatzm.f.html#DLATZM.1">DLATZM</a>( SIDE, M, N, V, INCV, TAU, C1, C2, LDC, WORK )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          SIDE
      INTEGER            INCV, LDC, M, N
      DOUBLE PRECISION   TAU
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      DOUBLE PRECISION   C1( LDC, * ), C2( LDC, * ), V( * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This routine is deprecated and has been replaced by routine <a name="DORMRZ.19"></a><a href="dormrz.f.html#DORMRZ.1">DORMRZ</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DLATZM.21"></a><a href="dlatzm.f.html#DLATZM.1">DLATZM</a> applies a Householder matrix generated by <a name="DTZRQF.21"></a><a href="dtzrqf.f.html#DTZRQF.1">DTZRQF</a> to a matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Let P = I - tau*u*u',   u = ( 1 ),
</span><span class="comment">*</span><span class="comment">                              ( v )
</span><span class="comment">*</span><span class="comment">  where v is an (m-1) vector if SIDE = 'L', or a (n-1) vector if
</span><span class="comment">*</span><span class="comment">  SIDE = 'R'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If SIDE equals 'L', let
</span><span class="comment">*</span><span class="comment">         C = [ C1 ] 1
</span><span class="comment">*</span><span class="comment">             [ C2 ] m-1
</span><span class="comment">*</span><span class="comment">               n
</span><span class="comment">*</span><span class="comment">  Then C is overwritten by P*C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If SIDE equals 'R', let
</span><span class="comment">*</span><span class="comment">         C = [ C1, C2 ] m
</span><span class="comment">*</span><span class="comment">                1  n-1
</span><span class="comment">*</span><span class="comment">  Then C is overwritten by C*P.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SIDE    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'L': form P * C
</span><span class="comment">*</span><span class="comment">          = 'R': form C * P
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the matrix C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the matrix C.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  V       (input) DOUBLE PRECISION array, dimension
</span><span class="comment">*</span><span class="comment">                  (1 + (M-1)*abs(INCV)) if SIDE = 'L'
</span><span class="comment">*</span><span class="comment">                  (1 + (N-1)*abs(INCV)) if SIDE = 'R'
</span><span class="comment">*</span><span class="comment">          The vector v in the representation of P. V is not used
</span><span class="comment">*</span><span class="comment">          if TAU = 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INCV    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The increment between elements of v. INCV &lt;&gt; 0
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  TAU     (input) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          The value tau in the representation of P.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  C1      (input/output) DOUBLE PRECISION array, dimension
</span><span class="comment">*</span><span class="comment">                         (LDC,N) if SIDE = 'L'
</span><span class="comment">*</span><span class="comment">                         (M,1)   if SIDE = 'R'
</span><span class="comment">*</span><span class="comment">          On entry, the n-vector C1 if SIDE = 'L', or the m-vector C1
</span><span class="comment">*</span><span class="comment">          if SIDE = 'R'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          On exit, the first row of P*C if SIDE = 'L', or the first
</span><span class="comment">*</span><span class="comment">          column of C*P if SIDE = 'R'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  C2      (input/output) DOUBLE PRECISION array, dimension
</span><span class="comment">*</span><span class="comment">                         (LDC, N)   if SIDE = 'L'
</span><span class="comment">*</span><span class="comment">                         (LDC, N-1) if SIDE = 'R'
</span><span class="comment">*</span><span class="comment">          On entry, the (m - 1) x n matrix C2 if SIDE = 'L', or the
</span><span class="comment">*</span><span class="comment">          m x (n - 1) matrix C2 if SIDE = 'R'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          On exit, rows 2:m of P*C if SIDE = 'L', or columns 2:m of C*P
</span><span class="comment">*</span><span class="comment">          if SIDE = 'R'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDC     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the arrays C1 and C2. LDC &gt;= (1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace) DOUBLE PRECISION array, dimension
</span><span class="comment">*</span><span class="comment">                      (N) if SIDE = 'L'
</span><span class="comment">*</span><span class="comment">                      (M) if SIDE = 'R'
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ONE, ZERO
      PARAMETER          ( ONE = 1.0D+0, ZERO = 0.0D+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           DAXPY, DCOPY, DGEMV, DGER
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.99"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      EXTERNAL           <a name="LSAME.100"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MIN
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span>      IF( ( MIN( M, N ).EQ.0 ) .OR. ( TAU.EQ.ZERO ) )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.110"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SIDE, <span class="string">'L'</span> ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        w := C1 + v' * C2
</span><span class="comment">*</span><span class="comment">
</span>         CALL DCOPY( N, C1, LDC, WORK, 1 )
         CALL DGEMV( <span class="string">'Transpose'</span>, M-1, N, ONE, C2, LDC, V, INCV, ONE,
     $               WORK, 1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        [ C1 ] := [ C1 ] - tau* [ 1 ] * w'
</span><span class="comment">*</span><span class="comment">        [ C2 ]    [ C2 ]        [ v ]
</span><span class="comment">*</span><span class="comment">
</span>         CALL DAXPY( N, -TAU, WORK, 1, C1, LDC )
         CALL DGER( M-1, N, -TAU, V, INCV, WORK, 1, C2, LDC )
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( <a name="LSAME.124"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SIDE, <span class="string">'R'</span> ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        w := C1 + C2 * v
</span><span class="comment">*</span><span class="comment">
</span>         CALL DCOPY( M, C1, 1, WORK, 1 )
         CALL DGEMV( <span class="string">'No transpose'</span>, M, N-1, ONE, C2, LDC, V, INCV, ONE,
     $               WORK, 1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        [ C1, C2 ] := [ C1, C2 ] - tau* w * [ 1 , v']
</span><span class="comment">*</span><span class="comment">
</span>         CALL DAXPY( M, -TAU, WORK, 1, C1, 1 )
         CALL DGER( M, N-1, -TAU, WORK, 1, V, INCV, C2, LDC )
      END IF
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DLATZM.140"></a><a href="dlatzm.f.html#DLATZM.1">DLATZM</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
