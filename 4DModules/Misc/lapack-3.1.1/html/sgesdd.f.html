<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>sgesdd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="SGESDD.1"></a><a href="sgesdd.f.html#SGESDD.1">SGESDD</a>( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,
     $                   LWORK, IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBZ
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      REAL               A( LDA, * ), S( * ), U( LDU, * ),
     $                   VT( LDVT, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="SGESDD.21"></a><a href="sgesdd.f.html#SGESDD.1">SGESDD</a> computes the singular value decomposition (SVD) of a real
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and right singular
</span><span class="comment">*</span><span class="comment">  vectors.  If singular vectors are desired, it uses a
</span><span class="comment">*</span><span class="comment">  divide-and-conquer algorithm.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns VT = V**T, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The divide and conquer algorithm makes very mild assumptions about
</span><span class="comment">*</span><span class="comment">  floating point arithmetic. It will work on machines with a guard
</span><span class="comment">*</span><span class="comment">  digit in add/subtract, or on those binary machines without guard
</span><span class="comment">*</span><span class="comment">  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
</span><span class="comment">*</span><span class="comment">  Cray-2. It could conceivably fail on hexadecimal or decimal machines
</span><span class="comment">*</span><span class="comment">  without guard digits, but we know of none.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBZ    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U and all N rows of V**T are
</span><span class="comment">*</span><span class="comment">                  returned in the arrays U and VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(M,N) columns of U and the first
</span><span class="comment">*</span><span class="comment">                  min(M,N) rows of V**T are returned in the arrays U
</span><span class="comment">*</span><span class="comment">                  and VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  If M &gt;= N, the first N columns of U are overwritten
</span><span class="comment">*</span><span class="comment">                  on the array A and all rows of V**T are returned in
</span><span class="comment">*</span><span class="comment">                  the array VT;
</span><span class="comment">*</span><span class="comment">                  otherwise, all columns of U are returned in the
</span><span class="comment">*</span><span class="comment">                  array U and the first M rows of V**T are overwritten
</span><span class="comment">*</span><span class="comment">                  in the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U or rows of V**T are computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) REAL array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O',  A is overwritten with the first N columns
</span><span class="comment">*</span><span class="comment">                          of U (the left singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          columnwise) if M &gt;= N;
</span><span class="comment">*</span><span class="comment">                          A is overwritten with the first M rows
</span><span class="comment">*</span><span class="comment">                          of V**T (the right singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          rowwise) otherwise.
</span><span class="comment">*</span><span class="comment">          if JOBZ .ne. 'O', the contents of A are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) REAL array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) REAL array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
</span><span class="comment">*</span><span class="comment">          UCOL = min(M,N) if JOBZ = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
</span><span class="comment">*</span><span class="comment">          orthogonal matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', U contains the first min(M,N) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) REAL array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
</span><span class="comment">*</span><span class="comment">          N-by-N orthogonal matrix V**T;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', VT contains the first min(M,N) rows of
</span><span class="comment">*</span><span class="comment">          V**T (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'N',
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N) + max(max(M,N),6*min(M,N)).
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'O',
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N)*min(M,N) + 
</span><span class="comment">*</span><span class="comment">                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'S' or 'A'
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N)*min(M,N) +
</span><span class="comment">*</span><span class="comment">                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">          If LWORK = -1 but other input arguments are legal, WORK(1)
</span><span class="comment">*</span><span class="comment">          returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  <a name="SBDSDC.134"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a> did not converge, updating process failed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Ming Gu and Huan Ren, Computer Science Division, University of
</span><span class="comment">*</span><span class="comment">     California at Berkeley, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, WNTQA, WNTQAS, WNTQN, WNTQO, WNTQS
      INTEGER            BDSPAC, BLK, CHUNK, I, IE, IERR, IL,
     $                   IR, ISCL, ITAU, ITAUP, ITAUQ, IU, IVT, LDWKVT,
     $                   LDWRKL, LDWRKR, LDWRKU, MAXWRK, MINMN, MINWRK,
     $                   MNTHR, NWORK, WRKBL
      REAL               ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      INTEGER            IDUM( 1 )
      REAL               DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="SBDSDC.162"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>, <a name="SGEBRD.162"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>, <a name="SGELQF.162"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>, SGEMM, <a name="SGEQRF.162"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>, <a name="SLACPY.162"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>,
     $                   <a name="SLASCL.163"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="SLASET.163"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SORGBR.163"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>, <a name="SORGLQ.163"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>, <a name="SORGQR.163"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>, <a name="SORMBR.163"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>,
     $                   <a name="XERBLA.164"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.167"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.168"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="SLAMCH.169"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.169"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
      EXTERNAL           <a name="ILAENV.170"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="LSAME.170"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="SLAMCH.170"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.170"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          INT, MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      WNTQA = <a name="LSAME.181"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'A'</span> )
      WNTQS = <a name="LSAME.182"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'S'</span> )
      WNTQAS = WNTQA .OR. WNTQS
      WNTQO = <a name="LSAME.184"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'O'</span> )
      WNTQN = <a name="LSAME.185"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTQA .OR. WNTQS .OR. WNTQO .OR. WNTQN ) ) THEN
         INFO = -1
      ELSE IF( M.LT.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDU.LT.1 .OR. ( WNTQAS .AND. LDU.LT.M ) .OR.
     $         ( WNTQO .AND. M.LT.N .AND. LDU.LT.M ) ) THEN
         INFO = -8
      ELSE IF( LDVT.LT.1 .OR. ( WNTQA .AND. LDVT.LT.N ) .OR.
     $         ( WNTQS .AND. LDVT.LT.MINMN ) .OR.
     $         ( WNTQO .AND. M.GE.N .AND. LDVT.LT.N ) ) THEN
         INFO = -10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.210"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="SBDSDC.217"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = INT( MINMN*11.0E0 / 6.0E0 )
            IF( WNTQN ) THEN
               BDSPAC = 7*N
            ELSE
               BDSPAC = 3*N*N + 4*N
            END IF
            IF( M.GE.MNTHR ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.230"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.230"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                    -1 )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.233"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.233"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+N )
                  MINWRK = BDSPAC + N
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.240"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.240"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.241"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.244"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.244"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.246"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.246"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.248"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.248"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + 2*N*N
                  MINWRK = BDSPAC + 2*N*N + 3*N
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.256"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.257"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.257"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.260"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.260"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.262"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.262"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.264"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.264"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + N*N
                  MINWRK = BDSPAC + N*N + 3*N
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.272"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.272"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.273"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.273"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.276"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.276"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.278"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.278"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.280"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.280"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + N*N
                  MINWRK = BDSPAC + N*N + 3*N
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               WRKBL = 3*N + ( M+N )*<a name="ILAENV.289"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.289"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                 -1 )
               IF( WNTQN ) THEN
                  MAXWRK = MAX( WRKBL, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               ELSE IF( WNTQO ) THEN
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.296"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.296"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.298"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.298"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + M*N
                  MINWRK = 3*N + MAX( M, N*N+BDSPAC )
               ELSE IF( WNTQS ) THEN
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.304"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.304"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.306"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.306"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               ELSE IF( WNTQA ) THEN
                  WRKBL = MAX( WRKBL, 3*N+M*
     $                    <a name="ILAENV.311"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.311"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.313"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.313"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               END IF
            END IF
         ELSE IF ( MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="SBDSDC.320"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = INT( MINMN*11.0E0 / 6.0E0 )
            IF( WNTQN ) THEN
               BDSPAC = 7*M
            ELSE
               BDSPAC = 3*M*M + 4*M
            END IF
            IF( N.GE.MNTHR ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.333"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.333"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                    -1 )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.336"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.336"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+M )
                  MINWRK = BDSPAC + M
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.343"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.343"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.344"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.344"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.347"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.347"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.349"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.349"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.351"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.351"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + 2*M*M
                  MINWRK = BDSPAC + 2*M*M + 3*M
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.359"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.359"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.360"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.360"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.363"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.363"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.365"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.365"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.367"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.367"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*M
                  MINWRK = BDSPAC + M*M + 3*M
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.375"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.375"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.376"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.376"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.379"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.379"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.381"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.381"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.383"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.383"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*M
                  MINWRK = BDSPAC + M*M + 3*M
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               WRKBL = 3*M + ( M+N )*<a name="ILAENV.392"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.392"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                 -1 )
               IF( WNTQN ) THEN
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               ELSE IF( WNTQO ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.399"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.399"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.401"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.401"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, M, N, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*N
                  MINWRK = 3*M + MAX( N, M*M+BDSPAC )
               ELSE IF( WNTQS ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.407"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.407"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.409"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.409"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               ELSE IF( WNTQA ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.414"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.416"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.416"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, M, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               END IF
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -12
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.431"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="SGESDD.431"></a><a href="sgesdd.f.html#SGESDD.1">SGESDD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.445"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="SLAMCH.446"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="SLANGE.451"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="SLASCL.455"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="SLASCL.458"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEQRF.480"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.485"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = 1
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.494"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing singular values only
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.502"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBZ = 'O')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IR = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IR) is LDWRKR by N
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.LDA*N+N*N+3*N+BDSPAC ) THEN
                  LDWRKR = LDA
               ELSE
                  LDWRKR = ( LWORK-N*N-3*N-BDSPAC ) / N
               END IF
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEQRF.526"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.531"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="SLASET.532"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGQR.538"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in VT, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.548"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               IU = NWORK
               NWORK = IU + N*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.562"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ), N,
     $                      VT, LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of R
</span><span class="comment">*</span><span class="comment">              and VT by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.570"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), WORK( IU ), N, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.573"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in WORK(IR) and copying to A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N*N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">
</span>               DO 10 I = 1, M, LDWRKR
                  CHUNK = MIN( M-I+1, LDWRKR )
                  CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                        LDA, WORK( IU ), N, ZERO, WORK( IR ),
     $                        LDWRKR )
                  CALL <a name="SLACPY.586"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IR ), LDWRKR,
     $                         A( I, 1 ), LDA )
   10          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IR = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKR = N
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEQRF.607"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.612"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="SLASET.613"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGQR.619"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.629"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagoal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.638"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of R and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.646"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.650"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.658"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, N, U, LDU, WORK( IR ), LDWRKR )
               CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA, WORK( IR ),
     $                     LDWRKR, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IU = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKU = N
               ITAU = IU + LDWRKU*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEQRF.679"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SLACPY.681"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span>               CALL <a name="SORGQR.685"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce R in A, zeroing out other entries
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.690"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.699"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.708"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ), N,
     $                      VT, LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of R and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.716"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.719"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU, WORK( IU ),
     $                     LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.732"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + N
            ITAUP = ITAUQ + N
            NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEBRD.751"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, only computing singular values
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.759"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               IU = NWORK
               IF( LWORK.GE.M*N+3*N+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = M
                  NWORK = IU + LDWRKU*N
                  CALL <a name="SLASET.769"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, WORK( IU ),
     $                         LDWRKU )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = N
                  NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IR) is LDWRKR by N
</span><span class="comment">*</span><span class="comment">
</span>                  IR = NWORK
                  LDWRKR = ( LWORK-N*N-3*N ) / N
               END IF
               NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.790"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ),
     $                      LDWRKU, VT, LDVT, DUM, IDUM, WORK( NWORK ),
     $                      IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.797"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*N+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Overwrite WORK(IU) by left singular vectors of A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORMBR.806"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                         WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy left singular vectors of A from WORK(IU) to A
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.812"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IU ), LDWRKU, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.818"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of
</span><span class="comment">*</span><span class="comment">                 bidiagonal matrix in WORK(IU), storing result in
</span><span class="comment">*</span><span class="comment">                 WORK(IR) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N*N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 20 I = 1, M, LDWRKR
                     CHUNK = MIN( M-I+1, LDWRKR )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IU ), LDWRKU, ZERO,
     $                           WORK( IR ), LDWRKR )
                     CALL <a name="SLACPY.831"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IR ), LDWRKR,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.843"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, U, LDU )
               CALL <a name="SBDSDC.844"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.852"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.855"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.865"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M, M, ZERO, ZERO, U, LDU )
               CALL <a name="SBDSDC.866"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set the right corner of U to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               IF( M.GT.N ) THEN
                  CALL <a name="SLASET.873"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M-N, M-N, ZERO, ONE, U( N+1, N+1 ),
     $                         LDU )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N+M, prefer N*N+2*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.881"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.884"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGELQF.910"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.915"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = 1
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.924"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing singular values only
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.932"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, M, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              IVT is M by M
</span><span class="comment">*</span><span class="comment">
</span>               IL = IVT + M*M
               IF( LWORK.GE.M*N+M*M+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKL = M
                  CHUNK = N
               ELSE
                  LDWRKL = M
                  CHUNK = ( LWORK-M*M ) / M
               END IF
               ITAU = IL + LDWRKL*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGELQF.962"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.967"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="SLASET.968"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGLQ.974"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.984"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U, and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.993"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), M, DUM, IDUM, WORK( NWORK ),
     $                      IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and WORK(IVT)
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1001"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.1004"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), WORK( IVT ), M,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IVT) by Q
</span><span class="comment">*</span><span class="comment">              in A, storing result in WORK(IL) and copying to A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M*M, prefer M*M+M*N)
</span><span class="comment">*</span><span class="comment">
</span>               DO 30 I = 1, N, CHUNK
                  BLK = MIN( N-I+1, CHUNK )
                  CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IVT ), M,
     $                        A( 1, I ), LDA, ZERO, WORK( IL ), LDWRKL )
                  CALL <a name="SLACPY.1016"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IL ), LDWRKL,
     $                         A( 1, I ), LDA )
   30          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IL = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IL) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKL = M
               ITAU = IL + LDWRKL*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGELQF.1037"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.1042"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="SLASET.1043"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGLQ.1049"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.1059"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.1068"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1076"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.1079"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IL) by
</span><span class="comment">*</span><span class="comment">              Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.1087"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, M, VT, LDVT, WORK( IL ), LDWRKL )
               CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IL ), LDWRKL,
     $                     A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 4t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IVT) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWKVT = M
               ITAU = IVT + LDWKVT*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGELQF.1108"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SLACPY.1110"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGLQ.1115"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce L in A, zeroing out other entries
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.1120"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.1129"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.1138"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), LDWKVT, DUM, IDUM,
     $                      WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and WORK(IVT)
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1146"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.1149"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IVT) by
</span><span class="comment">*</span><span class="comment">              Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IVT ), LDWKVT,
     $                     VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.1162"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + M
            ITAUP = ITAUQ + M
            NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEBRD.1181"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, only computing singular values
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.1189"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'L'</span>, <span class="string">'N'</span>, M, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               LDWKVT = M
               IVT = NWORK
               IF( LWORK.GE.M*N+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASET.1198"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, WORK( IVT ),
     $                         LDWKVT )
                  NWORK = IVT + LDWKVT*N
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                  NWORK = IVT + LDWKVT*M
                  IL = NWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) is M by CHUNK
</span><span class="comment">*</span><span class="comment">
</span>                  CHUNK = ( LWORK-M*M-3*M ) / M
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSDC.1218"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), LDWKVT, DUM, IDUM,
     $                      WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1225"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Overwrite WORK(IVT) by left singular vectors of A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORMBR.1234"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                         WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy right singular vectors of A from WORK(IVT) to A
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.1240"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IVT ), LDWKVT, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate P**T in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.1246"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by right singular vectors of
</span><span class="comment">*</span><span class="comment">                 bidiagonal matrix in WORK(IVT), storing result in
</span><span class="comment">*</span><span class="comment">                 WORK(IL) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M*M, prefer M*M+M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IVT ),
     $                           LDWKVT, A( 1, I ), LDA, ZERO,
     $                           WORK( IL ), M )
                     CALL <a name="SLACPY.1259"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IL ), M, A( 1, I ),
     $                            LDA )
   40             CONTINUE
               END IF
            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.1270"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, VT, LDVT )
               CALL <a name="SBDSDC.1271"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1279"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.1282"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.1292"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, N, N, ZERO, ZERO, VT, LDVT )
               CALL <a name="SBDSDC.1293"></a><a href="sbdsdc.f.html#SBDSDC.1">SBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set the right corner of VT to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               IF( N.GT.M ) THEN
                  CALL <a name="SLASET.1300"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, N-M, N-M, ZERO, ONE, VT( M+1, M+1 ),
     $                         LDVT )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORMBR.1308"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="SORMBR.1311"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="SLASCL.1324"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="SLASCL.1327"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="SGESDD.1337"></a><a href="sgesdd.f.html#SGESDD.1">SGESDD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
