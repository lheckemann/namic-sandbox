<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dlaqr4.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DLAQR4.1"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
     $                   ILOZ, IHIZ, Z, LDZ, WORK, LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK auxiliary routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
      LOGICAL            WANTT, WANTZ
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      DOUBLE PRECISION   H( LDH, * ), WI( * ), WORK( * ), WR( * ),
     $                   Z( LDZ, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     This subroutine implements one level of recursion for <a name="DLAQR0.17"></a><a href="dlaqr0.f.html#DLAQR0.1">DLAQR0</a>.
</span><span class="comment">*</span><span class="comment">     It is a complete implementation of the small bulge multi-shift
</span><span class="comment">*</span><span class="comment">     QR algorithm.  It may be called by <a name="DLAQR0.19"></a><a href="dlaqr0.f.html#DLAQR0.1">DLAQR0</a> and, for large enough
</span><span class="comment">*</span><span class="comment">     deflation window size, it may be called by <a name="DLAQR3.20"></a><a href="dlaqr3.f.html#DLAQR3.1">DLAQR3</a>.  This
</span><span class="comment">*</span><span class="comment">     subroutine is identical to <a name="DLAQR0.21"></a><a href="dlaqr0.f.html#DLAQR0.1">DLAQR0</a> except that it calls <a name="DLAQR2.21"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>
</span><span class="comment">*</span><span class="comment">     instead of <a name="DLAQR3.22"></a><a href="dlaqr3.f.html#DLAQR3.1">DLAQR3</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Purpose
</span><span class="comment">*</span><span class="comment">     =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     <a name="DLAQR4.27"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a> computes the eigenvalues of a Hessenberg matrix H
</span><span class="comment">*</span><span class="comment">     and, optionally, the matrices T and Z from the Schur decomposition
</span><span class="comment">*</span><span class="comment">     H = Z T Z**T, where T is an upper quasi-triangular matrix (the
</span><span class="comment">*</span><span class="comment">     Schur form), and Z is the orthogonal matrix of Schur vectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Optionally Z may be postmultiplied into an input orthogonal
</span><span class="comment">*</span><span class="comment">     matrix Q so that this routine can give the Schur factorization
</span><span class="comment">*</span><span class="comment">     of a matrix A which has been reduced to the Hessenberg form H
</span><span class="comment">*</span><span class="comment">     by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Arguments
</span><span class="comment">*</span><span class="comment">     =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WANTT   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          = .TRUE. : the full Schur form T is required;
</span><span class="comment">*</span><span class="comment">          = .FALSE.: only eigenvalues are required.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WANTZ   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          = .TRUE. : the matrix of Schur vectors Z is required;
</span><span class="comment">*</span><span class="comment">          = .FALSE.: Schur vectors are not required.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     N     (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The order of the matrix H.  N .GE. 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ILO   (input) INTEGER
</span><span class="comment">*</span><span class="comment">     IHI   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           It is assumed that H is already upper triangular in rows
</span><span class="comment">*</span><span class="comment">           and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
</span><span class="comment">*</span><span class="comment">           H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
</span><span class="comment">*</span><span class="comment">           previous call to <a name="DGEBAL.56"></a><a href="dgebal.f.html#DGEBAL.1">DGEBAL</a>, and then passed to <a name="DGEHRD.56"></a><a href="dgehrd.f.html#DGEHRD.1">DGEHRD</a> when the
</span><span class="comment">*</span><span class="comment">           matrix output by <a name="DGEBAL.57"></a><a href="dgebal.f.html#DGEBAL.1">DGEBAL</a> is reduced to Hessenberg form.
</span><span class="comment">*</span><span class="comment">           Otherwise, ILO and IHI should be set to 1 and N,
</span><span class="comment">*</span><span class="comment">           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
</span><span class="comment">*</span><span class="comment">           If N = 0, then ILO = 1 and IHI = 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     H     (input/output) DOUBLE PRECISION array, dimension (LDH,N)
</span><span class="comment">*</span><span class="comment">           On entry, the upper Hessenberg matrix H.
</span><span class="comment">*</span><span class="comment">           On exit, if INFO = 0 and WANTT is .TRUE., then H contains
</span><span class="comment">*</span><span class="comment">           the upper quasi-triangular matrix T from the Schur
</span><span class="comment">*</span><span class="comment">           decomposition (the Schur form); 2-by-2 diagonal blocks
</span><span class="comment">*</span><span class="comment">           (corresponding to complex conjugate pairs of eigenvalues)
</span><span class="comment">*</span><span class="comment">           are returned in standard form, with H(i,i) = H(i+1,i+1)
</span><span class="comment">*</span><span class="comment">           and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
</span><span class="comment">*</span><span class="comment">           .FALSE., then the contents of H are unspecified on exit.
</span><span class="comment">*</span><span class="comment">           (The output value of H when INFO.GT.0 is given under the
</span><span class="comment">*</span><span class="comment">           description of INFO below.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
</span><span class="comment">*</span><span class="comment">           j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDH   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The leading dimension of the array H. LDH .GE. max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WR    (output) DOUBLE PRECISION array, dimension (IHI)
</span><span class="comment">*</span><span class="comment">     WI    (output) DOUBLE PRECISION array, dimension (IHI)
</span><span class="comment">*</span><span class="comment">           The real and imaginary parts, respectively, of the computed
</span><span class="comment">*</span><span class="comment">           eigenvalues of H(ILO:IHI,ILO:IHI) are stored WR(ILO:IHI)
</span><span class="comment">*</span><span class="comment">           and WI(ILO:IHI). If two eigenvalues are computed as a
</span><span class="comment">*</span><span class="comment">           complex conjugate pair, they are stored in consecutive
</span><span class="comment">*</span><span class="comment">           elements of WR and WI, say the i-th and (i+1)th, with
</span><span class="comment">*</span><span class="comment">           WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
</span><span class="comment">*</span><span class="comment">           the eigenvalues are stored in the same order as on the
</span><span class="comment">*</span><span class="comment">           diagonal of the Schur form returned in H, with
</span><span class="comment">*</span><span class="comment">           WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
</span><span class="comment">*</span><span class="comment">           block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
</span><span class="comment">*</span><span class="comment">           WI(i+1) = -WI(i).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ILOZ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">     IHIZ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">           Specify the rows of Z to which transformations must be
</span><span class="comment">*</span><span class="comment">           applied if WANTZ is .TRUE..
</span><span class="comment">*</span><span class="comment">           1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Z     (input/output) DOUBLE PRECISION array, dimension (LDZ,IHI)
</span><span class="comment">*</span><span class="comment">           If WANTZ is .FALSE., then Z is not referenced.
</span><span class="comment">*</span><span class="comment">           If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
</span><span class="comment">*</span><span class="comment">           replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
</span><span class="comment">*</span><span class="comment">           orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
</span><span class="comment">*</span><span class="comment">           (The output value of Z when INFO.GT.0 is given under
</span><span class="comment">*</span><span class="comment">           the description of INFO below.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDZ   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The leading dimension of the array Z.  if WANTZ is .TRUE.
</span><span class="comment">*</span><span class="comment">           then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WORK  (workspace/output) DOUBLE PRECISION array, dimension LWORK
</span><span class="comment">*</span><span class="comment">           On exit, if LWORK = -1, WORK(1) returns an estimate of
</span><span class="comment">*</span><span class="comment">           the optimal value for LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LWORK (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The dimension of the array WORK.  LWORK .GE. max(1,N)
</span><span class="comment">*</span><span class="comment">           is sufficient, but LWORK typically as large as 6*N may
</span><span class="comment">*</span><span class="comment">           be required for optimal performance.  A workspace query
</span><span class="comment">*</span><span class="comment">           to determine the optimal workspace size is recommended.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           If LWORK = -1, then <a name="DLAQR4.122"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a> does a workspace query.
</span><span class="comment">*</span><span class="comment">           In this case, <a name="DLAQR4.123"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a> checks the input parameters and
</span><span class="comment">*</span><span class="comment">           estimates the optimal workspace size for the given
</span><span class="comment">*</span><span class="comment">           values of N, ILO and IHI.  The estimate is returned
</span><span class="comment">*</span><span class="comment">           in WORK(1).  No error message related to LWORK is
</span><span class="comment">*</span><span class="comment">           issued by <a name="XERBLA.127"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.  Neither H nor Z are accessed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     INFO  (output) INTEGER
</span><span class="comment">*</span><span class="comment">             =  0:  successful exit
</span><span class="comment">*</span><span class="comment">           .GT. 0:  if INFO = i, <a name="DLAQR4.132"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a> failed to compute all of
</span><span class="comment">*</span><span class="comment">                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
</span><span class="comment">*</span><span class="comment">                and WI contain those eigenvalues which have been
</span><span class="comment">*</span><span class="comment">                successfully computed.  (Failures are rare.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANT is .FALSE., then on exit,
</span><span class="comment">*</span><span class="comment">                the remaining unconverged eigenvalues are the eigen-
</span><span class="comment">*</span><span class="comment">                values of the upper Hessenberg matrix rows and
</span><span class="comment">*</span><span class="comment">                columns ILO through INFO of the final, output
</span><span class="comment">*</span><span class="comment">                value of H.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTT is .TRUE., then on exit
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           (*)  (initial value of H)*U  = U*(final value of H)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                where U is an orthogonal matrix.  The final
</span><span class="comment">*</span><span class="comment">                value of H is upper Hessenberg and quasi-triangular
</span><span class="comment">*</span><span class="comment">                in rows and columns INFO+1 through IHI.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTZ is .TRUE., then on exit
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                  (final value of Z(ILO:IHI,ILOZ:IHIZ)
</span><span class="comment">*</span><span class="comment">                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                where U is the orthogonal matrix in (*) (regard-
</span><span class="comment">*</span><span class="comment">                less of the value of WANTT.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
</span><span class="comment">*</span><span class="comment">                accessed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     Based on contributions by
</span><span class="comment">*</span><span class="comment">        Karen Braman and Ralph Byers, Department of Mathematics,
</span><span class="comment">*</span><span class="comment">        University of Kansas, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     References:
</span><span class="comment">*</span><span class="comment">       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
</span><span class="comment">*</span><span class="comment">       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
</span><span class="comment">*</span><span class="comment">       Performance, SIAM Journal of Matrix Analysis, volume 23, pages
</span><span class="comment">*</span><span class="comment">       929--947, 2002.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
</span><span class="comment">*</span><span class="comment">       Algorithm Part II: Aggressive Early Deflation, SIAM Journal
</span><span class="comment">*</span><span class="comment">       of Matrix Analysis, volume 23, pages 948--973, 2002.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Matrices of order NTINY or smaller must be processed by
</span><span class="comment">*</span><span class="comment">     .    <a name="DLAHQR.182"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a> because of insufficient subdiagonal scratch space.
</span><span class="comment">*</span><span class="comment">     .    (This is a hard limit.) ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Exceptional deflation windows:  try to cure rare
</span><span class="comment">*</span><span class="comment">     .    slow convergence by increasing the size of the
</span><span class="comment">*</span><span class="comment">     .    deflation window after KEXNW iterations. =====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Exceptional shifts: try to cure rare slow convergence
</span><span class="comment">*</span><span class="comment">     .    with ad-hoc exceptional shifts every KEXSH iterations.
</span><span class="comment">*</span><span class="comment">     .    The constants WILK1 and WILK2 are used to form the
</span><span class="comment">*</span><span class="comment">     .    exceptional shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>      INTEGER            NTINY
      PARAMETER          ( NTINY = 11 )
      INTEGER            KEXNW, KEXSH
      PARAMETER          ( KEXNW = 5, KEXSH = 6 )
      DOUBLE PRECISION   WILK1, WILK2
      PARAMETER          ( WILK1 = 0.75d0, WILK2 = -0.4375d0 )
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0d0, ONE = 1.0d0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      DOUBLE PRECISION   AA, BB, CC, CS, DD, SN, SS, SWAP
      INTEGER            I, INF, IT, ITMAX, K, KACC22, KBOT, KDU, KS,
     $                   KT, KTOP, KU, KV, KWH, KWTOP, KWV, LD, LS,
     $                   LWKOPT, NDFL, NH, NHO, NIBBLE, NMIN, NS, NSMAX,
     $                   NSR, NVE, NW, NWMAX, NWR
      LOGICAL            NWINC, SORTED
      CHARACTER          JBCMPZ*2
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.213"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      EXTERNAL           <a name="ILAENV.214"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   ZDUM( 1, 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DLACPY.220"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>, <a name="DLAHQR.220"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>, <a name="DLANV2.220"></a><a href="dlanv2.f.html#DLANV2.1">DLANV2</a>, <a name="DLAQR2.220"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>, <a name="DLAQR5.220"></a><a href="dlaqr5.f.html#DLAQR5.1">DLAQR5</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, DBLE, INT, MAX, MIN, MOD
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span>      INFO = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Quick return for N = 0: nothing to do. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 ) THEN
         WORK( 1 ) = ONE
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Set up job flags for <a name="ILAENV.235"></a><a href="hfy-index.html#ILAENV">ILAENV</a>. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( WANTT ) THEN
         JBCMPZ( 1: 1 ) = <span class="string">'S'</span>
      ELSE
         JBCMPZ( 1: 1 ) = <span class="string">'E'</span>
      END IF
      IF( WANTZ ) THEN
         JBCMPZ( 2: 2 ) = <span class="string">'V'</span>
      ELSE
         JBCMPZ( 2: 2 ) = <span class="string">'N'</span>
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Tiny matrices must use <a name="DLAHQR.248"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.LE.NTINY ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Estimate optimal workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         LWKOPT = 1
         IF( LWORK.NE.-1 )
     $      CALL <a name="DLAHQR.256"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>( WANTT, WANTZ, N, ILO, IHI, H, LDH, WR, WI,
     $                   ILOZ, IHIZ, Z, LDZ, INFO )
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Use small bulge multi-shift QR with aggressive early
</span><span class="comment">*</span><span class="comment">        .    deflation on larger-than-tiny matrices. ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Hope for the best. ====
</span><span class="comment">*</span><span class="comment">
</span>         INFO = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NWR = recommended deflation window size.  At this
</span><span class="comment">*</span><span class="comment">        .    point,  N .GT. NTINY = 11, so there is enough
</span><span class="comment">*</span><span class="comment">        .    subdiagonal workspace for NWR.GE.2 as required.
</span><span class="comment">*</span><span class="comment">        .    (In fact, there is enough subdiagonal space for
</span><span class="comment">*</span><span class="comment">        .    NWR.GE.3.) ====
</span><span class="comment">*</span><span class="comment">
</span>         NWR = <a name="ILAENV.273"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 13, <span class="string">'<a name="DLAQR4.273"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NWR = MAX( 2, NWR )
         NWR = MIN( IHI-ILO+1, ( N-1 ) / 3, NWR )
         NW = NWR
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NSR = recommended number of simultaneous shifts.
</span><span class="comment">*</span><span class="comment">        .    At this point N .GT. NTINY = 11, so there is at
</span><span class="comment">*</span><span class="comment">        .    enough subdiagonal workspace for NSR to be even
</span><span class="comment">*</span><span class="comment">        .    and greater than or equal to two as required. ====
</span><span class="comment">*</span><span class="comment">
</span>         NSR = <a name="ILAENV.283"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 15, <span class="string">'<a name="DLAQR4.283"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NSR = MIN( NSR, ( N+6 ) / 9, IHI-ILO )
         NSR = MAX( 2, NSR-MOD( NSR, 2 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Estimate optimal workspace ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Workspace query call to <a name="DLAQR2.289"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a> ====
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLAQR2.291"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>( WANTT, WANTZ, N, ILO, IHI, NWR+1, H, LDH, ILOZ,
     $                IHIZ, Z, LDZ, LS, LD, WR, WI, H, LDH, N, H, LDH,
     $                N, H, LDH, WORK, -1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Optimal workspace = MAX(<a name="DLAQR5.295"></a><a href="dlaqr5.f.html#DLAQR5.1">DLAQR5</a>, <a name="DLAQR2.295"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>) ====
</span><span class="comment">*</span><span class="comment">
</span>         LWKOPT = MAX( 3*NSR / 2, INT( WORK( 1 ) ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Quick return in case of workspace query. ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.EQ.-1 ) THEN
            WORK( 1 ) = DBLE( LWKOPT )
            RETURN
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== <a name="DLAHQR.306"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>/<a name="DLAQR0.306"></a><a href="dlaqr0.f.html#DLAQR0.1">DLAQR0</a> crossover point ====
</span><span class="comment">*</span><span class="comment">
</span>         NMIN = <a name="ILAENV.308"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 12, <span class="string">'<a name="DLAQR4.308"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NMIN = MAX( NTINY, NMIN )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Nibble crossover point ====
</span><span class="comment">*</span><span class="comment">
</span>         NIBBLE = <a name="ILAENV.313"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 14, <span class="string">'<a name="DLAQR4.313"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NIBBLE = MAX( 0, NIBBLE )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Accumulate reflections during ttswp?  Use block
</span><span class="comment">*</span><span class="comment">        .    2-by-2 structure during matrix-matrix multiply? ====
</span><span class="comment">*</span><span class="comment">
</span>         KACC22 = <a name="ILAENV.319"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 16, <span class="string">'<a name="DLAQR4.319"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         KACC22 = MAX( 0, KACC22 )
         KACC22 = MIN( 2, KACC22 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NWMAX = the largest possible deflation window for
</span><span class="comment">*</span><span class="comment">        .    which there is sufficient workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         NWMAX = MIN( ( N-1 ) / 3, LWORK / 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NSMAX = the Largest number of simultaneous shifts
</span><span class="comment">*</span><span class="comment">        .    for which there is sufficient workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         NSMAX = MIN( ( N+6 ) / 9, 2*LWORK / 3 )
         NSMAX = NSMAX - MOD( NSMAX, 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NDFL: an iteration count restarted at deflation. ====
</span><span class="comment">*</span><span class="comment">
</span>         NDFL = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== ITMAX = iteration limit ====
</span><span class="comment">*</span><span class="comment">
</span>         ITMAX = MAX( 30, 2*KEXSH )*MAX( 10, ( IHI-ILO+1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Last row and column in the active block ====
</span><span class="comment">*</span><span class="comment">
</span>         KBOT = IHI
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Main Loop ====
</span><span class="comment">*</span><span class="comment">
</span>         DO 80 IT = 1, ITMAX
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Done when KBOT falls below ILO ====
</span><span class="comment">*</span><span class="comment">
</span>            IF( KBOT.LT.ILO )
     $         GO TO 90
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Locate active block ====
</span><span class="comment">*</span><span class="comment">
</span>            DO 10 K = KBOT, ILO + 1, -1
               IF( H( K, K-1 ).EQ.ZERO )
     $            GO TO 20
   10       CONTINUE
            K = ILO
   20       CONTINUE
            KTOP = K
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Select deflation window size ====
</span><span class="comment">*</span><span class="comment">
</span>            NH = KBOT - KTOP + 1
            IF( NDFL.LT.KEXNW .OR. NH.LT.NW ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Typical deflation window.  If possible and
</span><span class="comment">*</span><span class="comment">              .    advisable, nibble the entire active block.
</span><span class="comment">*</span><span class="comment">              .    If not, use size NWR or NWR+1 depending upon
</span><span class="comment">*</span><span class="comment">              .    which has the smaller corresponding subdiagonal
</span><span class="comment">*</span><span class="comment">              .    entry (a heuristic). ====
</span><span class="comment">*</span><span class="comment">
</span>               NWINC = .TRUE.
               IF( NH.LE.MIN( NMIN, NWMAX ) ) THEN
                  NW = NH
               ELSE
                  NW = MIN( NWR, NH, NWMAX )
                  IF( NW.LT.NWMAX ) THEN
                     IF( NW.GE.NH-1 ) THEN
                        NW = NH
                     ELSE
                        KWTOP = KBOT - NW + 1
                        IF( ABS( H( KWTOP, KWTOP-1 ) ).GT.
     $                      ABS( H( KWTOP-1, KWTOP-2 ) ) )NW = NW + 1
                     END IF
                  END IF
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Exceptional deflation window.  If there have
</span><span class="comment">*</span><span class="comment">              .    been no deflations in KEXNW or more iterations,
</span><span class="comment">*</span><span class="comment">              .    then vary the deflation window size.   At first,
</span><span class="comment">*</span><span class="comment">              .    because, larger windows are, in general, more
</span><span class="comment">*</span><span class="comment">              .    powerful than smaller ones, rapidly increase the
</span><span class="comment">*</span><span class="comment">              .    window up to the maximum reasonable and possible.
</span><span class="comment">*</span><span class="comment">              .    Then maybe try a slightly smaller window.  ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( NWINC .AND. NW.LT.MIN( NWMAX, NH ) ) THEN
                  NW = MIN( NWMAX, NH, 2*NW )
               ELSE
                  NWINC = .FALSE.
                  IF( NW.EQ.NH .AND. NH.GT.2 )
     $               NW = NH - 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Aggressive early deflation:
</span><span class="comment">*</span><span class="comment">           .    split workspace under the subdiagonal into
</span><span class="comment">*</span><span class="comment">           .      - an nw-by-nw work array V in the lower
</span><span class="comment">*</span><span class="comment">           .        left-hand-corner,
</span><span class="comment">*</span><span class="comment">           .      - an NW-by-at-least-NW-but-more-is-better
</span><span class="comment">*</span><span class="comment">           .        (NW-by-NHO) horizontal work array along
</span><span class="comment">*</span><span class="comment">           .        the bottom edge,
</span><span class="comment">*</span><span class="comment">           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
</span><span class="comment">*</span><span class="comment">           .        vertical work array along the left-hand-edge.
</span><span class="comment">*</span><span class="comment">           .        ====
</span><span class="comment">*</span><span class="comment">
</span>            KV = N - NW + 1
            KT = NW + 1
            NHO = ( N-NW-1 ) - KT + 1
            KWV = NW + 2
            NVE = ( N-NW ) - KWV + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Aggressive early deflation ====
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLAQR2.429"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
     $                   IHIZ, Z, LDZ, LS, LD, WR, WI, H( KV, 1 ), LDH,
     $                   NHO, H( KV, KT ), LDH, NVE, H( KWV, 1 ), LDH,
     $                   WORK, LWORK )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Adjust KBOT accounting for new deflations. ====
</span><span class="comment">*</span><span class="comment">
</span>            KBOT = KBOT - LD
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== KS points to the shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>            KS = KBOT - LS + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Skip an expensive QR sweep if there is a (partly
</span><span class="comment">*</span><span class="comment">           .    heuristic) reason to expect that many eigenvalues
</span><span class="comment">*</span><span class="comment">           .    will deflate without it.  Here, the QR sweep is
</span><span class="comment">*</span><span class="comment">           .    skipped if many eigenvalues have just been deflated
</span><span class="comment">*</span><span class="comment">           .    or if the remaining active block is small.
</span><span class="comment">*</span><span class="comment">
</span>            IF( ( LD.EQ.0 ) .OR. ( ( 100*LD.LE.NW*NIBBLE ) .AND. ( KBOT-
     $          KTOP+1.GT.MIN( NMIN, NWMAX ) ) ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== NS = nominal number of simultaneous shifts.
</span><span class="comment">*</span><span class="comment">              .    This may be lowered (slightly) if <a name="DLAQR2.452"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a>
</span><span class="comment">*</span><span class="comment">              .    did not provide that many shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = MIN( NSMAX, NSR, MAX( 2, KBOT-KTOP ) )
               NS = NS - MOD( NS, 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== If there have been no deflations
</span><span class="comment">*</span><span class="comment">              .    in a multiple of KEXSH iterations,
</span><span class="comment">*</span><span class="comment">              .    then try exceptional shifts.
</span><span class="comment">*</span><span class="comment">              .    Otherwise use shifts provided by
</span><span class="comment">*</span><span class="comment">              .    <a name="DLAQR2.462"></a><a href="dlaqr2.f.html#DLAQR2.1">DLAQR2</a> above or from the eigenvalues
</span><span class="comment">*</span><span class="comment">              .    of a trailing principal submatrix. ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( MOD( NDFL, KEXSH ).EQ.0 ) THEN
                  KS = KBOT - NS + 1
                  DO 30 I = KBOT, MAX( KS+1, KTOP+2 ), -2
                     SS = ABS( H( I, I-1 ) ) + ABS( H( I-1, I-2 ) )
                     AA = WILK1*SS + H( I, I )
                     BB = SS
                     CC = WILK2*SS
                     DD = AA
                     CALL <a name="DLANV2.473"></a><a href="dlanv2.f.html#DLANV2.1">DLANV2</a>( AA, BB, CC, DD, WR( I-1 ), WI( I-1 ),
     $                            WR( I ), WI( I ), CS, SN )
   30             CONTINUE
                  IF( KS.EQ.KTOP ) THEN
                     WR( KS+1 ) = H( KS+1, KS+1 )
                     WI( KS+1 ) = ZERO
                     WR( KS ) = WR( KS+1 )
                     WI( KS ) = WI( KS+1 )
                  END IF
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 ==== Got NS/2 or fewer shifts? Use <a name="DLAHQR.484"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>
</span><span class="comment">*</span><span class="comment">                 .    on a trailing principal submatrix to
</span><span class="comment">*</span><span class="comment">                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
</span><span class="comment">*</span><span class="comment">                 .    there is enough space below the subdiagonal
</span><span class="comment">*</span><span class="comment">                 .    to fit an NS-by-NS scratch array.) ====
</span><span class="comment">*</span><span class="comment">
</span>                  IF( KBOT-KS+1.LE.NS / 2 ) THEN
                     KS = KBOT - NS + 1
                     KT = N - NS + 1
                     CALL <a name="DLACPY.493"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'A'</span>, NS, NS, H( KS, KS ), LDH,
     $                            H( KT, 1 ), LDH )
                     CALL <a name="DLAHQR.495"></a><a href="dlahqr.f.html#DLAHQR.1">DLAHQR</a>( .false., .false., NS, 1, NS,
     $                            H( KT, 1 ), LDH, WR( KS ), WI( KS ),
     $                            1, 1, ZDUM, 1, INF )
                     KS = KS + INF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    ==== In case of a rare QR failure use
</span><span class="comment">*</span><span class="comment">                    .    eigenvalues of the trailing 2-by-2
</span><span class="comment">*</span><span class="comment">                    .    principal submatrix.  ====
</span><span class="comment">*</span><span class="comment">
</span>                     IF( KS.GE.KBOT ) THEN
                        AA = H( KBOT-1, KBOT-1 )
                        CC = H( KBOT, KBOT-1 )
                        BB = H( KBOT-1, KBOT )
                        DD = H( KBOT, KBOT )
                        CALL <a name="DLANV2.509"></a><a href="dlanv2.f.html#DLANV2.1">DLANV2</a>( AA, BB, CC, DD, WR( KBOT-1 ),
     $                               WI( KBOT-1 ), WR( KBOT ),
     $                               WI( KBOT ), CS, SN )
                        KS = KBOT - 1
                     END IF
                  END IF
<span class="comment">*</span><span class="comment">
</span>                  IF( KBOT-KS+1.GT.NS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    ==== Sort the shifts (Helps a little)
</span><span class="comment">*</span><span class="comment">                    .    Bubble sort keeps complex conjugate
</span><span class="comment">*</span><span class="comment">                    .    pairs together. ====
</span><span class="comment">*</span><span class="comment">
</span>                     SORTED = .false.
                     DO 50 K = KBOT, KS + 1, -1
                        IF( SORTED )
     $                     GO TO 60
                        SORTED = .true.
                        DO 40 I = KS, K - 1
                           IF( ABS( WR( I ) )+ABS( WI( I ) ).LT.
     $                         ABS( WR( I+1 ) )+ABS( WI( I+1 ) ) ) THEN
                              SORTED = .false.
<span class="comment">*</span><span class="comment">
</span>                              SWAP = WR( I )
                              WR( I ) = WR( I+1 )
                              WR( I+1 ) = SWAP
<span class="comment">*</span><span class="comment">
</span>                              SWAP = WI( I )
                              WI( I ) = WI( I+1 )
                              WI( I+1 ) = SWAP
                           END IF
   40                   CONTINUE
   50                CONTINUE
   60                CONTINUE
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 ==== Shuffle shifts into pairs of real shifts
</span><span class="comment">*</span><span class="comment">                 .    and pairs of complex conjugate shifts
</span><span class="comment">*</span><span class="comment">                 .    assuming complex conjugate shifts are
</span><span class="comment">*</span><span class="comment">                 .    already adjacent to one another. (Yes,
</span><span class="comment">*</span><span class="comment">                 .    they are.)  ====
</span><span class="comment">*</span><span class="comment">
</span>                  DO 70 I = KBOT, KS + 2, -2
                     IF( WI( I ).NE.-WI( I-1 ) ) THEN
<span class="comment">*</span><span class="comment">
</span>                        SWAP = WR( I )
                        WR( I ) = WR( I-1 )
                        WR( I-1 ) = WR( I-2 )
                        WR( I-2 ) = SWAP
<span class="comment">*</span><span class="comment">
</span>                        SWAP = WI( I )
                        WI( I ) = WI( I-1 )
                        WI( I-1 ) = WI( I-2 )
                        WI( I-2 ) = SWAP
                     END IF
   70             CONTINUE
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== If there are only two shifts and both are
</span><span class="comment">*</span><span class="comment">              .    real, then use only one.  ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( KBOT-KS+1.EQ.2 ) THEN
                  IF( WI( KBOT ).EQ.ZERO ) THEN
                     IF( ABS( WR( KBOT )-H( KBOT, KBOT ) ).LT.
     $                   ABS( WR( KBOT-1 )-H( KBOT, KBOT ) ) ) THEN
                        WR( KBOT-1 ) = WR( KBOT )
                     ELSE
                        WR( KBOT ) = WR( KBOT-1 )
                     END IF
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Use up to NS of the the smallest magnatiude
</span><span class="comment">*</span><span class="comment">              .    shifts.  If there aren't NS shifts available,
</span><span class="comment">*</span><span class="comment">              .    then use them all, possibly dropping one to
</span><span class="comment">*</span><span class="comment">              .    make the number of shifts even. ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = MIN( NS, KBOT-KS+1 )
               NS = NS - MOD( NS, 2 )
               KS = KBOT - NS + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Small-bulge multi-shift QR sweep:
</span><span class="comment">*</span><span class="comment">              .    split workspace under the subdiagonal into
</span><span class="comment">*</span><span class="comment">              .    - a KDU-by-KDU work array U in the lower
</span><span class="comment">*</span><span class="comment">              .      left-hand-corner,
</span><span class="comment">*</span><span class="comment">              .    - a KDU-by-at-least-KDU-but-more-is-better
</span><span class="comment">*</span><span class="comment">              .      (KDU-by-NHo) horizontal work array WH along
</span><span class="comment">*</span><span class="comment">              .      the bottom edge,
</span><span class="comment">*</span><span class="comment">              .    - and an at-least-KDU-but-more-is-better-by-KDU
</span><span class="comment">*</span><span class="comment">              .      (NVE-by-KDU) vertical work WV arrow along
</span><span class="comment">*</span><span class="comment">              .      the left-hand-edge. ====
</span><span class="comment">*</span><span class="comment">
</span>               KDU = 3*NS - 3
               KU = N - KDU + 1
               KWH = KDU + 1
               NHO = ( N-KDU+1-4 ) - ( KDU+1 ) + 1
               KWV = KDU + 4
               NVE = N - KDU - KWV + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Small-bulge multi-shift QR sweep ====
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLAQR5.610"></a><a href="dlaqr5.f.html#DLAQR5.1">DLAQR5</a>( WANTT, WANTZ, KACC22, N, KTOP, KBOT, NS,
     $                      WR( KS ), WI( KS ), H, LDH, ILOZ, IHIZ, Z,
     $                      LDZ, WORK, 3, H( KU, 1 ), LDH, NVE,
     $                      H( KWV, 1 ), LDH, NHO, H( KU, KWH ), LDH )
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Note progress (or the lack of it). ====
</span><span class="comment">*</span><span class="comment">
</span>            IF( LD.GT.0 ) THEN
               NDFL = 1
            ELSE
               NDFL = NDFL + 1
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== End of main loop ====
</span>   80    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Iteration limit exceeded.  Set INFO to show where
</span><span class="comment">*</span><span class="comment">        .    the problem occurred and exit. ====
</span><span class="comment">*</span><span class="comment">
</span>         INFO = KBOT
   90    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Return the optimal value of LWORK. ====
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = DBLE( LWKOPT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== End of <a name="DLAQR4.638"></a><a href="dlaqr4.f.html#DLAQR4.1">DLAQR4</a> ====
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
