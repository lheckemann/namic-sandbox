<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>stgsy2.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="STGSY2.1"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a>( TRANS, IJOB, M, N, A, LDA, B, LDB, C, LDC, D,
     $                   LDD, E, LDE, F, LDF, SCALE, RDSUM, RDSCAL,
     $                   IWORK, PQ, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK auxiliary routine (version 3.1.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     January 2007
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          TRANS
      INTEGER            IJOB, INFO, LDA, LDB, LDC, LDD, LDE, LDF, M, N,
     $                   PQ
      REAL               RDSCAL, RDSUM, SCALE
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      REAL               A( LDA, * ), B( LDB, * ), C( LDC, * ),
     $                   D( LDD, * ), E( LDE, * ), F( LDF, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="STGSY2.24"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a> solves the generalized Sylvester equation:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              A * R - L * B = scale * C                (1)
</span><span class="comment">*</span><span class="comment">              D * R - L * E = scale * F,
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
</span><span class="comment">*</span><span class="comment">  (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
</span><span class="comment">*</span><span class="comment">  N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
</span><span class="comment">*</span><span class="comment">  must be in generalized Schur canonical form, i.e. A, B are upper
</span><span class="comment">*</span><span class="comment">  quasi triangular and D, E are upper triangular. The solution (R, L)
</span><span class="comment">*</span><span class="comment">  overwrites (C, F). 0 &lt;= SCALE &lt;= 1 is an output scaling factor
</span><span class="comment">*</span><span class="comment">  chosen to avoid overflow.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  In matrix notation solving equation (1) corresponds to solve
</span><span class="comment">*</span><span class="comment">  Z*x = scale*b, where Z is defined as
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         Z = [ kron(In, A)  -kron(B', Im) ]             (2)
</span><span class="comment">*</span><span class="comment">             [ kron(In, D)  -kron(E', Im) ],
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Ik is the identity matrix of size k and X' is the transpose of X.
</span><span class="comment">*</span><span class="comment">  kron(X, Y) is the Kronecker product between the matrices X and Y.
</span><span class="comment">*</span><span class="comment">  In the process of solving (1), we solve a number of such systems
</span><span class="comment">*</span><span class="comment">  where Dim(In), Dim(In) = 1 or 2.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If TRANS = 'T', solve the transposed system Z'*y = scale*b for y,
</span><span class="comment">*</span><span class="comment">  which is equivalent to solve for R and L in
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              A' * R  + D' * L   = scale *  C           (3)
</span><span class="comment">*</span><span class="comment">              R  * B' + L  * E'  = scale * -F
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This case is used to compute an estimate of Dif[(A, D), (B, E)] =
</span><span class="comment">*</span><span class="comment">  sigma_min(Z) using reverse communicaton with <a name="SLACON.55"></a><a href="slacon.f.html#SLACON.1">SLACON</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="STGSY2.57"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a> also (IJOB &gt;= 1) contributes to the computation in <a name="STGSYL.57"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a>
</span><span class="comment">*</span><span class="comment">  of an upper bound on the separation between to matrix pairs. Then
</span><span class="comment">*</span><span class="comment">  the input (A, D), (B, E) are sub-pencils of the matrix pair in
</span><span class="comment">*</span><span class="comment">  <a name="STGSYL.60"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a>. See <a name="STGSYL.60"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a> for details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  TRANS   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N', solve the generalized Sylvester equation (1).
</span><span class="comment">*</span><span class="comment">          = 'T': solve the 'transposed' system (3).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IJOB    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          Specifies what kind of functionality to be performed.
</span><span class="comment">*</span><span class="comment">          = 0: solve (1) only.
</span><span class="comment">*</span><span class="comment">          = 1: A contribution from this subsystem to a Frobenius
</span><span class="comment">*</span><span class="comment">               norm-based estimate of the separation between two matrix
</span><span class="comment">*</span><span class="comment">               pairs is computed. (look ahead strategy is used).
</span><span class="comment">*</span><span class="comment">          = 2: A contribution from this subsystem to a Frobenius
</span><span class="comment">*</span><span class="comment">               norm-based estimate of the separation between two matrix
</span><span class="comment">*</span><span class="comment">               pairs is computed. (<a name="SGECON.77"></a><a href="sgecon.f.html#SGECON.1">SGECON</a> on sub-systems is used.)
</span><span class="comment">*</span><span class="comment">          Not referenced if TRANS = 'T'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          On entry, M specifies the order of A and D, and the row
</span><span class="comment">*</span><span class="comment">          dimension of C, F, R and L.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          On entry, N specifies the order of B and E, and the column
</span><span class="comment">*</span><span class="comment">          dimension of C, F, R and L.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input) REAL array, dimension (LDA, M)
</span><span class="comment">*</span><span class="comment">          On entry, A contains an upper quasi triangular matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix A. LDA &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input) REAL array, dimension (LDB, N)
</span><span class="comment">*</span><span class="comment">          On entry, B contains an upper quasi triangular matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix B. LDB &gt;= max(1, N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  C       (input/output) REAL array, dimension (LDC, N)
</span><span class="comment">*</span><span class="comment">          On entry, C contains the right-hand-side of the first matrix
</span><span class="comment">*</span><span class="comment">          equation in (1).
</span><span class="comment">*</span><span class="comment">          On exit, if IJOB = 0, C has been overwritten by the
</span><span class="comment">*</span><span class="comment">          solution R.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDC     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix C. LDC &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  D       (input) REAL array, dimension (LDD, M)
</span><span class="comment">*</span><span class="comment">          On entry, D contains an upper triangular matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDD     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix D. LDD &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  E       (input) REAL array, dimension (LDE, N)
</span><span class="comment">*</span><span class="comment">          On entry, E contains an upper triangular matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDE     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix E. LDE &gt;= max(1, N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  F       (input/output) REAL array, dimension (LDF, N)
</span><span class="comment">*</span><span class="comment">          On entry, F contains the right-hand-side of the second matrix
</span><span class="comment">*</span><span class="comment">          equation in (1).
</span><span class="comment">*</span><span class="comment">          On exit, if IJOB = 0, F has been overwritten by the
</span><span class="comment">*</span><span class="comment">          solution L.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDF     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix F. LDF &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SCALE   (output) REAL
</span><span class="comment">*</span><span class="comment">          On exit, 0 &lt;= SCALE &lt;= 1. If 0 &lt; SCALE &lt; 1, the solutions
</span><span class="comment">*</span><span class="comment">          R and L (C and F on entry) will hold the solutions to a
</span><span class="comment">*</span><span class="comment">          slightly perturbed system but the input matrices A, B, D and
</span><span class="comment">*</span><span class="comment">          E have not been changed. If SCALE = 0, R and L will hold the
</span><span class="comment">*</span><span class="comment">          solutions to the homogeneous system with C = F = 0. Normally,
</span><span class="comment">*</span><span class="comment">          SCALE = 1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RDSUM   (input/output) REAL
</span><span class="comment">*</span><span class="comment">          On entry, the sum of squares of computed contributions to
</span><span class="comment">*</span><span class="comment">          the Dif-estimate under computation by <a name="STGSYL.140"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a>, where the
</span><span class="comment">*</span><span class="comment">          scaling factor RDSCAL (see below) has been factored out.
</span><span class="comment">*</span><span class="comment">          On exit, the corresponding sum of squares updated with the
</span><span class="comment">*</span><span class="comment">          contributions from the current sub-system.
</span><span class="comment">*</span><span class="comment">          If TRANS = 'T' RDSUM is not touched.
</span><span class="comment">*</span><span class="comment">          NOTE: RDSUM only makes sense when <a name="STGSY2.145"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a> is called by <a name="STGSYL.145"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RDSCAL  (input/output) REAL
</span><span class="comment">*</span><span class="comment">          On entry, scaling factor used to prevent overflow in RDSUM.
</span><span class="comment">*</span><span class="comment">          On exit, RDSCAL is updated w.r.t. the current contributions
</span><span class="comment">*</span><span class="comment">          in RDSUM.
</span><span class="comment">*</span><span class="comment">          If TRANS = 'T', RDSCAL is not touched.
</span><span class="comment">*</span><span class="comment">          NOTE: RDSCAL only makes sense when <a name="STGSY2.152"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a> is called by
</span><span class="comment">*</span><span class="comment">                <a name="STGSYL.153"></a><a href="stgsyl.f.html#STGSYL.1">STGSYL</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (M+N+2)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  PQ      (output) INTEGER
</span><span class="comment">*</span><span class="comment">          On exit, the number of subsystems (of size 2-by-2, 4-by-4 and
</span><span class="comment">*</span><span class="comment">          8-by-8) solved by this routine.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          On exit, if INFO is set to
</span><span class="comment">*</span><span class="comment">            =0: Successful exit
</span><span class="comment">*</span><span class="comment">            &lt;0: If INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">            &gt;0: The matrix pairs (A, D) and (B, E) have common or very
</span><span class="comment">*</span><span class="comment">                close eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
</span><span class="comment">*</span><span class="comment">     Umea University, S-901 87 Umea, Sweden.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">  Replaced various illegal calls to SCOPY by calls to <a name="SLASET.176"></a><a href="slaset.f.html#SLASET.1">SLASET</a>.
</span><span class="comment">*</span><span class="comment">  Sven Hammarling, 27/5/02.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      INTEGER            LDZ
      PARAMETER          ( LDZ = 8 )
      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            NOTRAN
      INTEGER            I, IE, IERR, II, IS, ISP1, J, JE, JJ, JS, JSP1,
     $                   K, MB, NB, P, Q, ZDIM
      REAL               ALPHA, SCALOC
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      INTEGER            IPIV( LDZ ), JPIV( LDZ )
      REAL               RHS( LDZ ), Z( LDZ, LDZ )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.196"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      EXTERNAL           <a name="LSAME.197"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           SAXPY, SCOPY, SGEMM, SGEMV, SGER, <a name="SGESC2.200"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>,
     $                   <a name="SGETC2.201"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>, SSCAL, <a name="SLASET.201"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SLATDF.201"></a><a href="slatdf.f.html#SLATDF.1">SLATDF</a>, <a name="XERBLA.201"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode and test input parameters
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      IERR = 0
      NOTRAN = <a name="LSAME.212"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANS, <span class="string">'N'</span> )
      IF( .NOT.NOTRAN .AND. .NOT.<a name="LSAME.213"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANS, <span class="string">'T'</span> ) ) THEN
         INFO = -1
      ELSE IF( NOTRAN ) THEN
         IF( ( IJOB.LT.0 ) .OR. ( IJOB.GT.2 ) ) THEN
            INFO = -2
         END IF
      END IF
      IF( INFO.EQ.0 ) THEN
         IF( M.LE.0 ) THEN
            INFO = -3
         ELSE IF( N.LE.0 ) THEN
            INFO = -4
         ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
            INFO = -5
         ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
            INFO = -8
         ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
            INFO = -10
         ELSE IF( LDD.LT.MAX( 1, M ) ) THEN
            INFO = -12
         ELSE IF( LDE.LT.MAX( 1, N ) ) THEN
            INFO = -14
         ELSE IF( LDF.LT.MAX( 1, M ) ) THEN
            INFO = -16
         END IF
      END IF
      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.240"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="STGSY2.240"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a>'</span>, -INFO )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Determine block structure of A
</span><span class="comment">*</span><span class="comment">
</span>      PQ = 0
      P = 0
      I = 1
   10 CONTINUE
      IF( I.GT.M )
     $   GO TO 20
      P = P + 1
      IWORK( P ) = I
      IF( I.EQ.M )
     $   GO TO 20
      IF( A( I+1, I ).NE.ZERO ) THEN
         I = I + 2
      ELSE
         I = I + 1
      END IF
      GO TO 10
   20 CONTINUE
      IWORK( P+1 ) = M + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Determine block structure of B
</span><span class="comment">*</span><span class="comment">
</span>      Q = P + 1
      J = 1
   30 CONTINUE
      IF( J.GT.N )
     $   GO TO 40
      Q = Q + 1
      IWORK( Q ) = J
      IF( J.EQ.N )
     $   GO TO 40
      IF( B( J+1, J ).NE.ZERO ) THEN
         J = J + 2
      ELSE
         J = J + 1
      END IF
      GO TO 30
   40 CONTINUE
      IWORK( Q+1 ) = N + 1
      PQ = P*( Q-P-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( NOTRAN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve (I, J) - subsystem
</span><span class="comment">*</span><span class="comment">           A(I, I) * R(I, J) - L(I, J) * B(J, J) = C(I, J)
</span><span class="comment">*</span><span class="comment">           D(I, I) * R(I, J) - L(I, J) * E(J, J) = F(I, J)
</span><span class="comment">*</span><span class="comment">        for I = P, P - 1, ..., 1; J = 1, 2, ..., Q
</span><span class="comment">*</span><span class="comment">
</span>         SCALE = ONE
         SCALOC = ONE
         DO 120 J = P + 2, Q
            JS = IWORK( J )
            JSP1 = JS + 1
            JE = IWORK( J+1 ) - 1
            NB = JE - JS + 1
            DO 110 I = P, 1, -1
<span class="comment">*</span><span class="comment">
</span>               IS = IWORK( I )
               ISP1 = IS + 1
               IE = IWORK( I+1 ) - 1
               MB = IE - IS + 1
               ZDIM = MB*NB*2
<span class="comment">*</span><span class="comment">
</span>               IF( ( MB.EQ.1 ) .AND. ( NB.EQ.1 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 2-by-2 system Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = D( IS, IS )
                  Z( 1, 2 ) = -B( JS, JS )
                  Z( 2, 2 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = F( IS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.324"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
<span class="comment">*</span><span class="comment">
</span>                  IF( IJOB.EQ.0 ) THEN
                     CALL <a name="SGESC2.329"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV,
     $                            SCALOC )
                     IF( SCALOC.NE.ONE ) THEN
                        DO 50 K = 1, N
                           CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                           CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
   50                   CONTINUE
                        SCALE = SCALE*SCALOC
                     END IF
                  ELSE
                     CALL <a name="SLATDF.339"></a><a href="slatdf.f.html#SLATDF.1">SLATDF</a>( IJOB, ZDIM, Z, LDZ, RHS, RDSUM,
     $                            RDSCAL, IPIV, JPIV )
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  F( IS, JS ) = RHS( 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( I.GT.1 ) THEN
                     ALPHA = -RHS( 1 )
                     CALL SAXPY( IS-1, ALPHA, A( 1, IS ), 1, C( 1, JS ),
     $                           1 )
                     CALL SAXPY( IS-1, ALPHA, D( 1, IS ), 1, F( 1, JS ),
     $                           1 )
                  END IF
                  IF( J.LT.Q ) THEN
                     CALL SAXPY( N-JE, RHS( 2 ), B( JS, JE+1 ), LDB,
     $                           C( IS, JE+1 ), LDC )
                     CALL SAXPY( N-JE, RHS( 2 ), E( JS, JE+1 ), LDE,
     $                           F( IS, JE+1 ), LDF )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.1 ) .AND. ( NB.EQ.2 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 4-by-4 system Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = ZERO
                  Z( 3, 1 ) = D( IS, IS )
                  Z( 4, 1 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = ZERO
                  Z( 2, 2 ) = A( IS, IS )
                  Z( 3, 2 ) = ZERO
                  Z( 4, 2 ) = D( IS, IS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 3 ) = -B( JS, JS )
                  Z( 2, 3 ) = -B( JS, JSP1 )
                  Z( 3, 3 ) = -E( JS, JS )
                  Z( 4, 3 ) = -E( JS, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 4 ) = -B( JSP1, JS )
                  Z( 2, 4 ) = -B( JSP1, JSP1 )
                  Z( 3, 4 ) = ZERO
                  Z( 4, 4 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = C( IS, JSP1 )
                  RHS( 3 ) = F( IS, JS )
                  RHS( 4 ) = F( IS, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.398"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
<span class="comment">*</span><span class="comment">
</span>                  IF( IJOB.EQ.0 ) THEN
                     CALL <a name="SGESC2.403"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV,
     $                            SCALOC )
                     IF( SCALOC.NE.ONE ) THEN
                        DO 60 K = 1, N
                           CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                           CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
   60                   CONTINUE
                        SCALE = SCALE*SCALOC
                     END IF
                  ELSE
                     CALL <a name="SLATDF.413"></a><a href="slatdf.f.html#SLATDF.1">SLATDF</a>( IJOB, ZDIM, Z, LDZ, RHS, RDSUM,
     $                            RDSCAL, IPIV, JPIV )
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  C( IS, JSP1 ) = RHS( 2 )
                  F( IS, JS ) = RHS( 3 )
                  F( IS, JSP1 ) = RHS( 4 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( I.GT.1 ) THEN
                     CALL SGER( IS-1, NB, -ONE, A( 1, IS ), 1, RHS( 1 ),
     $                          1, C( 1, JS ), LDC )
                     CALL SGER( IS-1, NB, -ONE, D( 1, IS ), 1, RHS( 1 ),
     $                          1, F( 1, JS ), LDF )
                  END IF
                  IF( J.LT.Q ) THEN
                     CALL SAXPY( N-JE, RHS( 3 ), B( JS, JE+1 ), LDB,
     $                           C( IS, JE+1 ), LDC )
                     CALL SAXPY( N-JE, RHS( 3 ), E( JS, JE+1 ), LDE,
     $                           F( IS, JE+1 ), LDF )
                     CALL SAXPY( N-JE, RHS( 4 ), B( JSP1, JE+1 ), LDB,
     $                           C( IS, JE+1 ), LDC )
                     CALL SAXPY( N-JE, RHS( 4 ), E( JSP1, JE+1 ), LDE,
     $                           F( IS, JE+1 ), LDF )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.2 ) .AND. ( NB.EQ.1 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 4-by-4 system Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = A( ISP1, IS )
                  Z( 3, 1 ) = D( IS, IS )
                  Z( 4, 1 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = A( IS, ISP1 )
                  Z( 2, 2 ) = A( ISP1, ISP1 )
                  Z( 3, 2 ) = D( IS, ISP1 )
                  Z( 4, 2 ) = D( ISP1, ISP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 3 ) = -B( JS, JS )
                  Z( 2, 3 ) = ZERO
                  Z( 3, 3 ) = -E( JS, JS )
                  Z( 4, 3 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 4 ) = ZERO
                  Z( 2, 4 ) = -B( JS, JS )
                  Z( 3, 4 ) = ZERO
                  Z( 4, 4 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = C( ISP1, JS )
                  RHS( 3 ) = F( IS, JS )
                  RHS( 4 ) = F( ISP1, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.477"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
                  IF( IJOB.EQ.0 ) THEN
                     CALL <a name="SGESC2.481"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV,
     $                            SCALOC )
                     IF( SCALOC.NE.ONE ) THEN
                        DO 70 K = 1, N
                           CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                           CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
   70                   CONTINUE
                        SCALE = SCALE*SCALOC
                     END IF
                  ELSE
                     CALL <a name="SLATDF.491"></a><a href="slatdf.f.html#SLATDF.1">SLATDF</a>( IJOB, ZDIM, Z, LDZ, RHS, RDSUM,
     $                            RDSCAL, IPIV, JPIV )
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  C( ISP1, JS ) = RHS( 2 )
                  F( IS, JS ) = RHS( 3 )
                  F( ISP1, JS ) = RHS( 4 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( I.GT.1 ) THEN
                     CALL SGEMV( <span class="string">'N'</span>, IS-1, MB, -ONE, A( 1, IS ), LDA,
     $                           RHS( 1 ), 1, ONE, C( 1, JS ), 1 )
                     CALL SGEMV( <span class="string">'N'</span>, IS-1, MB, -ONE, D( 1, IS ), LDD,
     $                           RHS( 1 ), 1, ONE, F( 1, JS ), 1 )
                  END IF
                  IF( J.LT.Q ) THEN
                     CALL SGER( MB, N-JE, ONE, RHS( 3 ), 1,
     $                          B( JS, JE+1 ), LDB, C( IS, JE+1 ), LDC )
                     CALL SGER( MB, N-JE, ONE, RHS( 3 ), 1,
     $                          E( JS, JE+1 ), LDE, F( IS, JE+1 ), LDF )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.2 ) .AND. ( NB.EQ.2 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build an 8-by-8 system Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASET.522"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, LDZ, LDZ, ZERO, ZERO, Z, LDZ )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = A( ISP1, IS )
                  Z( 5, 1 ) = D( IS, IS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = A( IS, ISP1 )
                  Z( 2, 2 ) = A( ISP1, ISP1 )
                  Z( 5, 2 ) = D( IS, ISP1 )
                  Z( 6, 2 ) = D( ISP1, ISP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 3, 3 ) = A( IS, IS )
                  Z( 4, 3 ) = A( ISP1, IS )
                  Z( 7, 3 ) = D( IS, IS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 3, 4 ) = A( IS, ISP1 )
                  Z( 4, 4 ) = A( ISP1, ISP1 )
                  Z( 7, 4 ) = D( IS, ISP1 )
                  Z( 8, 4 ) = D( ISP1, ISP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 5 ) = -B( JS, JS )
                  Z( 3, 5 ) = -B( JS, JSP1 )
                  Z( 5, 5 ) = -E( JS, JS )
                  Z( 7, 5 ) = -E( JS, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 2, 6 ) = -B( JS, JS )
                  Z( 4, 6 ) = -B( JS, JSP1 )
                  Z( 6, 6 ) = -E( JS, JS )
                  Z( 8, 6 ) = -E( JS, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 7 ) = -B( JSP1, JS )
                  Z( 3, 7 ) = -B( JSP1, JSP1 )
                  Z( 7, 7 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 2, 8 ) = -B( JSP1, JS )
                  Z( 4, 8 ) = -B( JSP1, JSP1 )
                  Z( 8, 8 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  K = 1
                  II = MB*NB + 1
                  DO 80 JJ = 0, NB - 1
                     CALL SCOPY( MB, C( IS, JS+JJ ), 1, RHS( K ), 1 )
                     CALL SCOPY( MB, F( IS, JS+JJ ), 1, RHS( II ), 1 )
                     K = K + MB
                     II = II + MB
   80             CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.573"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
                  IF( IJOB.EQ.0 ) THEN
                     CALL <a name="SGESC2.577"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV,
     $                            SCALOC )
                     IF( SCALOC.NE.ONE ) THEN
                        DO 90 K = 1, N
                           CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                           CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
   90                   CONTINUE
                        SCALE = SCALE*SCALOC
                     END IF
                  ELSE
                     CALL <a name="SLATDF.587"></a><a href="slatdf.f.html#SLATDF.1">SLATDF</a>( IJOB, ZDIM, Z, LDZ, RHS, RDSUM,
     $                            RDSCAL, IPIV, JPIV )
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  K = 1
                  II = MB*NB + 1
                  DO 100 JJ = 0, NB - 1
                     CALL SCOPY( MB, RHS( K ), 1, C( IS, JS+JJ ), 1 )
                     CALL SCOPY( MB, RHS( II ), 1, F( IS, JS+JJ ), 1 )
                     K = K + MB
                     II = II + MB
  100             CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( I.GT.1 ) THEN
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, IS-1, NB, MB, -ONE,
     $                           A( 1, IS ), LDA, RHS( 1 ), MB, ONE,
     $                           C( 1, JS ), LDC )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, IS-1, NB, MB, -ONE,
     $                           D( 1, IS ), LDD, RHS( 1 ), MB, ONE,
     $                           F( 1, JS ), LDF )
                  END IF
                  IF( J.LT.Q ) THEN
                     K = MB*NB + 1
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, MB, N-JE, NB, ONE, RHS( K ),
     $                           MB, B( JS, JE+1 ), LDB, ONE,
     $                           C( IS, JE+1 ), LDC )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, MB, N-JE, NB, ONE, RHS( K ),
     $                           MB, E( JS, JE+1 ), LDE, ONE,
     $                           F( IS, JE+1 ), LDF )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>  110       CONTINUE
  120    CONTINUE
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve (I, J) - subsystem
</span><span class="comment">*</span><span class="comment">             A(I, I)' * R(I, J) + D(I, I)' * L(J, J)  =  C(I, J)
</span><span class="comment">*</span><span class="comment">             R(I, I)  * B(J, J) + L(I, J)  * E(J, J)  = -F(I, J)
</span><span class="comment">*</span><span class="comment">        for I = 1, 2, ..., P, J = Q, Q - 1, ..., 1
</span><span class="comment">*</span><span class="comment">
</span>         SCALE = ONE
         SCALOC = ONE
         DO 200 I = 1, P
<span class="comment">*</span><span class="comment">
</span>            IS = IWORK( I )
            ISP1 = IS + 1
            IE = IWORK( I+1 ) - 1
            MB = IE - IS + 1
            DO 190 J = Q, P + 2, -1
<span class="comment">*</span><span class="comment">
</span>               JS = IWORK( J )
               JSP1 = JS + 1
               JE = IWORK( J+1 ) - 1
               NB = JE - JS + 1
               ZDIM = MB*NB*2
               IF( ( MB.EQ.1 ) .AND. ( NB.EQ.1 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 2-by-2 system Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = -B( JS, JS )
                  Z( 1, 2 ) = D( IS, IS )
                  Z( 2, 2 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = F( IS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.665"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGESC2.669"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV, SCALOC )
                  IF( SCALOC.NE.ONE ) THEN
                     DO 130 K = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                        CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
  130                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  F( IS, JS ) = RHS( 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( J.GT.P+2 ) THEN
                     ALPHA = RHS( 1 )
                     CALL SAXPY( JS-1, ALPHA, B( 1, JS ), 1, F( IS, 1 ),
     $                           LDF )
                     ALPHA = RHS( 2 )
                     CALL SAXPY( JS-1, ALPHA, E( 1, JS ), 1, F( IS, 1 ),
     $                           LDF )
                  END IF
                  IF( I.LT.P ) THEN
                     ALPHA = -RHS( 1 )
                     CALL SAXPY( M-IE, ALPHA, A( IS, IE+1 ), LDA,
     $                           C( IE+1, JS ), 1 )
                     ALPHA = -RHS( 2 )
                     CALL SAXPY( M-IE, ALPHA, D( IS, IE+1 ), LDD,
     $                           C( IE+1, JS ), 1 )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.1 ) .AND. ( NB.EQ.2 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 4-by-4 system Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = ZERO
                  Z( 3, 1 ) = -B( JS, JS )
                  Z( 4, 1 ) = -B( JSP1, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = ZERO
                  Z( 2, 2 ) = A( IS, IS )
                  Z( 3, 2 ) = -B( JS, JSP1 )
                  Z( 4, 2 ) = -B( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 3 ) = D( IS, IS )
                  Z( 2, 3 ) = ZERO
                  Z( 3, 3 ) = -E( JS, JS )
                  Z( 4, 3 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 4 ) = ZERO
                  Z( 2, 4 ) = D( IS, IS )
                  Z( 3, 4 ) = -E( JS, JSP1 )
                  Z( 4, 4 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = C( IS, JSP1 )
                  RHS( 3 ) = F( IS, JS )
                  RHS( 4 ) = F( IS, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.736"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
                  CALL <a name="SGESC2.739"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV, SCALOC )
                  IF( SCALOC.NE.ONE ) THEN
                     DO 140 K = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                        CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
  140                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  C( IS, JSP1 ) = RHS( 2 )
                  F( IS, JS ) = RHS( 3 )
                  F( IS, JSP1 ) = RHS( 4 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( J.GT.P+2 ) THEN
                     CALL SAXPY( JS-1, RHS( 1 ), B( 1, JS ), 1,
     $                           F( IS, 1 ), LDF )
                     CALL SAXPY( JS-1, RHS( 2 ), B( 1, JSP1 ), 1,
     $                           F( IS, 1 ), LDF )
                     CALL SAXPY( JS-1, RHS( 3 ), E( 1, JS ), 1,
     $                           F( IS, 1 ), LDF )
                     CALL SAXPY( JS-1, RHS( 4 ), E( 1, JSP1 ), 1,
     $                           F( IS, 1 ), LDF )
                  END IF
                  IF( I.LT.P ) THEN
                     CALL SGER( M-IE, NB, -ONE, A( IS, IE+1 ), LDA,
     $                          RHS( 1 ), 1, C( IE+1, JS ), LDC )
                     CALL SGER( M-IE, NB, -ONE, D( IS, IE+1 ), LDD,
     $                          RHS( 3 ), 1, C( IE+1, JS ), LDC )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.2 ) .AND. ( NB.EQ.1 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build a 4-by-4 system Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = A( IS, ISP1 )
                  Z( 3, 1 ) = -B( JS, JS )
                  Z( 4, 1 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = A( ISP1, IS )
                  Z( 2, 2 ) = A( ISP1, ISP1 )
                  Z( 3, 2 ) = ZERO
                  Z( 4, 2 ) = -B( JS, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 3 ) = D( IS, IS )
                  Z( 2, 3 ) = D( IS, ISP1 )
                  Z( 3, 3 ) = -E( JS, JS )
                  Z( 4, 3 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 4 ) = ZERO
                  Z( 2, 4 ) = D( ISP1, ISP1 )
                  Z( 3, 4 ) = ZERO
                  Z( 4, 4 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  RHS( 1 ) = C( IS, JS )
                  RHS( 2 ) = C( ISP1, JS )
                  RHS( 3 ) = F( IS, JS )
                  RHS( 4 ) = F( ISP1, JS )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.808"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGESC2.812"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV, SCALOC )
                  IF( SCALOC.NE.ONE ) THEN
                     DO 150 K = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                        CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
  150                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  C( IS, JS ) = RHS( 1 )
                  C( ISP1, JS ) = RHS( 2 )
                  F( IS, JS ) = RHS( 3 )
                  F( ISP1, JS ) = RHS( 4 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( J.GT.P+2 ) THEN
                     CALL SGER( MB, JS-1, ONE, RHS( 1 ), 1, B( 1, JS ),
     $                          1, F( IS, 1 ), LDF )
                     CALL SGER( MB, JS-1, ONE, RHS( 3 ), 1, E( 1, JS ),
     $                          1, F( IS, 1 ), LDF )
                  END IF
                  IF( I.LT.P ) THEN
                     CALL SGEMV( <span class="string">'T'</span>, MB, M-IE, -ONE, A( IS, IE+1 ),
     $                           LDA, RHS( 1 ), 1, ONE, C( IE+1, JS ),
     $                           1 )
                     CALL SGEMV( <span class="string">'T'</span>, MB, M-IE, -ONE, D( IS, IE+1 ),
     $                           LDD, RHS( 3 ), 1, ONE, C( IE+1, JS ),
     $                           1 )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( ( MB.EQ.2 ) .AND. ( NB.EQ.2 ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Build an 8-by-8 system Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLASET.850"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, LDZ, LDZ, ZERO, ZERO, Z, LDZ )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 1 ) = A( IS, IS )
                  Z( 2, 1 ) = A( IS, ISP1 )
                  Z( 5, 1 ) = -B( JS, JS )
                  Z( 7, 1 ) = -B( JSP1, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 2 ) = A( ISP1, IS )
                  Z( 2, 2 ) = A( ISP1, ISP1 )
                  Z( 6, 2 ) = -B( JS, JS )
                  Z( 8, 2 ) = -B( JSP1, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 3, 3 ) = A( IS, IS )
                  Z( 4, 3 ) = A( IS, ISP1 )
                  Z( 5, 3 ) = -B( JS, JSP1 )
                  Z( 7, 3 ) = -B( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 3, 4 ) = A( ISP1, IS )
                  Z( 4, 4 ) = A( ISP1, ISP1 )
                  Z( 6, 4 ) = -B( JS, JSP1 )
                  Z( 8, 4 ) = -B( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 1, 5 ) = D( IS, IS )
                  Z( 2, 5 ) = D( IS, ISP1 )
                  Z( 5, 5 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 2, 6 ) = D( ISP1, ISP1 )
                  Z( 6, 6 ) = -E( JS, JS )
<span class="comment">*</span><span class="comment">
</span>                  Z( 3, 7 ) = D( IS, IS )
                  Z( 4, 7 ) = D( IS, ISP1 )
                  Z( 5, 7 ) = -E( JS, JSP1 )
                  Z( 7, 7 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span>                  Z( 4, 8 ) = D( ISP1, ISP1 )
                  Z( 6, 8 ) = -E( JS, JSP1 )
                  Z( 8, 8 ) = -E( JSP1, JSP1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Set up right hand side(s)
</span><span class="comment">*</span><span class="comment">
</span>                  K = 1
                  II = MB*NB + 1
                  DO 160 JJ = 0, NB - 1
                     CALL SCOPY( MB, C( IS, JS+JJ ), 1, RHS( K ), 1 )
                     CALL SCOPY( MB, F( IS, JS+JJ ), 1, RHS( II ), 1 )
                     K = K + MB
                     II = II + MB
  160             CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve Z' * x = RHS
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGETC2.902"></a><a href="sgetc2.f.html#SGETC2.1">SGETC2</a>( ZDIM, Z, LDZ, IPIV, JPIV, IERR )
                  IF( IERR.GT.0 )
     $               INFO = IERR
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGESC2.906"></a><a href="sgesc2.f.html#SGESC2.1">SGESC2</a>( ZDIM, Z, LDZ, RHS, IPIV, JPIV, SCALOC )
                  IF( SCALOC.NE.ONE ) THEN
                     DO 170 K = 1, N
                        CALL SSCAL( M, SCALOC, C( 1, K ), 1 )
                        CALL SSCAL( M, SCALOC, F( 1, K ), 1 )
  170                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Unpack solution vector(s)
</span><span class="comment">*</span><span class="comment">
</span>                  K = 1
                  II = MB*NB + 1
                  DO 180 JJ = 0, NB - 1
                     CALL SCOPY( MB, RHS( K ), 1, C( IS, JS+JJ ), 1 )
                     CALL SCOPY( MB, RHS( II ), 1, F( IS, JS+JJ ), 1 )
                     K = K + MB
                     II = II + MB
  180             CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I, J) and L(I, J) into remaining
</span><span class="comment">*</span><span class="comment">                 equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( J.GT.P+2 ) THEN
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'T'</span>, MB, JS-1, NB, ONE,
     $                           C( IS, JS ), LDC, B( 1, JS ), LDB, ONE,
     $                           F( IS, 1 ), LDF )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'T'</span>, MB, JS-1, NB, ONE,
     $                           F( IS, JS ), LDF, E( 1, JS ), LDE, ONE,
     $                           F( IS, 1 ), LDF )
                  END IF
                  IF( I.LT.P ) THEN
                     CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, M-IE, NB, MB, -ONE,
     $                           A( IS, IE+1 ), LDA, C( IS, JS ), LDC,
     $                           ONE, C( IE+1, JS ), LDC )
                     CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, M-IE, NB, MB, -ONE,
     $                           D( IS, IE+1 ), LDD, F( IS, JS ), LDF,
     $                           ONE, C( IE+1, JS ), LDC )
                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>  190       CONTINUE
  200    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      END IF
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="STGSY2.954"></a><a href="stgsy2.f.html#STGSY2.1">STGSY2</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
