<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dgesvd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DGESVD.1"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a>( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
     $                   WORK, LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBU, JOBVT
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),
     $                   VT( LDVT, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DGESVD.20"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a> computes the singular value decomposition (SVD) of a real
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and/or right singular
</span><span class="comment">*</span><span class="comment">  vectors. The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns V**T, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBU    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U are returned in array U:
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array U;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U (no left singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVT   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix
</span><span class="comment">*</span><span class="comment">          V**T:
</span><span class="comment">*</span><span class="comment">          = 'A':  all N rows of V**T are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) rows of V**T (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) rows of V**T (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no rows of V**T (no right singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          JOBVT and JOBU cannot both be 'O'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBU = 'O',  A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          columns of U (the left singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'O', A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          rows of V**T (the right singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
</span><span class="comment">*</span><span class="comment">                          are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBU = 'S', U contains the first min(m,n) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBU = 'N' or 'O', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBU = 'S' or 'A', LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
</span><span class="comment">*</span><span class="comment">          V**T;
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'S', VT contains the first min(m,n) rows of
</span><span class="comment">*</span><span class="comment">          V**T (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'N' or 'O', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
</span><span class="comment">*</span><span class="comment">          if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged
</span><span class="comment">*</span><span class="comment">          superdiagonal elements of an upper bidiagonal matrix B
</span><span class="comment">*</span><span class="comment">          whose diagonal is in S (not necessarily sorted). B
</span><span class="comment">*</span><span class="comment">          satisfies A = U * B * VT, so it has the same singular values
</span><span class="comment">*</span><span class="comment">          as A, and singular vectors related by U and VT.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.123"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  if <a name="DBDSQR.128"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a> did not converge, INFO specifies how many
</span><span class="comment">*</span><span class="comment">                superdiagonals of an intermediate bidiagonal form B
</span><span class="comment">*</span><span class="comment">                did not converge to zero. See the description of WORK
</span><span class="comment">*</span><span class="comment">                above for details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, WNTUA, WNTUAS, WNTUN, WNTUO, WNTUS,
     $                   WNTVA, WNTVAS, WNTVN, WNTVO, WNTVS
      INTEGER            BDSPAC, BLK, CHUNK, I, IE, IERR, IR, ISCL,
     $                   ITAU, ITAUP, ITAUQ, IU, IWORK, LDWRKR, LDWRKU,
     $                   MAXWRK, MINMN, MINWRK, MNTHR, NCU, NCVT, NRU,
     $                   NRVT, WRKBL
      DOUBLE PRECISION   ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DBDSQR.152"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>, <a name="DGEBRD.152"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>, <a name="DGELQF.152"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>, DGEMM, <a name="DGEQRF.152"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>, <a name="DLACPY.152"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>,
     $                   <a name="DLASCL.153"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="DLASET.153"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>, <a name="DORGBR.153"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>, <a name="DORGLQ.153"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>, <a name="DORGQR.153"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>, <a name="DORMBR.153"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>,
     $                   <a name="XERBLA.154"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.157"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.158"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.159"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.159"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
      EXTERNAL           <a name="LSAME.160"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.160"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="DLAMCH.160"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.160"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      WNTUA = <a name="LSAME.171"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'A'</span> )
      WNTUS = <a name="LSAME.172"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'S'</span> )
      WNTUAS = WNTUA .OR. WNTUS
      WNTUO = <a name="LSAME.174"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'O'</span> )
      WNTUN = <a name="LSAME.175"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'N'</span> )
      WNTVA = <a name="LSAME.176"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'A'</span> )
      WNTVS = <a name="LSAME.177"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'S'</span> )
      WNTVAS = WNTVA .OR. WNTVS
      WNTVO = <a name="LSAME.179"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'O'</span> )
      WNTVN = <a name="LSAME.180"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTUA .OR. WNTUS .OR. WNTUO .OR. WNTUN ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( WNTVA .OR. WNTVS .OR. WNTVO .OR. WNTVN ) .OR.
     $         ( WNTVO .AND. WNTUO ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LDU.LT.1 .OR. ( WNTUAS .AND. LDU.LT.M ) ) THEN
         INFO = -9
      ELSE IF( LDVT.LT.1 .OR. ( WNTVA .AND. LDVT.LT.N ) .OR.
     $         ( WNTVS .AND. LDVT.LT.MINMN ) ) THEN
         INFO = -11
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.206"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="DBDSQR.213"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.215"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="DGESVD.215"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*N
            IF( M.GE.MNTHR ) THEN
               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = N + N*<a name="ILAENV.222"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.222"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*N+2*N*
     $                     <a name="ILAENV.225"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.225"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  IF( WNTVO .OR. WNTVAS )
     $               MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                        <a name="ILAENV.228"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.228"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*N, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.235"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.235"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.236"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.236"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.239"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.239"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.241"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.250"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.250"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.251"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.251"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.254"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.254"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.256"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.258"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.258"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.266"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.266"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.267"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.267"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.270"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.270"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.272"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.272"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.280"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.280"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.281"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.281"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.284"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.284"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.286"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.286"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.288"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.288"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.297"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.297"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.298"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.298"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.301"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.301"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.303"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.303"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.305"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.305"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.313"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.313"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.314"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.314"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.317"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.317"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.319"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.319"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.327"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.327"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.328"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.328"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.331"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.331"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.333"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.333"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.335"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.335"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.344"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.344"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.345"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.345"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.348"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.348"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.350"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.350"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.352"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.352"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 3*N + ( M+N )*<a name="ILAENV.361"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.361"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTUS .OR. WNTUO )
     $            MAXWRK = MAX( MAXWRK, 3*N+N*
     $                     <a name="ILAENV.365"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.365"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, N, N, -1 ) )
               IF( WNTUA )
     $            MAXWRK = MAX( MAXWRK, 3*N+M*
     $                     <a name="ILAENV.368"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.368"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               IF( .NOT.WNTVN )
     $            MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                     <a name="ILAENV.371"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.371"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*N+M, BDSPAC )
            END IF
         ELSE IF( MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="DBDSQR.377"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.379"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="DGESVD.379"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*M
            IF( N.GE.MNTHR ) THEN
               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.386"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.386"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*M+2*M*
     $                     <a name="ILAENV.389"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.389"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  IF( WNTUO .OR. WNTUAS )
     $               MAXWRK = MAX( MAXWRK, 3*M+M*
     $                        <a name="ILAENV.392"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.392"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*M, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.399"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.399"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.400"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.400"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.403"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.403"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.405"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.405"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.414"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.415"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.415"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.418"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.418"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.420"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.420"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.422"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.422"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.430"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.430"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.431"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.431"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.434"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.434"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.436"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.436"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.444"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.444"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.445"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.445"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.448"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.448"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.450"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.450"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.452"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.452"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.461"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.461"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.462"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.462"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.465"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.465"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.467"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.467"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.469"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.469"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.477"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.477"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.478"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.478"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.481"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.481"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.483"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.483"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.491"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.491"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.492"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.492"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.495"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.495"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.497"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.497"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.499"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.499"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.508"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.508"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.509"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.509"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.512"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.512"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.514"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.514"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.516"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.516"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 3*M + ( M+N )*<a name="ILAENV.525"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.525"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTVS .OR. WNTVO )
     $            MAXWRK = MAX( MAXWRK, 3*M+M*
     $                     <a name="ILAENV.529"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.529"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, M, N, M, -1 ) )
               IF( WNTVA )
     $            MAXWRK = MAX( MAXWRK, 3*M+N*
     $                     <a name="ILAENV.532"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.532"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'P'</span>, N, N, M, -1 ) )
               IF( .NOT.WNTUN )
     $            MAXWRK = MAX( MAXWRK, 3*M+( M-1 )*
     $                     <a name="ILAENV.535"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGBR.535"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*M+N, BDSPAC )
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -13
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.549"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DGESVD.549"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.563"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="DLAMCH.564"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="DLANGE.569"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="DLASCL.573"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="DLASCL.576"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">              No left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEQRF.598"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.603"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = 1
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.612"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               NCVT = 0
               IF( WNTVO .OR. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If right singular vectors desired, generate P'.
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.621"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  NCVT = N
               END IF
               IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.631"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, NCVT, 0, 0, S, WORK( IE ), A, LDA,
     $                      DUM, 1, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTVAS )
     $            CALL <a name="DLACPY.637"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, N, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEQRF.675"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to WORK(IR) and zero out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.680"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="DLASET.681"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                         LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGQR.687"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.697"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.704"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.713"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM, 1,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 10 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="DLACPY.727"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   10             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.743"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N, prefer 3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.750"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.758"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM, 1,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEQRF.799"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.804"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="DLASET.806"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGQR.812"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.822"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="DLACPY.825"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, N, N, VT, LDVT, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.830"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N-1, prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.837"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR) and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.846"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT, LDVT,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 20 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="DLACPY.860"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEQRF.874"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.879"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="DLASET.881"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGQR.887"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.897"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORMBR.904"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                         WORK( ITAUQ ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.911"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.920"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT, LDVT,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.955"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.960"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="DLASET.962"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.968"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.978"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.986"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.995"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IR ), LDWRKR, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1016"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1018"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1023"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.1032"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1038"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1045"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1054"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1099"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1104"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.1106"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1112"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1124"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1128"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1134"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1142"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1152"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R to A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1166"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1179"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1181"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1186"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.1195"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1201"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1208"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1215"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1224"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1259"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1264"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.1266"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1272"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1282"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1286"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1292"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1300"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1309"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1330"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1332"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1337"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1342"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="DLASET.1344"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1354"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1362"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1369"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1378"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1416"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1418"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1422"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="DLASET.1424"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1430"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1440"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1448"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1457"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IR ), LDWRKR, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1470"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1482"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1484"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1489"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.1498"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1504"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1512"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1521"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1566"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1568"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1573"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1578"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.1580"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1592"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1596"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1602"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1610"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1620"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1633"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1637"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1650"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1652"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1657"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.1666"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1672"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1680"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1687"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1696"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1731"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1733"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1738"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1743"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.1745"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1755"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1759"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1765"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1773"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1782"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1795"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEQRF.1807"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.1809"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGQR.1814"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R from A to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.1819"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="DLASET.1821"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.1831"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.1839"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.1846"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.1855"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + N
            ITAUP = ITAUQ + N
            IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DGEBRD.1880"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*N+NCU, prefer 3*N+NCU*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.1889"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
               IF( WNTUS )
     $            NCU = N
               IF( WNTUA )
     $            NCU = M
               CALL <a name="DORGBR.1894"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, NCU, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.1903"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="DORGBR.1904"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGBR.1913"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGBR.1922"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + N
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.1941"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.1950"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.1959"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">              No right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGELQF.1984"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.1989"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = 1
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.1998"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               IF( WNTUO .OR. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If left singular vectors desired, generate Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2006"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
               END IF
               IWORK = IE + M
               NRU = 0
               IF( WNTUO .OR. WNTUAS )
     $            NRU = M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing left singular
</span><span class="comment">*</span><span class="comment">              vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.2018"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, 0, NRU, 0, S, WORK( IE ), DUM, 1, A,
     $                      LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTUAS )
     $            CALL <a name="DLACPY.2024"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, M, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGELQF.2065"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to WORK(IR) and zero out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.2070"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="DLASET.2071"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                         WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGLQ.2077"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.2087"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2094"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.2103"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M*N+M)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 30 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="DLACPY.2117"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   30             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.2133"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2140"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.2148"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'L'</span>, M, N, 0, 0, S, WORK( IE ), A, LDA,
     $                         DUM, 1, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGELQF.2192"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.2197"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="DLASET.2198"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGLQ.2204"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.2214"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="DLACPY.2217"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, M, U, LDU, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2222"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2229"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in U, and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.2238"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, U, LDU, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M*N+M))
</span><span class="comment">*</span><span class="comment">
</span>                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="DLACPY.2252"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   40             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGELQF.2266"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.2271"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="DLASET.2272"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGLQ.2278"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DGEBRD.2288"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right vectors bidiagonalizing L by Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORMBR.2295"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                         WORK( ITAUP ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.2302"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DBDSQR.2311"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), A, LDA,
     $                         U, LDU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2346"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2351"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="DLASET.2353"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2359"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2369"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing L in
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2378"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2387"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2408"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy result to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2413"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2418"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.2427"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2433"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.2440"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2449"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2494"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2499"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.2501"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2507"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2519"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2523"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2530"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2537"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2547"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of L to A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2561"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2574"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2576"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2581"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.2590"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2596"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.2603"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors of L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2610"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, compute left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and compute right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2619"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2654"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2659"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.2661"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2667"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2677"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2681"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2688"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2695"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2704"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2725"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2727"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2732"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2737"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="DLASET.2738"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2748"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.2756"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2763"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2772"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2810"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2812"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2816"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="DLASET.2818"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2824"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2834"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2843"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2852"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2865"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2877"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2879"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2884"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.2893"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2899"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.2907"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.2916"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.2961"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2963"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.2968"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.2973"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.2975"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.2987"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.2991"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.2998"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.3005"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.3015"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.3028"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.3032"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.3045"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.3047"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.3052"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLASET.3061"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.3067"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.3075"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.3082"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.3091"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.3126"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.3128"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.3133"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.3138"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="DLASET.3140"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.3150"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.3154"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.3160"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.3167"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.3176"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.3189"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGELQF.3201"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="DLACPY.3203"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGLQ.3208"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DLACPY.3213"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="DLASET.3214"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DGEBRD.3224"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORMBR.3232"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DORGBR.3239"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="DBDSQR.3248"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + M
            ITAUP = ITAUQ + M
            IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DGEBRD.3273"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.3282"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="DORGBR.3283"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*M+NRVT, prefer 3*M+NRVT*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.3292"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
               IF( WNTVA )
     $            NRVT = N
               IF( WNTVS )
     $            NRVT = M
               CALL <a name="DORGBR.3297"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, NRVT, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGBR.3306"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, M, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGBR.3315"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + M
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.3334"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.3343"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSQR.3352"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If <a name="DBDSQR.3360"></a><a href="dbdsqr.f.html#DBDSQR.1">DBDSQR</a> failed to converge, copy unconverged superdiagonals
</span><span class="comment">*</span><span class="comment">     to WORK( 2:MINMN )
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         IF( IE.GT.2 ) THEN
            DO 50 I = 1, MINMN - 1
               WORK( I+1 ) = WORK( I+IE-1 )
   50       CONTINUE
         END IF
         IF( IE.LT.2 ) THEN
            DO 60 I = MINMN - 1, 1, -1
               WORK( I+1 ) = WORK( I+IE-1 )
   60       CONTINUE
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.3380"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.3383"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.3386"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.3389"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DGESVD.3399"></a><a href="dgesvd.f.html#DGESVD.1">DGESVD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
