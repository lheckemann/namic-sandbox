<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>ztgsen.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="ZTGSEN.1"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a>( IJOB, WANTQ, WANTZ, SELECT, N, A, LDA, B, LDB,
     $                   ALPHA, BETA, Q, LDQ, Z, LDZ, M, PL, PR, DIF,
     $                   WORK, LWORK, IWORK, LIWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     January 2007
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Modified to call <a name="ZLACN2.9"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a> in place of <a name="ZLACON.9"></a><a href="zlacon.f.html#ZLACON.1">ZLACON</a>, 10 Feb 03, SJH.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      LOGICAL            WANTQ, WANTZ
      INTEGER            IJOB, INFO, LDA, LDB, LDQ, LDZ, LIWORK, LWORK,
     $                   M, N
      DOUBLE PRECISION   PL, PR
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      LOGICAL            SELECT( * )
      INTEGER            IWORK( * )
      DOUBLE PRECISION   DIF( * )
      COMPLEX*16         A( LDA, * ), ALPHA( * ), B( LDB, * ),
     $                   BETA( * ), Q( LDQ, * ), WORK( * ), Z( LDZ, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZTGSEN.28"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a> reorders the generalized Schur decomposition of a complex
</span><span class="comment">*</span><span class="comment">  matrix pair (A, B) (in terms of an unitary equivalence trans-
</span><span class="comment">*</span><span class="comment">  formation Q' * (A, B) * Z), so that a selected cluster of eigenvalues
</span><span class="comment">*</span><span class="comment">  appears in the leading diagonal blocks of the pair (A,B). The leading
</span><span class="comment">*</span><span class="comment">  columns of Q and Z form unitary bases of the corresponding left and
</span><span class="comment">*</span><span class="comment">  right eigenspaces (deflating subspaces). (A, B) must be in
</span><span class="comment">*</span><span class="comment">  generalized Schur canonical form, that is, A and B are both upper
</span><span class="comment">*</span><span class="comment">  triangular.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZTGSEN.37"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a> also computes the generalized eigenvalues
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           w(j)= ALPHA(j) / BETA(j)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  of the reordered matrix pair (A, B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally, the routine computes estimates of reciprocal condition
</span><span class="comment">*</span><span class="comment">  numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
</span><span class="comment">*</span><span class="comment">  (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
</span><span class="comment">*</span><span class="comment">  between the matrix pairs (A11, B11) and (A22,B22) that correspond to
</span><span class="comment">*</span><span class="comment">  the selected cluster and the eigenvalues outside the cluster, resp.,
</span><span class="comment">*</span><span class="comment">  and norms of &quot;projections&quot; onto left and right eigenspaces w.r.t.
</span><span class="comment">*</span><span class="comment">  the selected cluster in the (1,1)-block.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IJOB    (input) integer
</span><span class="comment">*</span><span class="comment">          Specifies whether condition numbers are required for the
</span><span class="comment">*</span><span class="comment">          cluster of eigenvalues (PL and PR) or the deflating subspaces
</span><span class="comment">*</span><span class="comment">          (Difu and Difl):
</span><span class="comment">*</span><span class="comment">           =0: Only reorder w.r.t. SELECT. No extras.
</span><span class="comment">*</span><span class="comment">           =1: Reciprocal of norms of &quot;projections&quot; onto left and right
</span><span class="comment">*</span><span class="comment">               eigenspaces w.r.t. the selected cluster (PL and PR).
</span><span class="comment">*</span><span class="comment">           =2: Upper bounds on Difu and Difl. F-norm-based estimate
</span><span class="comment">*</span><span class="comment">               (DIF(1:2)).
</span><span class="comment">*</span><span class="comment">           =3: Estimate of Difu and Difl. 1-norm-based estimate
</span><span class="comment">*</span><span class="comment">               (DIF(1:2)).
</span><span class="comment">*</span><span class="comment">               About 5 times as expensive as IJOB = 2.
</span><span class="comment">*</span><span class="comment">           =4: Compute PL, PR and DIF (i.e. 0, 1 and 2 above): Economic
</span><span class="comment">*</span><span class="comment">               version to get it all.
</span><span class="comment">*</span><span class="comment">           =5: Compute PL, PR and DIF (i.e. 0, 1 and 3 above)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WANTQ   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          .TRUE. : update the left transformation matrix Q;
</span><span class="comment">*</span><span class="comment">          .FALSE.: do not update Q.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WANTZ   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          .TRUE. : update the right transformation matrix Z;
</span><span class="comment">*</span><span class="comment">          .FALSE.: do not update Z.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SELECT  (input) LOGICAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          SELECT specifies the eigenvalues in the selected cluster. To
</span><span class="comment">*</span><span class="comment">          select an eigenvalue w(j), SELECT(j) must be set to
</span><span class="comment">*</span><span class="comment">          .TRUE..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices A and B. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX*16 array, dimension(LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the upper triangular matrix A, in generalized
</span><span class="comment">*</span><span class="comment">          Schur canonical form.
</span><span class="comment">*</span><span class="comment">          On exit, A is overwritten by the reordered matrix A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) COMPLEX*16 array, dimension(LDB,N)
</span><span class="comment">*</span><span class="comment">          On entry, the upper triangular matrix B, in generalized
</span><span class="comment">*</span><span class="comment">          Schur canonical form.
</span><span class="comment">*</span><span class="comment">          On exit, B is overwritten by the reordered matrix B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHA   (output) COMPLEX*16 array, dimension (N)
</span><span class="comment">*</span><span class="comment">  BETA    (output) COMPLEX*16 array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The diagonal elements of A and B, respectively,
</span><span class="comment">*</span><span class="comment">          when the pair (A,B) has been reduced to generalized Schur
</span><span class="comment">*</span><span class="comment">          form.  ALPHA(i)/BETA(i) i=1,...,N are the generalized
</span><span class="comment">*</span><span class="comment">          eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Q       (input/output) COMPLEX*16 array, dimension (LDQ,N)
</span><span class="comment">*</span><span class="comment">          On entry, if WANTQ = .TRUE., Q is an N-by-N matrix.
</span><span class="comment">*</span><span class="comment">          On exit, Q has been postmultiplied by the left unitary
</span><span class="comment">*</span><span class="comment">          transformation matrix which reorder (A, B); The leading M
</span><span class="comment">*</span><span class="comment">          columns of Q form orthonormal bases for the specified pair of
</span><span class="comment">*</span><span class="comment">          left eigenspaces (deflating subspaces).
</span><span class="comment">*</span><span class="comment">          If WANTQ = .FALSE., Q is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDQ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array Q. LDQ &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If WANTQ = .TRUE., LDQ &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Z       (input/output) COMPLEX*16 array, dimension (LDZ,N)
</span><span class="comment">*</span><span class="comment">          On entry, if WANTZ = .TRUE., Z is an N-by-N matrix.
</span><span class="comment">*</span><span class="comment">          On exit, Z has been postmultiplied by the left unitary
</span><span class="comment">*</span><span class="comment">          transformation matrix which reorder (A, B); The leading M
</span><span class="comment">*</span><span class="comment">          columns of Z form orthonormal bases for the specified pair of
</span><span class="comment">*</span><span class="comment">          left eigenspaces (deflating subspaces).
</span><span class="comment">*</span><span class="comment">          If WANTZ = .FALSE., Z is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDZ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array Z. LDZ &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If WANTZ = .TRUE., LDZ &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the specified pair of left and right
</span><span class="comment">*</span><span class="comment">          eigenspaces, (deflating subspaces) 0 &lt;= M &lt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  PL      (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">  PR      (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          If IJOB = 1, 4 or 5, PL, PR are lower bounds on the
</span><span class="comment">*</span><span class="comment">          reciprocal  of the norm of &quot;projections&quot; onto left and right
</span><span class="comment">*</span><span class="comment">          eigenspace with respect to the selected cluster.
</span><span class="comment">*</span><span class="comment">          0 &lt; PL, PR &lt;= 1.
</span><span class="comment">*</span><span class="comment">          If M = 0 or M = N, PL = PR  = 1.
</span><span class="comment">*</span><span class="comment">          If IJOB = 0, 2 or 3 PL, PR are not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  DIF     (output) DOUBLE PRECISION array, dimension (2).
</span><span class="comment">*</span><span class="comment">          If IJOB &gt;= 2, DIF(1:2) store the estimates of Difu and Difl.
</span><span class="comment">*</span><span class="comment">          If IJOB = 2 or 4, DIF(1:2) are F-norm-based upper bounds on
</span><span class="comment">*</span><span class="comment">          Difu and Difl. If IJOB = 3 or 5, DIF(1:2) are 1-norm-based
</span><span class="comment">*</span><span class="comment">          estimates of Difu and Difl, computed using reversed
</span><span class="comment">*</span><span class="comment">          communication with <a name="ZLACN2.152"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a>.
</span><span class="comment">*</span><span class="comment">          If M = 0 or N, DIF(1:2) = F-norm([A, B]).
</span><span class="comment">*</span><span class="comment">          If IJOB = 0 or 1, DIF is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          IF IJOB = 0, WORK is not referenced.  Otherwise,
</span><span class="comment">*</span><span class="comment">          on exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;=  1
</span><span class="comment">*</span><span class="comment">          If IJOB = 1, 2 or 4, LWORK &gt;=  2*M*(N-M)
</span><span class="comment">*</span><span class="comment">          If IJOB = 3 or 5, LWORK &gt;=  4*M*(N-M)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.168"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
</span><span class="comment">*</span><span class="comment">          IF IJOB = 0, IWORK is not referenced.  Otherwise,
</span><span class="comment">*</span><span class="comment">          on exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LIWORK  (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array IWORK. LIWORK &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If IJOB = 1, 2 or 4, LIWORK &gt;=  N+2;
</span><span class="comment">*</span><span class="comment">          If IJOB = 3 or 5, LIWORK &gt;= MAX(N+2, 2*M*(N-M));
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LIWORK = -1, then a workspace query is assumed; the
</span><span class="comment">*</span><span class="comment">          routine only calculates the optimal size of the IWORK array,
</span><span class="comment">*</span><span class="comment">          returns this value as the first entry of the IWORK array, and
</span><span class="comment">*</span><span class="comment">          no error message related to LIWORK is issued by <a name="XERBLA.182"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">            =0: Successful exit.
</span><span class="comment">*</span><span class="comment">            &lt;0: If INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">            =1: Reordering of (A, B) failed because the transformed
</span><span class="comment">*</span><span class="comment">                matrix pair (A, B) would be too far from generalized
</span><span class="comment">*</span><span class="comment">                Schur form; the problem is very ill-conditioned.
</span><span class="comment">*</span><span class="comment">                (A, B) may have been partially reordered.
</span><span class="comment">*</span><span class="comment">                If requested, 0 is returned in DIF(*), PL and PR.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZTGSEN.197"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a> first collects the selected eigenvalues by computing unitary
</span><span class="comment">*</span><span class="comment">  U and W that move them to the top left corner of (A, B). In other
</span><span class="comment">*</span><span class="comment">  words, the selected eigenvalues are the eigenvalues of (A11, B11) in
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                U'*(A, B)*W = (A11 A12) (B11 B12) n1
</span><span class="comment">*</span><span class="comment">                              ( 0  A22),( 0  B22) n2
</span><span class="comment">*</span><span class="comment">                                n1  n2    n1  n2
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where N = n1+n2 and U' means the conjugate transpose of U. The first
</span><span class="comment">*</span><span class="comment">  n1 columns of U and W span the specified pair of left and right
</span><span class="comment">*</span><span class="comment">  eigenspaces (deflating subspaces) of (A, B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If (A, B) has been obtained from the generalized real Schur
</span><span class="comment">*</span><span class="comment">  decomposition of a matrix pair (C, D) = Q*(A, B)*Z', then the
</span><span class="comment">*</span><span class="comment">  reordered generalized Schur form of (C, D) is given by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           (C, D) = (Q*U)*(U'*(A, B)*W)*(Z*W)',
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  and the first n1 columns of Q*U and Z*W span the corresponding
</span><span class="comment">*</span><span class="comment">  deflating subspaces of (C, D) (Q and Z store Q*U and Z*W, resp.).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that if the selected eigenvalue is sufficiently ill-conditioned,
</span><span class="comment">*</span><span class="comment">  then its value may differ significantly from its value before
</span><span class="comment">*</span><span class="comment">  reordering.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The reciprocal condition numbers of the left and right eigenspaces
</span><span class="comment">*</span><span class="comment">  spanned by the first n1 columns of U and W (or Q*U and Z*W) may
</span><span class="comment">*</span><span class="comment">  be returned in DIF(1:2), corresponding to Difu and Difl, resp.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The Difu and Difl are defined as:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       Difu[(A11, B11), (A22, B22)] = sigma-min( Zu )
</span><span class="comment">*</span><span class="comment">  and
</span><span class="comment">*</span><span class="comment">       Difl[(A11, B11), (A22, B22)] = Difu[(A22, B22), (A11, B11)],
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where sigma-min(Zu) is the smallest singular value of the
</span><span class="comment">*</span><span class="comment">  (2*n1*n2)-by-(2*n1*n2) matrix
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       Zu = [ kron(In2, A11)  -kron(A22', In1) ]
</span><span class="comment">*</span><span class="comment">            [ kron(In2, B11)  -kron(B22', In1) ].
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Here, Inx is the identity matrix of size nx and A22' is the
</span><span class="comment">*</span><span class="comment">  transpose of A22. kron(X, Y) is the Kronecker product between
</span><span class="comment">*</span><span class="comment">  the matrices X and Y.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  When DIF(2) is small, small changes in (A, B) can cause large changes
</span><span class="comment">*</span><span class="comment">  in the deflating subspace. An approximate (asymptotic) bound on the
</span><span class="comment">*</span><span class="comment">  maximum angular error in the computed deflating subspaces is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       EPS * norm((A, B)) / DIF(2),
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where EPS is the machine precision.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The reciprocal norm of the projectors on the left and right
</span><span class="comment">*</span><span class="comment">  eigenspaces associated with (A11, B11) may be returned in PL and PR.
</span><span class="comment">*</span><span class="comment">  They are computed as follows. First we compute L and R so that
</span><span class="comment">*</span><span class="comment">  P*(A, B)*Q is block diagonal, where
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       P = ( I -L ) n1           Q = ( I R ) n1
</span><span class="comment">*</span><span class="comment">           ( 0  I ) n2    and        ( 0 I ) n2
</span><span class="comment">*</span><span class="comment">             n1 n2                    n1 n2
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  and (L, R) is the solution to the generalized Sylvester equation
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A11*R - L*A22 = -A12
</span><span class="comment">*</span><span class="comment">       B11*R - L*B22 = -B12
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Then PL = (F-norm(L)**2+1)**(-1/2) and PR = (F-norm(R)**2+1)**(-1/2).
</span><span class="comment">*</span><span class="comment">  An approximate (asymptotic) bound on the average absolute error of
</span><span class="comment">*</span><span class="comment">  the selected eigenvalues is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       EPS * norm((A, B)) / PL.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  There are also global error bounds which valid for perturbations up
</span><span class="comment">*</span><span class="comment">  to a certain restriction:  A lower bound (x) on the smallest
</span><span class="comment">*</span><span class="comment">  F-norm(E,F) for which an eigenvalue of (A11, B11) may move and
</span><span class="comment">*</span><span class="comment">  coalesce with an eigenvalue of (A22, B22) under perturbation (E,F),
</span><span class="comment">*</span><span class="comment">  (i.e. (A + E, B + F), is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">   x = min(Difu,Difl)/((1/(PL*PL)+1/(PR*PR))**(1/2)+2*max(1/PL,1/PR)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An approximate bound on x can be computed from DIF(1:2), PL and PR.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If y = ( F-norm(E,F) / x) &lt;= 1, the angles between the perturbed
</span><span class="comment">*</span><span class="comment">  (L', R') and unperturbed (L, R) left and right deflating subspaces
</span><span class="comment">*</span><span class="comment">  associated with the selected cluster in the (1,1)-blocks can be
</span><span class="comment">*</span><span class="comment">  bounded as
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">   max-angle(L, L') &lt;= arctan( y * PL / (1 - y * (1 - PL * PL)**(1/2))
</span><span class="comment">*</span><span class="comment">   max-angle(R, R') &lt;= arctan( y * PR / (1 - y * (1 - PR * PR)**(1/2))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  See LAPACK User's Guide section 4.11 or the following references
</span><span class="comment">*</span><span class="comment">  for more information.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that if the default method for computing the Frobenius-norm-
</span><span class="comment">*</span><span class="comment">  based estimate DIF is not wanted (see <a name="ZLATDF.292"></a><a href="zlatdf.f.html#ZLATDF.1">ZLATDF</a>), then the parameter
</span><span class="comment">*</span><span class="comment">  IDIFJB (see below) should be changed from 3 to 4 (routine <a name="ZLATDF.293"></a><a href="zlatdf.f.html#ZLATDF.1">ZLATDF</a>
</span><span class="comment">*</span><span class="comment">  (IJOB = 2 will be used)). See <a name="ZTGSYL.294"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a> for more details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
</span><span class="comment">*</span><span class="comment">     Umea University, S-901 87 Umea, Sweden.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  References
</span><span class="comment">*</span><span class="comment">  ==========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
</span><span class="comment">*</span><span class="comment">      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
</span><span class="comment">*</span><span class="comment">      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
</span><span class="comment">*</span><span class="comment">      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
</span><span class="comment">*</span><span class="comment">      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
</span><span class="comment">*</span><span class="comment">      Estimation: Theory, Algorithms and Software, Report
</span><span class="comment">*</span><span class="comment">      UMINF - 94.04, Department of Computing Science, Umea University,
</span><span class="comment">*</span><span class="comment">      S-901 87 Umea, Sweden, 1994. Also as LAPACK Working Note 87.
</span><span class="comment">*</span><span class="comment">      To appear in Numerical Algorithms, 1996.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
</span><span class="comment">*</span><span class="comment">      for Solving the Generalized Sylvester Equation and Estimating the
</span><span class="comment">*</span><span class="comment">      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
</span><span class="comment">*</span><span class="comment">      Department of Computing Science, Umea University, S-901 87 Umea,
</span><span class="comment">*</span><span class="comment">      Sweden, December 1993, Revised April 1994, Also as LAPACK working
</span><span class="comment">*</span><span class="comment">      Note 75. To appear in ACM Trans. on Math. Software, Vol 22, No 1,
</span><span class="comment">*</span><span class="comment">      1996.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      INTEGER            IDIFJB
      PARAMETER          ( IDIFJB = 3 )
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, SWAP, WANTD, WANTD1, WANTD2, WANTP
      INTEGER            I, IERR, IJB, K, KASE, KS, LIWMIN, LWMIN, MN2,
     $                   N1, N2
      DOUBLE PRECISION   DSCALE, DSUM, RDSCAL, SAFMIN
      COMPLEX*16         TEMP1, TEMP2
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      INTEGER            ISAVE( 3 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="XERBLA.342"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>, <a name="ZLACN2.342"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a>, <a name="ZLACPY.342"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>, <a name="ZLASSQ.342"></a><a href="zlassq.f.html#ZLASSQ.1">ZLASSQ</a>, ZSCAL, <a name="ZTGEXC.342"></a><a href="ztgexc.f.html#ZTGEXC.1">ZTGEXC</a>,
     $                   <a name="ZTGSYL.343"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, DCMPLX, DCONJG, MAX, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      DOUBLE PRECISION   <a name="DLAMCH.349"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>
      EXTERNAL           <a name="DLAMCH.350"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode and test the input parameters
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      LQUERY = ( LWORK.EQ.-1 .OR. LIWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( IJOB.LT.0 .OR. IJOB.GT.5 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -9
      ELSE IF( LDQ.LT.1 .OR. ( WANTQ .AND. LDQ.LT.N ) ) THEN
         INFO = -13
      ELSE IF( LDZ.LT.1 .OR. ( WANTZ .AND. LDZ.LT.N ) ) THEN
         INFO = -15
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.374"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="ZTGSEN.374"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a>'</span>, -INFO )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span>      IERR = 0
<span class="comment">*</span><span class="comment">
</span>      WANTP = IJOB.EQ.1 .OR. IJOB.GE.4
      WANTD1 = IJOB.EQ.2 .OR. IJOB.EQ.4
      WANTD2 = IJOB.EQ.3 .OR. IJOB.EQ.5
      WANTD = WANTD1 .OR. WANTD2
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Set M to the dimension of the specified pair of deflating
</span><span class="comment">*</span><span class="comment">     subspaces.
</span><span class="comment">*</span><span class="comment">
</span>      M = 0
      DO 10 K = 1, N
         ALPHA( K ) = A( K, K )
         BETA( K ) = B( K, K )
         IF( K.LT.N ) THEN
            IF( SELECT( K ) )
     $         M = M + 1
         ELSE
            IF( SELECT( N ) )
     $         M = M + 1
         END IF
   10 CONTINUE
<span class="comment">*</span><span class="comment">
</span>      IF( IJOB.EQ.1 .OR. IJOB.EQ.2 .OR. IJOB.EQ.4 ) THEN
         LWMIN = MAX( 1, 2*M*( N-M ) )
         LIWMIN = MAX( 1, N+2 )
      ELSE IF( IJOB.EQ.3 .OR. IJOB.EQ.5 ) THEN
         LWMIN = MAX( 1, 4*M*( N-M ) )
         LIWMIN = MAX( 1, 2*M*( N-M ), N+2 )
      ELSE
         LWMIN = 1
         LIWMIN = 1
      END IF
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = LWMIN
      IWORK( 1 ) = LIWMIN
<span class="comment">*</span><span class="comment">
</span>      IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN
         INFO = -21
      ELSE IF( LIWORK.LT.LIWMIN .AND. .NOT.LQUERY ) THEN
         INFO = -23
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.422"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="ZTGSEN.422"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.N .OR. M.EQ.0 ) THEN
         IF( WANTP ) THEN
            PL = ONE
            PR = ONE
         END IF
         IF( WANTD ) THEN
            DSCALE = ZERO
            DSUM = ONE
            DO 20 I = 1, N
               CALL <a name="ZLASSQ.439"></a><a href="zlassq.f.html#ZLASSQ.1">ZLASSQ</a>( N, A( 1, I ), 1, DSCALE, DSUM )
               CALL <a name="ZLASSQ.440"></a><a href="zlassq.f.html#ZLASSQ.1">ZLASSQ</a>( N, B( 1, I ), 1, DSCALE, DSUM )
   20       CONTINUE
            DIF( 1 ) = DSCALE*SQRT( DSUM )
            DIF( 2 ) = DIF( 1 )
         END IF
         GO TO 70
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constant
</span><span class="comment">*</span><span class="comment">
</span>      SAFMIN = <a name="DLAMCH.450"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Collect the selected blocks at the top-left corner of (A, B).
</span><span class="comment">*</span><span class="comment">
</span>      KS = 0
      DO 30 K = 1, N
         SWAP = SELECT( K )
         IF( SWAP ) THEN
            KS = KS + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Swap the K-th block to position KS. Compute unitary Q
</span><span class="comment">*</span><span class="comment">           and Z that will swap adjacent diagonal blocks in (A, B).
</span><span class="comment">*</span><span class="comment">
</span>            IF( K.NE.KS )
     $         CALL <a name="ZTGEXC.464"></a><a href="ztgexc.f.html#ZTGEXC.1">ZTGEXC</a>( WANTQ, WANTZ, N, A, LDA, B, LDB, Q, LDQ, Z,
     $                      LDZ, K, KS, IERR )
<span class="comment">*</span><span class="comment">
</span>            IF( IERR.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Swap is rejected: exit.
</span><span class="comment">*</span><span class="comment">
</span>               INFO = 1
               IF( WANTP ) THEN
                  PL = ZERO
                  PR = ZERO
               END IF
               IF( WANTD ) THEN
                  DIF( 1 ) = ZERO
                  DIF( 2 ) = ZERO
               END IF
               GO TO 70
            END IF
         END IF
   30 CONTINUE
      IF( WANTP ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve generalized Sylvester equation for R and L:
</span><span class="comment">*</span><span class="comment">                   A11 * R - L * A22 = A12
</span><span class="comment">*</span><span class="comment">                   B11 * R - L * B22 = B12
</span><span class="comment">*</span><span class="comment">
</span>         N1 = M
         N2 = N - M
         I = N1 + 1
         CALL <a name="ZLACPY.493"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'Full'</span>, N1, N2, A( 1, I ), LDA, WORK, N1 )
         CALL <a name="ZLACPY.494"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'Full'</span>, N1, N2, B( 1, I ), LDB, WORK( N1*N2+1 ),
     $                N1 )
         IJB = 0
         CALL <a name="ZTGSYL.497"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'N'</span>, IJB, N1, N2, A, LDA, A( I, I ), LDA, WORK,
     $                N1, B, LDB, B( I, I ), LDB, WORK( N1*N2+1 ), N1,
     $                DSCALE, DIF( 1 ), WORK( N1*N2*2+1 ),
     $                LWORK-2*N1*N2, IWORK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Estimate the reciprocal of norms of &quot;projections&quot; onto
</span><span class="comment">*</span><span class="comment">        left and right eigenspaces
</span><span class="comment">*</span><span class="comment">
</span>         RDSCAL = ZERO
         DSUM = ONE
         CALL <a name="ZLASSQ.507"></a><a href="zlassq.f.html#ZLASSQ.1">ZLASSQ</a>( N1*N2, WORK, 1, RDSCAL, DSUM )
         PL = RDSCAL*SQRT( DSUM )
         IF( PL.EQ.ZERO ) THEN
            PL = ONE
         ELSE
            PL = DSCALE / ( SQRT( DSCALE*DSCALE / PL+PL )*SQRT( PL ) )
         END IF
         RDSCAL = ZERO
         DSUM = ONE
         CALL <a name="ZLASSQ.516"></a><a href="zlassq.f.html#ZLASSQ.1">ZLASSQ</a>( N1*N2, WORK( N1*N2+1 ), 1, RDSCAL, DSUM )
         PR = RDSCAL*SQRT( DSUM )
         IF( PR.EQ.ZERO ) THEN
            PR = ONE
         ELSE
            PR = DSCALE / ( SQRT( DSCALE*DSCALE / PR+PR )*SQRT( PR ) )
         END IF
      END IF
      IF( WANTD ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute estimates Difu and Difl.
</span><span class="comment">*</span><span class="comment">
</span>         IF( WANTD1 ) THEN
            N1 = M
            N2 = N - M
            I = N1 + 1
            IJB = IDIFJB
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Frobenius norm-based Difu estimate.
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZTGSYL.536"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'N'</span>, IJB, N1, N2, A, LDA, A( I, I ), LDA, WORK,
     $                   N1, B, LDB, B( I, I ), LDB, WORK( N1*N2+1 ),
     $                   N1, DSCALE, DIF( 1 ), WORK( N1*N2*2+1 ),
     $                   LWORK-2*N1*N2, IWORK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Frobenius norm-based Difl estimate.
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZTGSYL.543"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'N'</span>, IJB, N2, N1, A( I, I ), LDA, A, LDA, WORK,
     $                   N2, B( I, I ), LDB, B, LDB, WORK( N1*N2+1 ),
     $                   N2, DSCALE, DIF( 2 ), WORK( N1*N2*2+1 ),
     $                   LWORK-2*N1*N2, IWORK, IERR )
         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute 1-norm-based estimates of Difu and Difl using
</span><span class="comment">*</span><span class="comment">           reversed communication with <a name="ZLACN2.550"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a>. In each step a
</span><span class="comment">*</span><span class="comment">           generalized Sylvester equation or a transposed variant
</span><span class="comment">*</span><span class="comment">           is solved.
</span><span class="comment">*</span><span class="comment">
</span>            KASE = 0
            N1 = M
            N2 = N - M
            I = N1 + 1
            IJB = 0
            MN2 = 2*N1*N2
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           1-norm-based estimate of Difu.
</span><span class="comment">*</span><span class="comment">
</span>   40       CONTINUE
            CALL <a name="ZLACN2.564"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a>( MN2, WORK( MN2+1 ), WORK, DIF( 1 ), KASE,
     $                   ISAVE )
            IF( KASE.NE.0 ) THEN
               IF( KASE.EQ.1 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve generalized Sylvester equation
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZTGSYL.571"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'N'</span>, IJB, N1, N2, A, LDA, A( I, I ), LDA,
     $                         WORK, N1, B, LDB, B( I, I ), LDB,
     $                         WORK( N1*N2+1 ), N1, DSCALE, DIF( 1 ),
     $                         WORK( N1*N2*2+1 ), LWORK-2*N1*N2, IWORK,
     $                         IERR )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve the transposed variant.
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZTGSYL.580"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'C'</span>, IJB, N1, N2, A, LDA, A( I, I ), LDA,
     $                         WORK, N1, B, LDB, B( I, I ), LDB,
     $                         WORK( N1*N2+1 ), N1, DSCALE, DIF( 1 ),
     $                         WORK( N1*N2*2+1 ), LWORK-2*N1*N2, IWORK,
     $                         IERR )
               END IF
               GO TO 40
            END IF
            DIF( 1 ) = DSCALE / DIF( 1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           1-norm-based estimate of Difl.
</span><span class="comment">*</span><span class="comment">
</span>   50       CONTINUE
            CALL <a name="ZLACN2.593"></a><a href="zlacn2.f.html#ZLACN2.1">ZLACN2</a>( MN2, WORK( MN2+1 ), WORK, DIF( 2 ), KASE,
     $                   ISAVE )
            IF( KASE.NE.0 ) THEN
               IF( KASE.EQ.1 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve generalized Sylvester equation
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZTGSYL.600"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'N'</span>, IJB, N2, N1, A( I, I ), LDA, A, LDA,
     $                         WORK, N2, B( I, I ), LDB, B, LDB,
     $                         WORK( N1*N2+1 ), N2, DSCALE, DIF( 2 ),
     $                         WORK( N1*N2*2+1 ), LWORK-2*N1*N2, IWORK,
     $                         IERR )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Solve the transposed variant.
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZTGSYL.609"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( <span class="string">'C'</span>, IJB, N2, N1, A( I, I ), LDA, A, LDA,
     $                         WORK, N2, B, LDB, B( I, I ), LDB,
     $                         WORK( N1*N2+1 ), N2, DSCALE, DIF( 2 ),
     $                         WORK( N1*N2*2+1 ), LWORK-2*N1*N2, IWORK,
     $                         IERR )
               END IF
               GO TO 50
            END IF
            DIF( 2 ) = DSCALE / DIF( 2 )
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If B(K,K) is complex, make it real and positive (normalization
</span><span class="comment">*</span><span class="comment">     of the generalized Schur form) and Store the generalized
</span><span class="comment">*</span><span class="comment">     eigenvalues of reordered pair (A, B)
</span><span class="comment">*</span><span class="comment">
</span>      DO 60 K = 1, N
         DSCALE = ABS( B( K, K ) )
         IF( DSCALE.GT.SAFMIN ) THEN
            TEMP1 = DCONJG( B( K, K ) / DSCALE )
            TEMP2 = B( K, K ) / DSCALE
            B( K, K ) = DSCALE
            CALL ZSCAL( N-K, TEMP1, B( K, K+1 ), LDB )
            CALL ZSCAL( N-K+1, TEMP1, A( K, K ), LDA )
            IF( WANTQ )
     $         CALL ZSCAL( N, TEMP2, Q( 1, K ), 1 )
         ELSE
            B( K, K ) = DCMPLX( ZERO, ZERO )
         END IF
<span class="comment">*</span><span class="comment">
</span>         ALPHA( K ) = A( K, K )
         BETA( K ) = B( K, K )
<span class="comment">*</span><span class="comment">
</span>   60 CONTINUE
<span class="comment">*</span><span class="comment">
</span>   70 CONTINUE
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = LWMIN
      IWORK( 1 ) = LIWMIN
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="ZTGSEN.651"></a><a href="ztgsen.f.html#ZTGSEN.1">ZTGSEN</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
