<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dgesdd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DGESDD.1"></a><a href="dgesdd.f.html#DGESDD.1">DGESDD</a>( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,
     $                   LWORK, IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBZ
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),
     $                   VT( LDVT, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DGESDD.21"></a><a href="dgesdd.f.html#DGESDD.1">DGESDD</a> computes the singular value decomposition (SVD) of a real
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and right singular
</span><span class="comment">*</span><span class="comment">  vectors.  If singular vectors are desired, it uses a
</span><span class="comment">*</span><span class="comment">  divide-and-conquer algorithm.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns VT = V**T, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The divide and conquer algorithm makes very mild assumptions about
</span><span class="comment">*</span><span class="comment">  floating point arithmetic. It will work on machines with a guard
</span><span class="comment">*</span><span class="comment">  digit in add/subtract, or on those binary machines without guard
</span><span class="comment">*</span><span class="comment">  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
</span><span class="comment">*</span><span class="comment">  Cray-2. It could conceivably fail on hexadecimal or decimal machines
</span><span class="comment">*</span><span class="comment">  without guard digits, but we know of none.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBZ    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U and all N rows of V**T are
</span><span class="comment">*</span><span class="comment">                  returned in the arrays U and VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(M,N) columns of U and the first
</span><span class="comment">*</span><span class="comment">                  min(M,N) rows of V**T are returned in the arrays U
</span><span class="comment">*</span><span class="comment">                  and VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  If M &gt;= N, the first N columns of U are overwritten
</span><span class="comment">*</span><span class="comment">                  on the array A and all rows of V**T are returned in
</span><span class="comment">*</span><span class="comment">                  the array VT;
</span><span class="comment">*</span><span class="comment">                  otherwise, all columns of U are returned in the
</span><span class="comment">*</span><span class="comment">                  array U and the first M rows of V**T are overwritten
</span><span class="comment">*</span><span class="comment">                  in the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U or rows of V**T are computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O',  A is overwritten with the first N columns
</span><span class="comment">*</span><span class="comment">                          of U (the left singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          columnwise) if M &gt;= N;
</span><span class="comment">*</span><span class="comment">                          A is overwritten with the first M rows
</span><span class="comment">*</span><span class="comment">                          of V**T (the right singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          rowwise) otherwise.
</span><span class="comment">*</span><span class="comment">          if JOBZ .ne. 'O', the contents of A are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
</span><span class="comment">*</span><span class="comment">          UCOL = min(M,N) if JOBZ = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
</span><span class="comment">*</span><span class="comment">          orthogonal matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', U contains the first min(M,N) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
</span><span class="comment">*</span><span class="comment">          N-by-N orthogonal matrix V**T;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', VT contains the first min(M,N) rows of
</span><span class="comment">*</span><span class="comment">          V**T (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'N',
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N) + max(max(M,N),7*min(M,N)).
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'O',
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N)*min(M,N) + 
</span><span class="comment">*</span><span class="comment">                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'S' or 'A'
</span><span class="comment">*</span><span class="comment">            LWORK &gt;= 3*min(M,N)*min(M,N) +
</span><span class="comment">*</span><span class="comment">                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">          If LWORK = -1 but other input arguments are legal, WORK(1)
</span><span class="comment">*</span><span class="comment">          returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  <a name="DBDSDC.134"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a> did not converge, updating process failed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Ming Gu and Huan Ren, Computer Science Division, University of
</span><span class="comment">*</span><span class="comment">     California at Berkeley, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, WNTQA, WNTQAS, WNTQN, WNTQO, WNTQS
      INTEGER            BDSPAC, BLK, CHUNK, I, IE, IERR, IL,
     $                   IR, ISCL, ITAU, ITAUP, ITAUQ, IU, IVT, LDWKVT,
     $                   LDWRKL, LDWRKR, LDWRKU, MAXWRK, MINMN, MINWRK,
     $                   MNTHR, NWORK, WRKBL
      DOUBLE PRECISION   ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      INTEGER            IDUM( 1 )
      DOUBLE PRECISION   DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DBDSDC.162"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>, <a name="DGEBRD.162"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>, <a name="DGELQF.162"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>, DGEMM, <a name="DGEQRF.162"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>, <a name="DLACPY.162"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>,
     $                   <a name="DLASCL.163"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="DLASET.163"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>, <a name="DORGBR.163"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>, <a name="DORGLQ.163"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>, <a name="DORGQR.163"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>, <a name="DORMBR.163"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>,
     $                   <a name="XERBLA.164"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.167"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.168"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.169"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.169"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
      EXTERNAL           <a name="DLAMCH.170"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.170"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>, <a name="ILAENV.170"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="LSAME.170"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          INT, MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      WNTQA = <a name="LSAME.181"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'A'</span> )
      WNTQS = <a name="LSAME.182"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'S'</span> )
      WNTQAS = WNTQA .OR. WNTQS
      WNTQO = <a name="LSAME.184"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'O'</span> )
      WNTQN = <a name="LSAME.185"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTQA .OR. WNTQS .OR. WNTQO .OR. WNTQN ) ) THEN
         INFO = -1
      ELSE IF( M.LT.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDU.LT.1 .OR. ( WNTQAS .AND. LDU.LT.M ) .OR.
     $         ( WNTQO .AND. M.LT.N .AND. LDU.LT.M ) ) THEN
         INFO = -8
      ELSE IF( LDVT.LT.1 .OR. ( WNTQA .AND. LDVT.LT.N ) .OR.
     $         ( WNTQS .AND. LDVT.LT.MINMN ) .OR.
     $         ( WNTQO .AND. M.GE.N .AND. LDVT.LT.N ) ) THEN
         INFO = -10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.210"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="DBDSDC.217"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = INT( MINMN*11.0D0 / 6.0D0 )
            IF( WNTQN ) THEN
               BDSPAC = 7*N
            ELSE
               BDSPAC = 3*N*N + 4*N
            END IF
            IF( M.GE.MNTHR ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.230"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.230"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                    -1 )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.233"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.233"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+N )
                  MINWRK = BDSPAC + N
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.240"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.240"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.241"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.244"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.244"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.246"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.246"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.248"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.248"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + 2*N*N
                  MINWRK = BDSPAC + 2*N*N + 3*N
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.256"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.257"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.257"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.260"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.260"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.262"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.262"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.264"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.264"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + N*N
                  MINWRK = BDSPAC + N*N + 3*N
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.272"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.272"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.273"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGQR.273"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.276"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.276"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.278"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.278"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.280"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.280"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + N*N
                  MINWRK = BDSPAC + N*N + 3*N
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               WRKBL = 3*N + ( M+N )*<a name="ILAENV.289"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.289"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                 -1 )
               IF( WNTQN ) THEN
                  MAXWRK = MAX( WRKBL, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               ELSE IF( WNTQO ) THEN
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.296"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.296"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.298"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.298"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*N )
                  MAXWRK = WRKBL + M*N
                  MINWRK = 3*N + MAX( M, N*N+BDSPAC )
               ELSE IF( WNTQS ) THEN
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.304"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.304"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.306"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.306"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               ELSE IF( WNTQA ) THEN
                  WRKBL = MAX( WRKBL, 3*N+M*
     $                    <a name="ILAENV.311"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.311"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.313"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.313"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC+3*N )
                  MINWRK = 3*N + MAX( M, BDSPAC )
               END IF
            END IF
         ELSE IF( MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="DBDSDC.320"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = INT( MINMN*11.0D0 / 6.0D0 )
            IF( WNTQN ) THEN
               BDSPAC = 7*M
            ELSE
               BDSPAC = 3*M*M + 4*M
            END IF
            IF( N.GE.MNTHR ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.333"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.333"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                    -1 )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.336"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.336"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+M )
                  MINWRK = BDSPAC + M
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.343"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.343"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.344"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.344"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.347"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.347"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.349"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.349"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.351"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.351"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + 2*M*M
                  MINWRK = BDSPAC + 2*M*M + 3*M
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.359"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.359"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.360"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.360"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.363"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.363"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.365"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.365"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.367"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.367"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*M
                  MINWRK = BDSPAC + M*M + 3*M
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.375"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.375"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.376"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORGLQ.376"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.379"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.379"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.381"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.381"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.383"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.383"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*M
                  MINWRK = BDSPAC + M*M + 3*M
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               WRKBL = 3*M + ( M+N )*<a name="ILAENV.392"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.392"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                 -1 )
               IF( WNTQN ) THEN
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               ELSE IF( WNTQO ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.399"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.399"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.401"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.401"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, M, N, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC+3*M )
                  MAXWRK = WRKBL + M*N
                  MINWRK = 3*M + MAX( N, M*M+BDSPAC )
               ELSE IF( WNTQS ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.407"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.407"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.409"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.409"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               ELSE IF( WNTQA ) THEN
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.414"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.416"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.416"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PRT'</span>, N, N, M, -1 ) )
                  MAXWRK = MAX( WRKBL, BDSPAC+3*M )
                  MINWRK = 3*M + MAX( N, BDSPAC )
               END IF
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -12
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.431"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DGESDD.431"></a><a href="dgesdd.f.html#DGESDD.1">DGESDD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.445"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="DLAMCH.446"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="DLANGE.451"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="DLASCL.455"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="DLASCL.458"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEQRF.480"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.485"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = 1
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.494"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing singular values only
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.502"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBZ = 'O')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IR = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IR) is LDWRKR by N
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.LDA*N+N*N+3*N+BDSPAC ) THEN
                  LDWRKR = LDA
               ELSE
                  LDWRKR = ( LWORK-N*N-3*N-BDSPAC ) / N
               END IF
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEQRF.526"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.531"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="DLASET.532"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGQR.538"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in VT, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.548"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               IU = NWORK
               NWORK = IU + N*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.562"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ), N,
     $                      VT, LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of R
</span><span class="comment">*</span><span class="comment">              and VT by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N*N+3*N, prefer 2*N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.570"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), WORK( IU ), N, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.573"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in WORK(IR) and copying to A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N*N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">
</span>               DO 10 I = 1, M, LDWRKR
                  CHUNK = MIN( M-I+1, LDWRKR )
                  CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                        LDA, WORK( IU ), N, ZERO, WORK( IR ),
     $                        LDWRKR )
                  CALL <a name="DLACPY.586"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IR ), LDWRKR,
     $                         A( I, 1 ), LDA )
   10          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IR = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKR = N
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEQRF.607"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.612"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="DLASET.613"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGQR.619"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.629"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagoal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.638"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of R and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.646"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.650"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.658"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, N, N, U, LDU, WORK( IR ), LDWRKR )
               CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA, WORK( IR ),
     $                     LDWRKR, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IU = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKU = N
               ITAU = IU + LDWRKU*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEQRF.679"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DLACPY.681"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span>               CALL <a name="DORGQR.685"></a><a href="dorgqr.f.html#DORGQR.1">DORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce R in A, zeroing out other entries
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.690"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = ITAU
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.699"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.708"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ), N,
     $                      VT, LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of R and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.716"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.719"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU, WORK( IU ),
     $                     LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.732"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + N
            ITAUP = ITAUQ + N
            NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DGEBRD.751"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, only computing singular values
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.759"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               IU = NWORK
               IF( LWORK.GE.M*N+3*N+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = M
                  NWORK = IU + LDWRKU*N
                  CALL <a name="DLASET.769"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, WORK( IU ),
     $                         LDWRKU )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = N
                  NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IR) is LDWRKR by N
</span><span class="comment">*</span><span class="comment">
</span>                  IR = NWORK
                  LDWRKR = ( LWORK-N*N-3*N ) / N
               END IF
               NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in WORK(IU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.790"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), WORK( IU ),
     $                      LDWRKU, VT, LDVT, DUM, IDUM, WORK( NWORK ),
     $                      IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.797"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*N+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Overwrite WORK(IU) by left singular vectors of A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORMBR.806"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                         WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy left singular vectors of A from WORK(IU) to A
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.812"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IU ), LDWRKU, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.818"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of
</span><span class="comment">*</span><span class="comment">                 bidiagonal matrix in WORK(IU), storing result in
</span><span class="comment">*</span><span class="comment">                 WORK(IR) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N*N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 20 I = 1, M, LDWRKR
                     CHUNK = MIN( M-I+1, LDWRKR )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IU ), LDWRKU, ZERO,
     $                           WORK( IR ), LDWRKR )
                     CALL <a name="DLACPY.831"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IR ), LDWRKR,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.843"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, U, LDU )
               CALL <a name="DBDSDC.844"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.852"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.855"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.865"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M, M, ZERO, ZERO, U, LDU )
               CALL <a name="DBDSDC.866"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set the right corner of U to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               IF( M.GT.N ) THEN
                  CALL <a name="DLASET.873"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M-N, M-N, ZERO, ONE, U( N+1, N+1 ),
     $                         LDU )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need N*N+2*N+M, prefer N*N+2*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.881"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.884"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGELQF.910"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.915"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = 1
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.924"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing singular values only
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.932"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, M, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              IVT is M by M
</span><span class="comment">*</span><span class="comment">
</span>               IL = IVT + M*M
               IF( LWORK.GE.M*N+M*M+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKL = M
                  CHUNK = N
               ELSE
                  LDWRKL = M
                  CHUNK = ( LWORK-M*M ) / M
               END IF
               ITAU = IL + LDWRKL*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGELQF.962"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.967"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="DLASET.968"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGLQ.974"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.984"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U, and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.993"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), M, DUM, IDUM, WORK( NWORK ),
     $                      IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and WORK(IVT)
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M*M+3*M, prefer 2*M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1001"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.1004"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), WORK( IVT ), M,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IVT) by Q
</span><span class="comment">*</span><span class="comment">              in A, storing result in WORK(IL) and copying to A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M*M, prefer M*M+M*N)
</span><span class="comment">*</span><span class="comment">
</span>               DO 30 I = 1, N, CHUNK
                  BLK = MIN( N-I+1, CHUNK )
                  CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IVT ), M,
     $                        A( 1, I ), LDA, ZERO, WORK( IL ), LDWRKL )
                  CALL <a name="DLACPY.1016"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IL ), LDWRKL,
     $                         A( 1, I ), LDA )
   30          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IL = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IL) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKL = M
               ITAU = IL + LDWRKL*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGELQF.1037"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.1042"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="DLASET.1043"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGLQ.1049"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.1059"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, WORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1068"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1076"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.1079"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IL) by
</span><span class="comment">*</span><span class="comment">              Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.1087"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, M, VT, LDVT, WORK( IL ), LDWRKL )
               CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IL ), LDWRKL,
     $                     A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 4t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IVT) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWKVT = M
               ITAU = IVT + LDWKVT*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGELQF.1108"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DLACPY.1110"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORGLQ.1115"></a><a href="dorglq.f.html#DORGLQ.1">DORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce L in A, zeroing out other entries
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.1120"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = ITAU
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DGEBRD.1129"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1138"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), LDWKVT, DUM, IDUM,
     $                      WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L and WORK(IVT)
</span><span class="comment">*</span><span class="comment">              by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1146"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.1149"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IVT) by
</span><span class="comment">*</span><span class="comment">              Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IVT ), LDWKVT,
     $                     VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLACPY.1162"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + M
            ITAUP = ITAUQ + M
            NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DGEBRD.1181"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, only computing singular values
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1189"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'N'</span>, M, S, WORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, WORK( NWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               LDWKVT = M
               IVT = NWORK
               IF( LWORK.GE.M*N+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLASET.1198"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, WORK( IVT ),
     $                         LDWKVT )
                  NWORK = IVT + LDWKVT*N
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                  NWORK = IVT + LDWKVT*M
                  IL = NWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) is M by CHUNK
</span><span class="comment">*</span><span class="comment">
</span>                  CHUNK = ( LWORK-M*M-3*M ) / M
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in WORK(IVT)
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1218"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU,
     $                      WORK( IVT ), LDWKVT, DUM, IDUM,
     $                      WORK( NWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1225"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*M+BDSPAC ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Overwrite WORK(IVT) by left singular vectors of A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORMBR.1234"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                         WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy right singular vectors of A from WORK(IVT) to A
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLACPY.1240"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IVT ), LDWKVT, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate P**T in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DORGBR.1246"></a><a href="dorgbr.f.html#DORGBR.1">DORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by right singular vectors of
</span><span class="comment">*</span><span class="comment">                 bidiagonal matrix in WORK(IVT), storing result in
</span><span class="comment">*</span><span class="comment">                 WORK(IL) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M*M, prefer M*M+M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL DGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IVT ),
     $                           LDWKVT, A( 1, I ), LDA, ZERO,
     $                           WORK( IL ), M )
                     CALL <a name="DLACPY.1259"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IL ), M, A( 1, I ),
     $                            LDA )
   40             CONTINUE
               END IF
            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.1270"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, M, N, ZERO, ZERO, VT, LDVT )
               CALL <a name="DBDSDC.1271"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1279"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.1282"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors of bidiagonal matrix in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DLASET.1292"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, N, N, ZERO, ZERO, VT, LDVT )
               CALL <a name="DBDSDC.1293"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, WORK( IE ), U, LDU, VT,
     $                      LDVT, DUM, IDUM, WORK( NWORK ), IWORK,
     $                      INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set the right corner of VT to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               IF( N.GT.M ) THEN
                  CALL <a name="DLASET.1300"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, N-M, N-M, ZERO, ONE, VT( M+1, M+1 ),
     $                         LDVT )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A and VT
</span><span class="comment">*</span><span class="comment">              by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DORMBR.1308"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="DORMBR.1311"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'T'</span>, N, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.1324"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.1327"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DGESDD.1337"></a><a href="dgesdd.f.html#DGESDD.1">DGESDD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
