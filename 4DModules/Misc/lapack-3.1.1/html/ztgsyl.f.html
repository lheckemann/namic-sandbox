<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>ztgsyl.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="ZTGSYL.1"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>( TRANS, IJOB, M, N, A, LDA, B, LDB, C, LDC, D,
     $                   LDD, E, LDE, F, LDF, SCALE, DIF, WORK, LWORK,
     $                   IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     January 2007
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          TRANS
      INTEGER            IJOB, INFO, LDA, LDB, LDC, LDD, LDE, LDF,
     $                   LWORK, M, N
      DOUBLE PRECISION   DIF, SCALE
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      COMPLEX*16         A( LDA, * ), B( LDB, * ), C( LDC, * ),
     $                   D( LDD, * ), E( LDE, * ), F( LDF, * ),
     $                   WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZTGSYL.25"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a> solves the generalized Sylvester equation:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              A * R - L * B = scale * C            (1)
</span><span class="comment">*</span><span class="comment">              D * R - L * E = scale * F
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where R and L are unknown m-by-n matrices, (A, D), (B, E) and
</span><span class="comment">*</span><span class="comment">  (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
</span><span class="comment">*</span><span class="comment">  respectively, with complex entries. A, B, D and E are upper
</span><span class="comment">*</span><span class="comment">  triangular (i.e., (A,D) and (B,E) in generalized Schur form).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The solution (R, L) overwrites (C, F). 0 &lt;= SCALE &lt;= 1
</span><span class="comment">*</span><span class="comment">  is an output scaling factor chosen to avoid overflow.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
</span><span class="comment">*</span><span class="comment">  is defined as
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         Z = [ kron(In, A)  -kron(B', Im) ]        (2)
</span><span class="comment">*</span><span class="comment">             [ kron(In, D)  -kron(E', Im) ],
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Here Ix is the identity matrix of size x and X' is the conjugate
</span><span class="comment">*</span><span class="comment">  transpose of X. Kron(X, Y) is the Kronecker product between the
</span><span class="comment">*</span><span class="comment">  matrices X and Y.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If TRANS = 'C', y in the conjugate transposed system Z'*y = scale*b
</span><span class="comment">*</span><span class="comment">  is solved for, which is equivalent to solve for R and L in
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              A' * R + D' * L = scale * C           (3)
</span><span class="comment">*</span><span class="comment">              R * B' + L * E' = scale * -F
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This case (TRANS = 'C') is used to compute an one-norm-based estimate
</span><span class="comment">*</span><span class="comment">  of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
</span><span class="comment">*</span><span class="comment">  and (B,E), using <a name="ZLACON.56"></a><a href="zlacon.f.html#ZLACON.1">ZLACON</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If IJOB &gt;= 1, <a name="ZTGSYL.58"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a> computes a Frobenius norm-based estimate of
</span><span class="comment">*</span><span class="comment">  Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
</span><span class="comment">*</span><span class="comment">  reciprocal of the smallest singular value of Z.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This is a level-3 BLAS algorithm.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  TRANS   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': solve the generalized sylvester equation (1).
</span><span class="comment">*</span><span class="comment">          = 'C': solve the &quot;conjugate transposed&quot; system (3).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IJOB    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          Specifies what kind of functionality to be performed.
</span><span class="comment">*</span><span class="comment">          =0: solve (1) only.
</span><span class="comment">*</span><span class="comment">          =1: The functionality of 0 and 3.
</span><span class="comment">*</span><span class="comment">          =2: The functionality of 0 and 4.
</span><span class="comment">*</span><span class="comment">          =3: Only an estimate of Dif[(A,D), (B,E)] is computed.
</span><span class="comment">*</span><span class="comment">              (look ahead strategy is used).
</span><span class="comment">*</span><span class="comment">          =4: Only an estimate of Dif[(A,D), (B,E)] is computed.
</span><span class="comment">*</span><span class="comment">              (<a name="ZGECON.79"></a><a href="zgecon.f.html#ZGECON.1">ZGECON</a> on sub-systems is used).
</span><span class="comment">*</span><span class="comment">          Not referenced if TRANS = 'C'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices A and D, and the row dimension of
</span><span class="comment">*</span><span class="comment">          the matrices C, F, R and L.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices B and E, and the column dimension
</span><span class="comment">*</span><span class="comment">          of the matrices C, F, R and L.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input) COMPLEX*16 array, dimension (LDA, M)
</span><span class="comment">*</span><span class="comment">          The upper triangular matrix A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input) COMPLEX*16 array, dimension (LDB, N)
</span><span class="comment">*</span><span class="comment">          The upper triangular matrix B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1, N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  C       (input/output) COMPLEX*16 array, dimension (LDC, N)
</span><span class="comment">*</span><span class="comment">          On entry, C contains the right-hand-side of the first matrix
</span><span class="comment">*</span><span class="comment">          equation in (1) or (3).
</span><span class="comment">*</span><span class="comment">          On exit, if IJOB = 0, 1 or 2, C has been overwritten by
</span><span class="comment">*</span><span class="comment">          the solution R. If IJOB = 3 or 4 and TRANS = 'N', C holds R,
</span><span class="comment">*</span><span class="comment">          the solution achieved during the computation of the
</span><span class="comment">*</span><span class="comment">          Dif-estimate.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDC     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array C. LDC &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  D       (input) COMPLEX*16 array, dimension (LDD, M)
</span><span class="comment">*</span><span class="comment">          The upper triangular matrix D.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDD     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array D. LDD &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  E       (input) COMPLEX*16 array, dimension (LDE, N)
</span><span class="comment">*</span><span class="comment">          The upper triangular matrix E.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDE     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array E. LDE &gt;= max(1, N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  F       (input/output) COMPLEX*16 array, dimension (LDF, N)
</span><span class="comment">*</span><span class="comment">          On entry, F contains the right-hand-side of the second matrix
</span><span class="comment">*</span><span class="comment">          equation in (1) or (3).
</span><span class="comment">*</span><span class="comment">          On exit, if IJOB = 0, 1 or 2, F has been overwritten by
</span><span class="comment">*</span><span class="comment">          the solution L. If IJOB = 3 or 4 and TRANS = 'N', F holds L,
</span><span class="comment">*</span><span class="comment">          the solution achieved during the computation of the
</span><span class="comment">*</span><span class="comment">          Dif-estimate.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDF     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array F. LDF &gt;= max(1, M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  DIF     (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          On exit DIF is the reciprocal of a lower bound of the
</span><span class="comment">*</span><span class="comment">          reciprocal of the Dif-function, i.e. DIF is an upper bound of
</span><span class="comment">*</span><span class="comment">          Dif[(A,D), (B,E)] = sigma-min(Z), where Z as in (2).
</span><span class="comment">*</span><span class="comment">          IF IJOB = 0 or TRANS = 'C', DIF is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SCALE   (output) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          On exit SCALE is the scaling factor in (1) or (3).
</span><span class="comment">*</span><span class="comment">          If 0 &lt; SCALE &lt; 1, C and F hold the solutions R and L, resp.,
</span><span class="comment">*</span><span class="comment">          to a slightly perturbed system but the input matrices A, B,
</span><span class="comment">*</span><span class="comment">          D and E have not been changed. If SCALE = 0, R and L will
</span><span class="comment">*</span><span class="comment">          hold the solutions to the homogenious system with C = F = 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt; = 1.
</span><span class="comment">*</span><span class="comment">          If IJOB = 1 or 2 and TRANS = 'N', LWORK &gt;= max(1,2*M*N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.159"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (M+N+2)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">            =0: successful exit
</span><span class="comment">*</span><span class="comment">            &lt;0: If INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">            &gt;0: (A, D) and (B, E) have common or very close
</span><span class="comment">*</span><span class="comment">                eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
</span><span class="comment">*</span><span class="comment">     Umea University, S-901 87 Umea, Sweden.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [1] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
</span><span class="comment">*</span><span class="comment">      for Solving the Generalized Sylvester Equation and Estimating the
</span><span class="comment">*</span><span class="comment">      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
</span><span class="comment">*</span><span class="comment">      Department of Computing Science, Umea University, S-901 87 Umea,
</span><span class="comment">*</span><span class="comment">      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
</span><span class="comment">*</span><span class="comment">      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
</span><span class="comment">*</span><span class="comment">      No 1, 1996.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [2] B. Kagstrom, A Perturbation Analysis of the Generalized Sylvester
</span><span class="comment">*</span><span class="comment">      Equation (AR - LB, DR - LE ) = (C, F), SIAM J. Matrix Anal.
</span><span class="comment">*</span><span class="comment">      Appl., 15(4):1045-1060, 1994.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [3] B. Kagstrom and L. Westin, Generalized Schur Methods with
</span><span class="comment">*</span><span class="comment">      Condition Estimators for Solving the Generalized Sylvester
</span><span class="comment">*</span><span class="comment">      Equation, IEEE Transactions on Automatic Control, Vol. 34, No. 7,
</span><span class="comment">*</span><span class="comment">      July 1989, pp 745-751.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">  Replaced various illegal calls to CCOPY by calls to <a name="CLASET.194"></a><a href="claset.f.html#CLASET.1">CLASET</a>.
</span><span class="comment">*</span><span class="comment">  Sven Hammarling, 1/5/02.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
      COMPLEX*16         CZERO
      PARAMETER          ( CZERO = (0.0D+0, 0.0D+0) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, NOTRAN
      INTEGER            I, IE, IFUNC, IROUND, IS, ISOLVE, J, JE, JS, K,
     $                   LINFO, LWMIN, MB, NB, P, PQ, Q
      DOUBLE PRECISION   DSCALE, DSUM, SCALE2, SCALOC
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.210"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.211"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      EXTERNAL           <a name="LSAME.212"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.212"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="XERBLA.215"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>, ZGEMM, <a name="ZLACPY.215"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>, <a name="ZLASET.215"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>, ZSCAL, <a name="ZTGSY2.215"></a><a href="ztgsy2.f.html#ZTGSY2.1">ZTGSY2</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          DBLE, DCMPLX, MAX, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode and test input parameters
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      NOTRAN = <a name="LSAME.225"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANS, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.NOTRAN .AND. .NOT.<a name="LSAME.228"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( TRANS, <span class="string">'C'</span> ) ) THEN
         INFO = -1
      ELSE IF( NOTRAN ) THEN
         IF( ( IJOB.LT.0 ) .OR. ( IJOB.GT.4 ) ) THEN
            INFO = -2
         END IF
      END IF
      IF( INFO.EQ.0 ) THEN
         IF( M.LE.0 ) THEN
            INFO = -3
         ELSE IF( N.LE.0 ) THEN
            INFO = -4
         ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
            INFO = -6
         ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
            INFO = -8
         ELSE IF( LDC.LT.MAX( 1, M ) ) THEN
            INFO = -10
         ELSE IF( LDD.LT.MAX( 1, M ) ) THEN
            INFO = -12
         ELSE IF( LDE.LT.MAX( 1, N ) ) THEN
            INFO = -14
         ELSE IF( LDF.LT.MAX( 1, M ) ) THEN
            INFO = -16
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         IF( NOTRAN ) THEN
            IF( IJOB.EQ.1 .OR. IJOB.EQ.2 ) THEN
               LWMIN = MAX( 1, 2*M*N )
            ELSE
               LWMIN = 1
            END IF
         ELSE
            LWMIN = 1
         END IF
         WORK( 1 ) = LWMIN
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN
            INFO = -20
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.273"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="ZTGSYL.273"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         SCALE = 1
         IF( NOTRAN ) THEN
            IF( IJOB.NE.0 ) THEN
               DIF = 0
            END IF
         END IF
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Determine  optimal block sizes MB and NB
</span><span class="comment">*</span><span class="comment">
</span>      MB = <a name="ILAENV.293"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 2, <span class="string">'<a name="ZTGSYL.293"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>'</span>, TRANS, M, N, -1, -1 )
      NB = <a name="ILAENV.294"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 5, <span class="string">'<a name="ZTGSYL.294"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>'</span>, TRANS, M, N, -1, -1 )
<span class="comment">*</span><span class="comment">
</span>      ISOLVE = 1
      IFUNC = 0
      IF( NOTRAN ) THEN
         IF( IJOB.GE.3 ) THEN
            IFUNC = IJOB - 2
            CALL <a name="ZLASET.301"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, C, LDC )
            CALL <a name="ZLASET.302"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, F, LDF )
         ELSE IF( IJOB.GE.1 .AND. NOTRAN ) THEN
            ISOLVE = 2
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ( MB.LE.1 .AND. NB.LE.1 ) .OR. ( MB.GE.M .AND. NB.GE.N ) )
     $     THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Use unblocked Level 2 solver
</span><span class="comment">*</span><span class="comment">
</span>         DO 30 IROUND = 1, ISOLVE
<span class="comment">*</span><span class="comment">
</span>            SCALE = ONE
            DSCALE = ZERO
            DSUM = ONE
            PQ = M*N
            CALL <a name="ZTGSY2.319"></a><a href="ztgsy2.f.html#ZTGSY2.1">ZTGSY2</a>( TRANS, IFUNC, M, N, A, LDA, B, LDB, C, LDC, D,
     $                   LDD, E, LDE, F, LDF, SCALE, DSUM, DSCALE,
     $                   INFO )
            IF( DSCALE.NE.ZERO ) THEN
               IF( IJOB.EQ.1 .OR. IJOB.EQ.3 ) THEN
                  DIF = SQRT( DBLE( 2*M*N ) ) / ( DSCALE*SQRT( DSUM ) )
               ELSE
                  DIF = SQRT( DBLE( PQ ) ) / ( DSCALE*SQRT( DSUM ) )
               END IF
            END IF
            IF( ISOLVE.EQ.2 .AND. IROUND.EQ.1 ) THEN
               IF( NOTRAN ) THEN
                  IFUNC = IJOB
               END IF
               SCALE2 = SCALE
               CALL <a name="ZLACPY.334"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, C, LDC, WORK, M )
               CALL <a name="ZLACPY.335"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, F, LDF, WORK( M*N+1 ), M )
               CALL <a name="ZLASET.336"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, C, LDC )
               CALL <a name="ZLASET.337"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, F, LDF )
            ELSE IF( ISOLVE.EQ.2 .AND. IROUND.EQ.2 ) THEN
               CALL <a name="ZLACPY.339"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK, M, C, LDC )
               CALL <a name="ZLACPY.340"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK( M*N+1 ), M, F, LDF )
               SCALE = SCALE2
            END IF
   30    CONTINUE
<span class="comment">*</span><span class="comment">
</span>         RETURN
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Determine block structure of A
</span><span class="comment">*</span><span class="comment">
</span>      P = 0
      I = 1
   40 CONTINUE
      IF( I.GT.M )
     $   GO TO 50
      P = P + 1
      IWORK( P ) = I
      I = I + MB
      IF( I.GE.M )
     $   GO TO 50
      GO TO 40
   50 CONTINUE
      IWORK( P+1 ) = M + 1
      IF( IWORK( P ).EQ.IWORK( P+1 ) )
     $   P = P - 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Determine block structure of B
</span><span class="comment">*</span><span class="comment">
</span>      Q = P + 1
      J = 1
   60 CONTINUE
      IF( J.GT.N )
     $   GO TO 70
<span class="comment">*</span><span class="comment">
</span>      Q = Q + 1
      IWORK( Q ) = J
      J = J + NB
      IF( J.GE.N )
     $   GO TO 70
      GO TO 60
<span class="comment">*</span><span class="comment">
</span>   70 CONTINUE
      IWORK( Q+1 ) = N + 1
      IF( IWORK( Q ).EQ.IWORK( Q+1 ) )
     $   Q = Q - 1
<span class="comment">*</span><span class="comment">
</span>      IF( NOTRAN ) THEN
         DO 150 IROUND = 1, ISOLVE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Solve (I, J) - subsystem
</span><span class="comment">*</span><span class="comment">               A(I, I) * R(I, J) - L(I, J) * B(J, J) = C(I, J)
</span><span class="comment">*</span><span class="comment">               D(I, I) * R(I, J) - L(I, J) * E(J, J) = F(I, J)
</span><span class="comment">*</span><span class="comment">           for I = P, P - 1, ..., 1; J = 1, 2, ..., Q
</span><span class="comment">*</span><span class="comment">
</span>            PQ = 0
            SCALE = ONE
            DSCALE = ZERO
            DSUM = ONE
            DO 130 J = P + 2, Q
               JS = IWORK( J )
               JE = IWORK( J+1 ) - 1
               NB = JE - JS + 1
               DO 120 I = P, 1, -1
                  IS = IWORK( I )
                  IE = IWORK( I+1 ) - 1
                  MB = IE - IS + 1
                  CALL <a name="ZTGSY2.407"></a><a href="ztgsy2.f.html#ZTGSY2.1">ZTGSY2</a>( TRANS, IFUNC, MB, NB, A( IS, IS ), LDA,
     $                         B( JS, JS ), LDB, C( IS, JS ), LDC,
     $                         D( IS, IS ), LDD, E( JS, JS ), LDE,
     $                         F( IS, JS ), LDF, SCALOC, DSUM, DSCALE,
     $                         LINFO )
                  IF( LINFO.GT.0 )
     $               INFO = LINFO
                  PQ = PQ + MB*NB
                  IF( SCALOC.NE.ONE ) THEN
                     DO 80 K = 1, JS - 1
                        CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ),
     $                              C( 1, K ), 1 )
                        CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ),
     $                              F( 1, K ), 1 )
   80                CONTINUE
                     DO 90 K = JS, JE
                        CALL ZSCAL( IS-1, DCMPLX( SCALOC, ZERO ),
     $                              C( 1, K ), 1 )
                        CALL ZSCAL( IS-1, DCMPLX( SCALOC, ZERO ),
     $                              F( 1, K ), 1 )
   90                CONTINUE
                     DO 100 K = JS, JE
                        CALL ZSCAL( M-IE, DCMPLX( SCALOC, ZERO ),
     $                              C( IE+1, K ), 1 )
                        CALL ZSCAL( M-IE, DCMPLX( SCALOC, ZERO ),
     $                              F( IE+1, K ), 1 )
  100                CONTINUE
                     DO 110 K = JE + 1, N
                        CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ),
     $                              C( 1, K ), 1 )
                        CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ),
     $                              F( 1, K ), 1 )
  110                CONTINUE
                     SCALE = SCALE*SCALOC
                  END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Substitute R(I,J) and L(I,J) into remaining equation.
</span><span class="comment">*</span><span class="comment">
</span>                  IF( I.GT.1 ) THEN
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, IS-1, NB, MB,
     $                           DCMPLX( -ONE, ZERO ), A( 1, IS ), LDA,
     $                           C( IS, JS ), LDC, DCMPLX( ONE, ZERO ),
     $                           C( 1, JS ), LDC )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, IS-1, NB, MB,
     $                           DCMPLX( -ONE, ZERO ), D( 1, IS ), LDD,
     $                           C( IS, JS ), LDC, DCMPLX( ONE, ZERO ),
     $                           F( 1, JS ), LDF )
                  END IF
                  IF( J.LT.Q ) THEN
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, MB, N-JE, NB,
     $                           DCMPLX( ONE, ZERO ), F( IS, JS ), LDF,
     $                           B( JS, JE+1 ), LDB,
     $                           DCMPLX( ONE, ZERO ), C( IS, JE+1 ),
     $                           LDC )
                     CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, MB, N-JE, NB,
     $                           DCMPLX( ONE, ZERO ), F( IS, JS ), LDF,
     $                           E( JS, JE+1 ), LDE,
     $                           DCMPLX( ONE, ZERO ), F( IS, JE+1 ),
     $                           LDF )
                  END IF
  120          CONTINUE
  130       CONTINUE
            IF( DSCALE.NE.ZERO ) THEN
               IF( IJOB.EQ.1 .OR. IJOB.EQ.3 ) THEN
                  DIF = SQRT( DBLE( 2*M*N ) ) / ( DSCALE*SQRT( DSUM ) )
               ELSE
                  DIF = SQRT( DBLE( PQ ) ) / ( DSCALE*SQRT( DSUM ) )
               END IF
            END IF
            IF( ISOLVE.EQ.2 .AND. IROUND.EQ.1 ) THEN
               IF( NOTRAN ) THEN
                  IFUNC = IJOB
               END IF
               SCALE2 = SCALE
               CALL <a name="ZLACPY.481"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, C, LDC, WORK, M )
               CALL <a name="ZLACPY.482"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, F, LDF, WORK( M*N+1 ), M )
               CALL <a name="ZLASET.483"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, C, LDC )
               CALL <a name="ZLASET.484"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, F, LDF )
            ELSE IF( ISOLVE.EQ.2 .AND. IROUND.EQ.2 ) THEN
               CALL <a name="ZLACPY.486"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK, M, C, LDC )
               CALL <a name="ZLACPY.487"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK( M*N+1 ), M, F, LDF )
               SCALE = SCALE2
            END IF
  150    CONTINUE
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve transposed (I, J)-subsystem
</span><span class="comment">*</span><span class="comment">            A(I, I)' * R(I, J) + D(I, I)' * L(I, J) = C(I, J)
</span><span class="comment">*</span><span class="comment">            R(I, J) * B(J, J)  + L(I, J) * E(J, J) = -F(I, J)
</span><span class="comment">*</span><span class="comment">        for I = 1,2,..., P; J = Q, Q-1,..., 1
</span><span class="comment">*</span><span class="comment">
</span>         SCALE = ONE
         DO 210 I = 1, P
            IS = IWORK( I )
            IE = IWORK( I+1 ) - 1
            MB = IE - IS + 1
            DO 200 J = Q, P + 2, -1
               JS = IWORK( J )
               JE = IWORK( J+1 ) - 1
               NB = JE - JS + 1
               CALL <a name="ZTGSY2.507"></a><a href="ztgsy2.f.html#ZTGSY2.1">ZTGSY2</a>( TRANS, IFUNC, MB, NB, A( IS, IS ), LDA,
     $                      B( JS, JS ), LDB, C( IS, JS ), LDC,
     $                      D( IS, IS ), LDD, E( JS, JS ), LDE,
     $                      F( IS, JS ), LDF, SCALOC, DSUM, DSCALE,
     $                      LINFO )
               IF( LINFO.GT.0 )
     $            INFO = LINFO
               IF( SCALOC.NE.ONE ) THEN
                  DO 160 K = 1, JS - 1
                     CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ), C( 1, K ),
     $                           1 )
                     CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ), F( 1, K ),
     $                           1 )
  160             CONTINUE
                  DO 170 K = JS, JE
                     CALL ZSCAL( IS-1, DCMPLX( SCALOC, ZERO ),
     $                           C( 1, K ), 1 )
                     CALL ZSCAL( IS-1, DCMPLX( SCALOC, ZERO ),
     $                           F( 1, K ), 1 )
  170             CONTINUE
                  DO 180 K = JS, JE
                     CALL ZSCAL( M-IE, DCMPLX( SCALOC, ZERO ),
     $                           C( IE+1, K ), 1 )
                     CALL ZSCAL( M-IE, DCMPLX( SCALOC, ZERO ),
     $                           F( IE+1, K ), 1 )
  180             CONTINUE
                  DO 190 K = JE + 1, N
                     CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ), C( 1, K ),
     $                           1 )
                     CALL ZSCAL( M, DCMPLX( SCALOC, ZERO ), F( 1, K ),
     $                           1 )
  190             CONTINUE
                  SCALE = SCALE*SCALOC
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Substitute R(I,J) and L(I,J) into remaining equation.
</span><span class="comment">*</span><span class="comment">
</span>               IF( J.GT.P+2 ) THEN
                  CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'C'</span>, MB, JS-1, NB,
     $                        DCMPLX( ONE, ZERO ), C( IS, JS ), LDC,
     $                        B( 1, JS ), LDB, DCMPLX( ONE, ZERO ),
     $                        F( IS, 1 ), LDF )
                  CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'C'</span>, MB, JS-1, NB,
     $                        DCMPLX( ONE, ZERO ), F( IS, JS ), LDF,
     $                        E( 1, JS ), LDE, DCMPLX( ONE, ZERO ),
     $                        F( IS, 1 ), LDF )
               END IF
               IF( I.LT.P ) THEN
                  CALL ZGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, M-IE, NB, MB,
     $                        DCMPLX( -ONE, ZERO ), A( IS, IE+1 ), LDA,
     $                        C( IS, JS ), LDC, DCMPLX( ONE, ZERO ),
     $                        C( IE+1, JS ), LDC )
                  CALL ZGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, M-IE, NB, MB,
     $                        DCMPLX( -ONE, ZERO ), D( IS, IE+1 ), LDD,
     $                        F( IS, JS ), LDF, DCMPLX( ONE, ZERO ),
     $                        C( IE+1, JS ), LDC )
               END IF
  200       CONTINUE
  210    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = LWMIN
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="ZTGSYL.572"></a><a href="ztgsyl.f.html#ZTGSYL.1">ZTGSYL</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
