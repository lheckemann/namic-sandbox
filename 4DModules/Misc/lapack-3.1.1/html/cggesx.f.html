<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>cggesx.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="CGGESX.1"></a><a href="cggesx.f.html#CGGESX.1">CGGESX</a>( JOBVSL, JOBVSR, SORT, SELCTG, SENSE, N, A, LDA,
     $                   B, LDB, SDIM, ALPHA, BETA, VSL, LDVSL, VSR,
     $                   LDVSR, RCONDE, RCONDV, WORK, LWORK, RWORK,
     $                   IWORK, LIWORK, BWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBVSL, JOBVSR, SENSE, SORT
      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LIWORK, LWORK, N,
     $                   SDIM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      LOGICAL            BWORK( * )
      INTEGER            IWORK( * )
      REAL               RCONDE( 2 ), RCONDV( 2 ), RWORK( * )
      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),
     $                   BETA( * ), VSL( LDVSL, * ), VSR( LDVSR, * ),
     $                   WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Function Arguments ..
</span>      LOGICAL            SELCTG
      EXTERNAL           SELCTG
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="CGGESX.31"></a><a href="cggesx.f.html#CGGESX.1">CGGESX</a> computes for a pair of N-by-N complex nonsymmetric matrices
</span><span class="comment">*</span><span class="comment">  (A,B), the generalized eigenvalues, the complex Schur form (S,T),
</span><span class="comment">*</span><span class="comment">  and, optionally, the left and/or right matrices of Schur vectors (VSL
</span><span class="comment">*</span><span class="comment">  and VSR).  This gives the generalized Schur factorization
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where (VSR)**H is the conjugate-transpose of VSR.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally, it also orders the eigenvalues so that a selected cluster
</span><span class="comment">*</span><span class="comment">  of eigenvalues appears in the leading diagonal blocks of the upper
</span><span class="comment">*</span><span class="comment">  triangular matrix S and the upper triangular matrix T; computes
</span><span class="comment">*</span><span class="comment">  a reciprocal condition number for the average of the selected
</span><span class="comment">*</span><span class="comment">  eigenvalues (RCONDE); and computes a reciprocal condition number for
</span><span class="comment">*</span><span class="comment">  the right and left deflating subspaces corresponding to the selected
</span><span class="comment">*</span><span class="comment">  eigenvalues (RCONDV). The leading columns of VSL and VSR then form
</span><span class="comment">*</span><span class="comment">  an orthonormal basis for the corresponding left and right eigenspaces
</span><span class="comment">*</span><span class="comment">  (deflating subspaces).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w
</span><span class="comment">*</span><span class="comment">  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is
</span><span class="comment">*</span><span class="comment">  usually represented as the pair (alpha,beta), as there is a
</span><span class="comment">*</span><span class="comment">  reasonable interpretation for beta=0 or for both being zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A pair of matrices (S,T) is in generalized complex Schur form if T is
</span><span class="comment">*</span><span class="comment">  upper triangular with non-negative diagonal and S is upper
</span><span class="comment">*</span><span class="comment">  triangular.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVSL  (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the left Schur vectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the left Schur vectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVSR  (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the right Schur vectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the right Schur vectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SORT    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies whether or not to order the eigenvalues on the
</span><span class="comment">*</span><span class="comment">          diagonal of the generalized Schur form.
</span><span class="comment">*</span><span class="comment">          = 'N':  Eigenvalues are not ordered;
</span><span class="comment">*</span><span class="comment">          = 'S':  Eigenvalues are ordered (see SELCTG).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SELCTG  (external procedure) LOGICAL FUNCTION of two COMPLEX arguments
</span><span class="comment">*</span><span class="comment">          SELCTG must be declared EXTERNAL in the calling subroutine.
</span><span class="comment">*</span><span class="comment">          If SORT = 'N', SELCTG is not referenced.
</span><span class="comment">*</span><span class="comment">          If SORT = 'S', SELCTG is used to select eigenvalues to sort
</span><span class="comment">*</span><span class="comment">          to the top left of the Schur form.
</span><span class="comment">*</span><span class="comment">          Note that a selected complex eigenvalue may no longer satisfy
</span><span class="comment">*</span><span class="comment">          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since
</span><span class="comment">*</span><span class="comment">          ordering may change the value of complex eigenvalues
</span><span class="comment">*</span><span class="comment">          (especially if the eigenvalue is ill-conditioned), in this
</span><span class="comment">*</span><span class="comment">          case INFO is set to N+3 see INFO below).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SENSE   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Determines which reciprocal condition numbers are computed.
</span><span class="comment">*</span><span class="comment">          = 'N' : None are computed;
</span><span class="comment">*</span><span class="comment">          = 'E' : Computed for average of selected eigenvalues only;
</span><span class="comment">*</span><span class="comment">          = 'V' : Computed for selected deflating subspaces only;
</span><span class="comment">*</span><span class="comment">          = 'B' : Computed for both.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E', 'V', or 'B', SORT must equal 'S'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices A, B, VSL, and VSR.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX array, dimension (LDA, N)
</span><span class="comment">*</span><span class="comment">          On entry, the first of the pair of matrices.
</span><span class="comment">*</span><span class="comment">          On exit, A has been overwritten by its generalized Schur
</span><span class="comment">*</span><span class="comment">          form S.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of A.  LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) COMPLEX array, dimension (LDB, N)
</span><span class="comment">*</span><span class="comment">          On entry, the second of the pair of matrices.
</span><span class="comment">*</span><span class="comment">          On exit, B has been overwritten by its generalized Schur
</span><span class="comment">*</span><span class="comment">          form T.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of B.  LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SDIM    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          If SORT = 'N', SDIM = 0.
</span><span class="comment">*</span><span class="comment">          If SORT = 'S', SDIM = number of eigenvalues (after sorting)
</span><span class="comment">*</span><span class="comment">          for which SELCTG is true.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHA   (output) COMPLEX array, dimension (N)
</span><span class="comment">*</span><span class="comment">  BETA    (output) COMPLEX array, dimension (N)
</span><span class="comment">*</span><span class="comment">          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the
</span><span class="comment">*</span><span class="comment">          generalized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are
</span><span class="comment">*</span><span class="comment">          the diagonals of the complex Schur form (S,T).  BETA(j) will
</span><span class="comment">*</span><span class="comment">          be non-negative real.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          Note: the quotients ALPHA(j)/BETA(j) may easily over- or
</span><span class="comment">*</span><span class="comment">          underflow, and BETA(j) may even be zero.  Thus, the user
</span><span class="comment">*</span><span class="comment">          should avoid naively computing the ratio alpha/beta.
</span><span class="comment">*</span><span class="comment">          However, ALPHA will be always less than and usually
</span><span class="comment">*</span><span class="comment">          comparable with norm(A) in magnitude, and BETA always less
</span><span class="comment">*</span><span class="comment">          than and usually comparable with norm(B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VSL     (output) COMPLEX array, dimension (LDVSL,N)
</span><span class="comment">*</span><span class="comment">          If JOBVSL = 'V', VSL will contain the left Schur vectors.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVSL = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVSL   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VSL. LDVSL &gt;=1, and
</span><span class="comment">*</span><span class="comment">          if JOBVSL = 'V', LDVSL &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VSR     (output) COMPLEX array, dimension (LDVSR,N)
</span><span class="comment">*</span><span class="comment">          If JOBVSR = 'V', VSR will contain the right Schur vectors.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVSR = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVSR   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VSR. LDVSR &gt;= 1, and
</span><span class="comment">*</span><span class="comment">          if JOBVSR = 'V', LDVSR &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDE  (output) REAL array, dimension ( 2 )
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', RCONDE(1) and RCONDE(2) contain the
</span><span class="comment">*</span><span class="comment">          reciprocal condition numbers for the average of the selected
</span><span class="comment">*</span><span class="comment">          eigenvalues.
</span><span class="comment">*</span><span class="comment">          Not referenced if SENSE = 'N' or 'V'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDV  (output) REAL array, dimension ( 2 )
</span><span class="comment">*</span><span class="comment">          If SENSE = 'V' or 'B', RCONDV(1) and RCONDV(2) contain the
</span><span class="comment">*</span><span class="comment">          reciprocal condition number for the selected deflating
</span><span class="comment">*</span><span class="comment">          subspaces.
</span><span class="comment">*</span><span class="comment">          Not referenced if SENSE = 'N' or 'E'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.
</span><span class="comment">*</span><span class="comment">          If N = 0, LWORK &gt;= 1, else if SENSE = 'E', 'V', or 'B',
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= MAX(1,2*N,2*SDIM*(N-SDIM)), else
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= MAX(1,2*N).  Note that 2*SDIM*(N-SDIM) &lt;= N*N/2.
</span><span class="comment">*</span><span class="comment">          Note also that an error is only returned if
</span><span class="comment">*</span><span class="comment">          LWORK &lt; MAX(1,2*N), but if SENSE = 'E' or 'V' or 'B' this may
</span><span class="comment">*</span><span class="comment">          not be large enough.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the bound on the optimal size of the WORK
</span><span class="comment">*</span><span class="comment">          array and the minimum size of the IWORK array, returns these
</span><span class="comment">*</span><span class="comment">          values as the first entries of the WORK and IWORK arrays, and
</span><span class="comment">*</span><span class="comment">          no error message related to LWORK or LIWORK is issued by
</span><span class="comment">*</span><span class="comment">          <a name="XERBLA.178"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) REAL array, dimension ( 8*N )
</span><span class="comment">*</span><span class="comment">          Real workspace.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LIWORK  (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'N' or N = 0, LIWORK &gt;= 1, otherwise
</span><span class="comment">*</span><span class="comment">          LIWORK &gt;= N+2.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LIWORK = -1, then a workspace query is assumed; the
</span><span class="comment">*</span><span class="comment">          routine only calculates the bound on the optimal size of the
</span><span class="comment">*</span><span class="comment">          WORK array and the minimum size of the IWORK array, returns
</span><span class="comment">*</span><span class="comment">          these values as the first entries of the WORK and IWORK
</span><span class="comment">*</span><span class="comment">          arrays, and no error message related to LWORK or LIWORK is
</span><span class="comment">*</span><span class="comment">          issued by <a name="XERBLA.196"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BWORK   (workspace) LOGICAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          Not referenced if SORT = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          = 1,...,N:
</span><span class="comment">*</span><span class="comment">                The QZ iteration failed.  (A,B) are not in Schur
</span><span class="comment">*</span><span class="comment">                form, but ALPHA(j) and BETA(j) should be correct for
</span><span class="comment">*</span><span class="comment">                j=INFO+1,...,N.
</span><span class="comment">*</span><span class="comment">          &gt; N:  =N+1: other than QZ iteration failed in <a name="CHGEQZ.208"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>
</span><span class="comment">*</span><span class="comment">                =N+2: after reordering, roundoff changed values of
</span><span class="comment">*</span><span class="comment">                      some complex eigenvalues so that leading
</span><span class="comment">*</span><span class="comment">                      eigenvalues in the Generalized Schur form no
</span><span class="comment">*</span><span class="comment">                      longer satisfy SELCTG=.TRUE.  This could also
</span><span class="comment">*</span><span class="comment">                      be caused due to scaling.
</span><span class="comment">*</span><span class="comment">                =N+3: reordering failed in <a name="CTGSEN.214"></a><a href="ctgsen.f.html#CTGSEN.1">CTGSEN</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
      COMPLEX            CZERO, CONE
      PARAMETER          ( CZERO = ( 0.0E+0, 0.0E+0 ),
     $                   CONE = ( 1.0E+0, 0.0E+0 ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            CURSL, ILASCL, ILBSCL, ILVSL, ILVSR, LASTSL,
     $                   LQUERY, WANTSB, WANTSE, WANTSN, WANTST, WANTSV
      INTEGER            I, ICOLS, IERR, IHI, IJOB, IJOBVL, IJOBVR,
     $                   ILEFT, ILO, IRIGHT, IROWS, IRWRK, ITAU, IWRK,
     $                   LIWMIN, LWRK, MAXWRK, MINWRK
      REAL               ANRM, ANRMTO, BIGNUM, BNRM, BNRMTO, EPS, PL,
     $                   PR, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      REAL               DIF( 2 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="CGEQRF.238"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CGGBAK.238"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>, <a name="CGGBAL.238"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a>, <a name="CGGHRD.238"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>, <a name="CHGEQZ.238"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>, <a name="CLACPY.238"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>,
     $                   <a name="CLASCL.239"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>, <a name="CLASET.239"></a><a href="claset.f.html#CLASET.1">CLASET</a>, <a name="CTGSEN.239"></a><a href="ctgsen.f.html#CTGSEN.1">CTGSEN</a>, <a name="CUNGQR.239"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>, <a name="CUNMQR.239"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, <a name="SLABAD.239"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>,
     $                   <a name="XERBLA.240"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.243"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.244"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="CLANGE.245"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.245"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      EXTERNAL           <a name="LSAME.246"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.246"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="CLANGE.246"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.246"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.255"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVSL, <span class="string">'N'</span> ) ) THEN
         IJOBVL = 1
         ILVSL = .FALSE.
      ELSE IF( <a name="LSAME.258"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVSL, <span class="string">'V'</span> ) ) THEN
         IJOBVL = 2
         ILVSL = .TRUE.
      ELSE
         IJOBVL = -1
         ILVSL = .FALSE.
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.266"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVSR, <span class="string">'N'</span> ) ) THEN
         IJOBVR = 1
         ILVSR = .FALSE.
      ELSE IF( <a name="LSAME.269"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVSR, <span class="string">'V'</span> ) ) THEN
         IJOBVR = 2
         ILVSR = .TRUE.
      ELSE
         IJOBVR = -1
         ILVSR = .FALSE.
      END IF
<span class="comment">*</span><span class="comment">
</span>      WANTST = <a name="LSAME.277"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SORT, <span class="string">'S'</span> )
      WANTSN = <a name="LSAME.278"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'N'</span> )
      WANTSE = <a name="LSAME.279"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'E'</span> )
      WANTSV = <a name="LSAME.280"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'V'</span> )
      WANTSB = <a name="LSAME.281"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'B'</span> )
      LQUERY = ( LWORK.EQ.-1 .OR. LIWORK.EQ.-1 )
      IF( WANTSN ) THEN
         IJOB = 0
      ELSE IF( WANTSE ) THEN
         IJOB = 1
      ELSE IF( WANTSV ) THEN
         IJOB = 2
      ELSE IF( WANTSB ) THEN
         IJOB = 4
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      IF( IJOBVL.LE.0 ) THEN
         INFO = -1
      ELSE IF( IJOBVR.LE.0 ) THEN
         INFO = -2
      ELSE IF( ( .NOT.WANTST ) .AND. ( .NOT.<a name="LSAME.300"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SORT, <span class="string">'N'</span> ) ) ) THEN
         INFO = -3
      ELSE IF( .NOT.( WANTSN .OR. WANTSE .OR. WANTSV .OR. WANTSB ) .OR.
     $         ( .NOT.WANTST .AND. .NOT.WANTSN ) ) THEN
         INFO = -5
      ELSE IF( N.LT.0 ) THEN
         INFO = -6
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -8
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -10
      ELSE IF( LDVSL.LT.1 .OR. ( ILVSL .AND. LDVSL.LT.N ) ) THEN
         INFO = -15
      ELSE IF( LDVSR.LT.1 .OR. ( ILVSR .AND. LDVSR.LT.N ) ) THEN
         INFO = -17
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.322"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         IF( N.GT.0) THEN
            MINWRK = 2*N
            MAXWRK = N*(1 + <a name="ILAENV.327"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEQRF.327"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 ) )
            MAXWRK = MAX( MAXWRK, N*( 1 +
     $                    <a name="ILAENV.329"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMQR.329"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>'</span>, <span class="string">' '</span>, N, 1, N, -1 ) ) )
            IF( ILVSL ) THEN
               MAXWRK = MAX( MAXWRK, N*( 1 +
     $                       <a name="ILAENV.332"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNGQR.332"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>'</span>, <span class="string">' '</span>, N, 1, N, -1 ) ) )
            END IF
            LWRK = MAXWRK
            IF( IJOB.GE.1 )
     $         LWRK = MAX( LWRK, N*N/2 )
         ELSE
            MINWRK = 1
            MAXWRK = 1
            LWRK   = 1
         END IF
         WORK( 1 ) = LWRK
         IF( WANTSN .OR. N.EQ.0 ) THEN
            LIWMIN = 1
         ELSE
            LIWMIN = N + 2
         END IF
         IWORK( 1 ) = LIWMIN
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -21
         ELSE IF( LIWORK.LT.LIWMIN  .AND. .NOT.LQUERY) THEN
            INFO = -24
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.358"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="CGGESX.358"></a><a href="cggesx.f.html#CGGESX.1">CGGESX</a>'</span>, -INFO )
         RETURN
      ELSE IF (LQUERY) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 ) THEN
         SDIM = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.373"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="SLAMCH.374"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.376"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
      SMLNUM = SQRT( SMLNUM ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="CLANGE.382"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, N, N, A, LDA, RWORK )
      ILASCL = .FALSE.
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ANRMTO = SMLNUM
         ILASCL = .TRUE.
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ANRMTO = BIGNUM
         ILASCL = .TRUE.
      END IF
      IF( ILASCL )
     $   CALL <a name="CLASCL.392"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, ANRMTO, N, N, A, LDA, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="CLANGE.396"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, N, N, B, LDB, RWORK )
      ILBSCL = .FALSE.
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
         BNRMTO = SMLNUM
         ILBSCL = .TRUE.
      ELSE IF( BNRM.GT.BIGNUM ) THEN
         BNRMTO = BIGNUM
         ILBSCL = .TRUE.
      END IF
      IF( ILBSCL )
     $   CALL <a name="CLASCL.406"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BNRMTO, N, N, B, LDB, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Permute the matrix to make it more nearly triangular
</span><span class="comment">*</span><span class="comment">     (Real Workspace: need 6*N)
</span><span class="comment">*</span><span class="comment">
</span>      ILEFT = 1
      IRIGHT = N + 1
      IRWRK = IRIGHT + N
      CALL <a name="CGGBAL.414"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a>( <span class="string">'P'</span>, N, A, LDA, B, LDB, ILO, IHI, RWORK( ILEFT ),
     $             RWORK( IRIGHT ), RWORK( IRWRK ), IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce B to triangular form (QR decomposition of B)
</span><span class="comment">*</span><span class="comment">     (Complex Workspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      IROWS = IHI + 1 - ILO
      ICOLS = N + 1 - ILO
      ITAU = 1
      IWRK = ITAU + IROWS
      CALL <a name="CGEQRF.424"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>( IROWS, ICOLS, B( ILO, ILO ), LDB, WORK( ITAU ),
     $             WORK( IWRK ), LWORK+1-IWRK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Apply the unitary transformation to matrix A
</span><span class="comment">*</span><span class="comment">     (Complex Workspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="CUNMQR.430"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, IROWS, ICOLS, IROWS, B( ILO, ILO ), LDB,
     $             WORK( ITAU ), A( ILO, ILO ), LDA, WORK( IWRK ),
     $             LWORK+1-IWRK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Initialize VSL
</span><span class="comment">*</span><span class="comment">     (Complex Workspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILVSL ) THEN
         CALL <a name="CLASET.438"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'Full'</span>, N, N, CZERO, CONE, VSL, LDVSL )
         IF( IROWS.GT.1 ) THEN
            CALL <a name="CLACPY.440"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, IROWS-1, IROWS-1, B( ILO+1, ILO ), LDB,
     $                   VSL( ILO+1, ILO ), LDVSL )
         END IF
         CALL <a name="CUNGQR.443"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>( IROWS, IROWS, IROWS, VSL( ILO, ILO ), LDVSL,
     $                WORK( ITAU ), WORK( IWRK ), LWORK+1-IWRK, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Initialize VSR
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILVSR )
     $   CALL <a name="CLASET.450"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'Full'</span>, N, N, CZERO, CONE, VSR, LDVSR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce to generalized Hessenberg form
</span><span class="comment">*</span><span class="comment">     (Workspace: none needed)
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="CGGHRD.455"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>( JOBVSL, JOBVSR, N, ILO, IHI, A, LDA, B, LDB, VSL,
     $             LDVSL, VSR, LDVSR, IERR )
<span class="comment">*</span><span class="comment">
</span>      SDIM = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Perform QZ algorithm, computing Schur vectors if desired
</span><span class="comment">*</span><span class="comment">     (Complex Workspace: need N)
</span><span class="comment">*</span><span class="comment">     (Real Workspace:    need N)
</span><span class="comment">*</span><span class="comment">
</span>      IWRK = ITAU
      CALL <a name="CHGEQZ.465"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>( <span class="string">'S'</span>, JOBVSL, JOBVSR, N, ILO, IHI, A, LDA, B, LDB,
     $             ALPHA, BETA, VSL, LDVSL, VSR, LDVSR, WORK( IWRK ),
     $             LWORK+1-IWRK, RWORK( IRWRK ), IERR )
      IF( IERR.NE.0 ) THEN
         IF( IERR.GT.0 .AND. IERR.LE.N ) THEN
            INFO = IERR
         ELSE IF( IERR.GT.N .AND. IERR.LE.2*N ) THEN
            INFO = IERR - N
         ELSE
            INFO = N + 1
         END IF
         GO TO 40
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Sort eigenvalues ALPHA/BETA and compute the reciprocal of
</span><span class="comment">*</span><span class="comment">     condition number(s)
</span><span class="comment">*</span><span class="comment">
</span>      IF( WANTST ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo scaling on eigenvalues before SELCTGing
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILASCL )
     $      CALL <a name="CLASCL.487"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRMTO, ANRM, N, 1, ALPHA, N, IERR )
         IF( ILBSCL )
     $      CALL <a name="CLASCL.489"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRMTO, BNRM, N, 1, BETA, N, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Select eigenvalues
</span><span class="comment">*</span><span class="comment">
</span>         DO 10 I = 1, N
            BWORK( I ) = SELCTG( ALPHA( I ), BETA( I ) )
   10    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Reorder eigenvalues, transform Generalized Schur vectors, and
</span><span class="comment">*</span><span class="comment">        compute reciprocal condition numbers
</span><span class="comment">*</span><span class="comment">        (Complex Workspace: If IJOB &gt;= 1, need MAX(1, 2*SDIM*(N-SDIM))
</span><span class="comment">*</span><span class="comment">                            otherwise, need 1 )
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CTGSEN.502"></a><a href="ctgsen.f.html#CTGSEN.1">CTGSEN</a>( IJOB, ILVSL, ILVSR, BWORK, N, A, LDA, B, LDB,
     $                ALPHA, BETA, VSL, LDVSL, VSR, LDVSR, SDIM, PL, PR,
     $                DIF, WORK( IWRK ), LWORK-IWRK+1, IWORK, LIWORK,
     $                IERR )
<span class="comment">*</span><span class="comment">
</span>         IF( IJOB.GE.1 )
     $      MAXWRK = MAX( MAXWRK, 2*SDIM*( N-SDIM ) )
         IF( IERR.EQ.-21 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">            not enough complex workspace
</span><span class="comment">*</span><span class="comment">
</span>            INFO = -21
         ELSE
            IF( IJOB.EQ.1 .OR. IJOB.EQ.4 ) THEN
               RCONDE( 1 ) = PL
               RCONDE( 2 ) = PR
            END IF
            IF( IJOB.EQ.2 .OR. IJOB.EQ.4 ) THEN
               RCONDV( 1 ) = DIF( 1 )
               RCONDV( 2 ) = DIF( 2 )
            END IF
            IF( IERR.EQ.1 )
     $         INFO = N + 3
         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Apply permutation to VSL and VSR
</span><span class="comment">*</span><span class="comment">     (Workspace: none needed)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILVSL )
     $   CALL <a name="CGGBAK.533"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, N, ILO, IHI, RWORK( ILEFT ),
     $                RWORK( IRIGHT ), N, VSL, LDVSL, IERR )
<span class="comment">*</span><span class="comment">
</span>      IF( ILVSR )
     $   CALL <a name="CGGBAK.537"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, N, ILO, IHI, RWORK( ILEFT ),
     $                RWORK( IRIGHT ), N, VSR, LDVSR, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILASCL ) THEN
         CALL <a name="CLASCL.543"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'U'</span>, 0, 0, ANRMTO, ANRM, N, N, A, LDA, IERR )
         CALL <a name="CLASCL.544"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRMTO, ANRM, N, 1, ALPHA, N, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILBSCL ) THEN
         CALL <a name="CLASCL.548"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'U'</span>, 0, 0, BNRMTO, BNRM, N, N, B, LDB, IERR )
         CALL <a name="CLASCL.549"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRMTO, BNRM, N, 1, BETA, N, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( WANTST ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check if reordering is correct
</span><span class="comment">*</span><span class="comment">
</span>         LASTSL = .TRUE.
         SDIM = 0
         DO 30 I = 1, N
            CURSL = SELCTG( ALPHA( I ), BETA( I ) )
            IF( CURSL )
     $         SDIM = SDIM + 1
            IF( CURSL .AND. .NOT.LASTSL )
     $         INFO = N + 2
            LASTSL = CURSL
   30    CONTINUE
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span>   40 CONTINUE
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
      IWORK( 1 ) = LIWMIN
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="CGGESX.576"></a><a href="cggesx.f.html#CGGESX.1">CGGESX</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
