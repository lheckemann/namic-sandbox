<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>slaqr3.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="SLAQR3.1"></a><a href="slaqr3.f.html#SLAQR3.1">SLAQR3</a>( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
     $                   IHIZ, Z, LDZ, NS, ND, SR, SI, V, LDV, NH, T,
     $                   LDT, NV, WV, LDWV, WORK, LWORK )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK auxiliary routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            IHIZ, ILOZ, KBOT, KTOP, LDH, LDT, LDV, LDWV,
     $                   LDZ, LWORK, N, ND, NH, NS, NV, NW
      LOGICAL            WANTT, WANTZ
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               H( LDH, * ), SI( * ), SR( * ), T( LDT, * ),
     $                   V( LDV, * ), WORK( * ), WV( LDWV, * ),
     $                   Z( LDZ, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ******************************************************************
</span><span class="comment">*</span><span class="comment">     Aggressive early deflation:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     This subroutine accepts as input an upper Hessenberg matrix
</span><span class="comment">*</span><span class="comment">     H and performs an orthogonal similarity transformation
</span><span class="comment">*</span><span class="comment">     designed to detect and deflate fully converged eigenvalues from
</span><span class="comment">*</span><span class="comment">     a trailing principal submatrix.  On output H has been over-
</span><span class="comment">*</span><span class="comment">     written by a new Hessenberg matrix that is a perturbation of
</span><span class="comment">*</span><span class="comment">     an orthogonal similarity transformation of H.  It is to be
</span><span class="comment">*</span><span class="comment">     hoped that the final version of H has many zero subdiagonal
</span><span class="comment">*</span><span class="comment">     entries.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ******************************************************************
</span><span class="comment">*</span><span class="comment">     WANTT   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          If .TRUE., then the Hessenberg matrix H is fully updated
</span><span class="comment">*</span><span class="comment">          so that the quasi-triangular Schur factor may be
</span><span class="comment">*</span><span class="comment">          computed (in cooperation with the calling subroutine).
</span><span class="comment">*</span><span class="comment">          If .FALSE., then only enough of H is updated to preserve
</span><span class="comment">*</span><span class="comment">          the eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WANTZ   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          If .TRUE., then the orthogonal matrix Z is updated so
</span><span class="comment">*</span><span class="comment">          so that the orthogonal Schur factor may be computed
</span><span class="comment">*</span><span class="comment">          (in cooperation with the calling subroutine).
</span><span class="comment">*</span><span class="comment">          If .FALSE., then Z is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrix H and (if WANTZ is .TRUE.) the
</span><span class="comment">*</span><span class="comment">          order of the orthogonal matrix Z.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     KTOP    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
</span><span class="comment">*</span><span class="comment">          KBOT and KTOP together determine an isolated block
</span><span class="comment">*</span><span class="comment">          along the diagonal of the Hessenberg matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     KBOT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          It is assumed without a check that either
</span><span class="comment">*</span><span class="comment">          KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
</span><span class="comment">*</span><span class="comment">          determine an isolated block along the diagonal of the
</span><span class="comment">*</span><span class="comment">          Hessenberg matrix.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     NW      (input) INTEGER
</span><span class="comment">*</span><span class="comment">          Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     H       (input/output) REAL array, dimension (LDH,N)
</span><span class="comment">*</span><span class="comment">          On input the initial N-by-N section of H stores the
</span><span class="comment">*</span><span class="comment">          Hessenberg matrix undergoing aggressive early deflation.
</span><span class="comment">*</span><span class="comment">          On output H has been transformed by an orthogonal
</span><span class="comment">*</span><span class="comment">          similarity transformation, perturbed, and the returned
</span><span class="comment">*</span><span class="comment">          to Hessenberg form that (it is to be hoped) has some
</span><span class="comment">*</span><span class="comment">          zero subdiagonal entries.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDH     (input) integer
</span><span class="comment">*</span><span class="comment">          Leading dimension of H just as declared in the calling
</span><span class="comment">*</span><span class="comment">          subroutine.  N .LE. LDH
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ILOZ    (input) INTEGER
</span><span class="comment">*</span><span class="comment">     IHIZ    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          Specify the rows of Z to which transformations must be
</span><span class="comment">*</span><span class="comment">          applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Z       (input/output) REAL array, dimension (LDZ,IHI)
</span><span class="comment">*</span><span class="comment">          IF WANTZ is .TRUE., then on output, the orthogonal
</span><span class="comment">*</span><span class="comment">          similarity transformation mentioned above has been
</span><span class="comment">*</span><span class="comment">          accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
</span><span class="comment">*</span><span class="comment">          If WANTZ is .FALSE., then Z is unreferenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDZ     (input) integer
</span><span class="comment">*</span><span class="comment">          The leading dimension of Z just as declared in the
</span><span class="comment">*</span><span class="comment">          calling subroutine.  1 .LE. LDZ.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     NS      (output) integer
</span><span class="comment">*</span><span class="comment">          The number of unconverged (ie approximate) eigenvalues
</span><span class="comment">*</span><span class="comment">          returned in SR and SI that may be used as shifts by the
</span><span class="comment">*</span><span class="comment">          calling subroutine.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ND      (output) integer
</span><span class="comment">*</span><span class="comment">          The number of converged eigenvalues uncovered by this
</span><span class="comment">*</span><span class="comment">          subroutine.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     SR      (output) REAL array, dimension KBOT
</span><span class="comment">*</span><span class="comment">     SI      (output) REAL array, dimension KBOT
</span><span class="comment">*</span><span class="comment">          On output, the real and imaginary parts of approximate
</span><span class="comment">*</span><span class="comment">          eigenvalues that may be used for shifts are stored in
</span><span class="comment">*</span><span class="comment">          SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
</span><span class="comment">*</span><span class="comment">          SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
</span><span class="comment">*</span><span class="comment">          The real and imaginary parts of converged eigenvalues
</span><span class="comment">*</span><span class="comment">          are stored in SR(KBOT-ND+1) through SR(KBOT) and
</span><span class="comment">*</span><span class="comment">          SI(KBOT-ND+1) through SI(KBOT), respectively.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     V       (workspace) REAL array, dimension (LDV,NW)
</span><span class="comment">*</span><span class="comment">          An NW-by-NW work array.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDV     (input) integer scalar
</span><span class="comment">*</span><span class="comment">          The leading dimension of V just as declared in the
</span><span class="comment">*</span><span class="comment">          calling subroutine.  NW .LE. LDV
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     NH      (input) integer scalar
</span><span class="comment">*</span><span class="comment">          The number of columns of T.  NH.GE.NW.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     T       (workspace) REAL array, dimension (LDT,NW)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDT     (input) integer
</span><span class="comment">*</span><span class="comment">          The leading dimension of T just as declared in the
</span><span class="comment">*</span><span class="comment">          calling subroutine.  NW .LE. LDT
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     NV      (input) integer
</span><span class="comment">*</span><span class="comment">          The number of rows of work array WV available for
</span><span class="comment">*</span><span class="comment">          workspace.  NV.GE.NW.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WV      (workspace) REAL array, dimension (LDWV,NW)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDWV    (input) integer
</span><span class="comment">*</span><span class="comment">          The leading dimension of W just as declared in the
</span><span class="comment">*</span><span class="comment">          calling subroutine.  NW .LE. LDV
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WORK    (workspace) REAL array, dimension LWORK.
</span><span class="comment">*</span><span class="comment">          On exit, WORK(1) is set to an estimate of the optimal value
</span><span class="comment">*</span><span class="comment">          of LWORK for the given values of N, NW, KTOP and KBOT.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LWORK   (input) integer
</span><span class="comment">*</span><span class="comment">          The dimension of the work array WORK.  LWORK = 2*NW
</span><span class="comment">*</span><span class="comment">          suffices, but greater efficiency may result from larger
</span><span class="comment">*</span><span class="comment">          values of LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; <a name="SLAQR3.145"></a><a href="slaqr3.f.html#SLAQR3.1">SLAQR3</a>
</span><span class="comment">*</span><span class="comment">          only estimates the optimal workspace size for the given
</span><span class="comment">*</span><span class="comment">          values of N, NW, KTOP and KBOT.  The estimate is returned
</span><span class="comment">*</span><span class="comment">          in WORK(1).  No error message related to LWORK is issued
</span><span class="comment">*</span><span class="comment">          by <a name="XERBLA.149"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.  Neither H nor Z are accessed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     Based on contributions by
</span><span class="comment">*</span><span class="comment">        Karen Braman and Ralph Byers, Department of Mathematics,
</span><span class="comment">*</span><span class="comment">        University of Kansas, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==================================================================
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0e0, ONE = 1.0e0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      REAL               AA, BB, BETA, CC, CS, DD, EVI, EVK, FOO, S,
     $                   SAFMAX, SAFMIN, SMLNUM, SN, TAU, ULP
      INTEGER            I, IFST, ILST, INFO, INFQR, J, JW, K, KCOL,
     $                   KEND, KLN, KROW, KWTOP, LTOP, LWK1, LWK2, LWK3,
     $                   LWKOPT, NMIN
      LOGICAL            BULGE, SORTED
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      REAL               <a name="SLAMCH.170"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      INTEGER            <a name="ILAENV.171"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      EXTERNAL           <a name="SLAMCH.172"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="ILAENV.172"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           SCOPY, <a name="SGEHRD.175"></a><a href="sgehrd.f.html#SGEHRD.1">SGEHRD</a>, SGEMM, <a name="SLABAD.175"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>, <a name="SLACPY.175"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>, <a name="SLAHQR.175"></a><a href="slahqr.f.html#SLAHQR.1">SLAHQR</a>,
     $                   <a name="SLANV2.176"></a><a href="slanv2.f.html#SLANV2.1">SLANV2</a>, <a name="SLAQR4.176"></a><a href="slaqr4.f.html#SLAQR4.1">SLAQR4</a>, <a name="SLARF.176"></a><a href="slarf.f.html#SLARF.1">SLARF</a>, <a name="SLARFG.176"></a><a href="slarfg.f.html#SLARFG.1">SLARFG</a>, <a name="SLASET.176"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SORGHR.176"></a><a href="sorghr.f.html#SORGHR.1">SORGHR</a>,
     $                   <a name="STREXC.177"></a><a href="strexc.f.html#STREXC.1">STREXC</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, INT, MAX, MIN, REAL, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Estimate optimal workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>      JW = MIN( NW, KBOT-KTOP+1 )
      IF( JW.LE.2 ) THEN
         LWKOPT = 1
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Workspace query call to <a name="SGEHRD.191"></a><a href="sgehrd.f.html#SGEHRD.1">SGEHRD</a> ====
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGEHRD.193"></a><a href="sgehrd.f.html#SGEHRD.1">SGEHRD</a>( JW, 1, JW-1, T, LDT, WORK, WORK, -1, INFO )
         LWK1 = INT( WORK( 1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Workspace query call to <a name="SORGHR.196"></a><a href="sorghr.f.html#SORGHR.1">SORGHR</a> ====
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORGHR.198"></a><a href="sorghr.f.html#SORGHR.1">SORGHR</a>( JW, 1, JW-1, T, LDT, WORK, WORK, -1, INFO )
         LWK2 = INT( WORK( 1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Workspace query call to <a name="SLAQR4.201"></a><a href="slaqr4.f.html#SLAQR4.1">SLAQR4</a> ====
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLAQR4.203"></a><a href="slaqr4.f.html#SLAQR4.1">SLAQR4</a>( .true., .true., JW, 1, JW, T, LDT, SR, SI, 1, JW,
     $                V, LDV, WORK, -1, INFQR )
         LWK3 = INT( WORK( 1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Optimal workspace ====
</span><span class="comment">*</span><span class="comment">
</span>         LWKOPT = MAX( JW+MAX( LWK1, LWK2 ), LWK3 )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Quick return in case of workspace query. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( LWORK.EQ.-1 ) THEN
         WORK( 1 ) = REAL( LWKOPT )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Nothing to do ...
</span><span class="comment">*</span><span class="comment">     ... for an empty active block ... ====
</span>      NS = 0
      ND = 0
      IF( KTOP.GT.KBOT )
     $   RETURN
<span class="comment">*</span><span class="comment">     ... nor for an empty deflation window. ====
</span>      IF( NW.LT.1 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Machine constants ====
</span><span class="comment">*</span><span class="comment">
</span>      SAFMIN = <a name="SLAMCH.231"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'SAFE MINIMUM'</span> )
      SAFMAX = ONE / SAFMIN
      CALL <a name="SLABAD.233"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SAFMIN, SAFMAX )
      ULP = <a name="SLAMCH.234"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'PRECISION'</span> )
      SMLNUM = SAFMIN*( REAL( N ) / ULP )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Setup deflation window ====
</span><span class="comment">*</span><span class="comment">
</span>      JW = MIN( NW, KBOT-KTOP+1 )
      KWTOP = KBOT - JW + 1
      IF( KWTOP.EQ.KTOP ) THEN
         S = ZERO
      ELSE
         S = H( KWTOP, KWTOP-1 )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( KBOT.EQ.KWTOP ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== 1-by-1 deflation window: not much to do ====
</span><span class="comment">*</span><span class="comment">
</span>         SR( KWTOP ) = H( KWTOP, KWTOP )
         SI( KWTOP ) = ZERO
         NS = 1
         ND = 0
         IF( ABS( S ).LE.MAX( SMLNUM, ULP*ABS( H( KWTOP, KWTOP ) ) ) )
     $        THEN
            NS = 0
            ND = 1
            IF( KWTOP.GT.KTOP )
     $         H( KWTOP, KWTOP-1 ) = ZERO
         END IF
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Convert to spike-triangular form.  (In case of a
</span><span class="comment">*</span><span class="comment">     .    rare QR failure, this routine continues to do
</span><span class="comment">*</span><span class="comment">     .    aggressive early deflation using that part of
</span><span class="comment">*</span><span class="comment">     .    the deflation window that converged using INFQR
</span><span class="comment">*</span><span class="comment">     .    here and there to keep track.) ====
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="SLACPY.271"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, JW, JW, H( KWTOP, KWTOP ), LDH, T, LDT )
      CALL SCOPY( JW-1, H( KWTOP+1, KWTOP ), LDH+1, T( 2, 1 ), LDT+1 )
<span class="comment">*</span><span class="comment">
</span>      CALL <a name="SLASET.274"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'A'</span>, JW, JW, ZERO, ONE, V, LDV )
      NMIN = <a name="ILAENV.275"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 12, <span class="string">'<a name="SLAQR3.275"></a><a href="slaqr3.f.html#SLAQR3.1">SLAQR3</a>'</span>, <span class="string">'SV'</span>, JW, 1, JW, LWORK )
      IF( JW.GT.NMIN ) THEN
         CALL <a name="SLAQR4.277"></a><a href="slaqr4.f.html#SLAQR4.1">SLAQR4</a>( .true., .true., JW, 1, JW, T, LDT, SR( KWTOP ),
     $                SI( KWTOP ), 1, JW, V, LDV, WORK, LWORK, INFQR )
      ELSE
         CALL <a name="SLAHQR.280"></a><a href="slahqr.f.html#SLAHQR.1">SLAHQR</a>( .true., .true., JW, 1, JW, T, LDT, SR( KWTOP ),
     $                SI( KWTOP ), 1, JW, V, LDV, INFQR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== <a name="STREXC.284"></a><a href="strexc.f.html#STREXC.1">STREXC</a> needs a clean margin near the diagonal ====
</span><span class="comment">*</span><span class="comment">
</span>      DO 10 J = 1, JW - 3
         T( J+2, J ) = ZERO
         T( J+3, J ) = ZERO
   10 CONTINUE
      IF( JW.GT.2 )
     $   T( JW, JW-2 ) = ZERO
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Deflation detection loop ====
</span><span class="comment">*</span><span class="comment">
</span>      NS = JW
      ILST = INFQR + 1
   20 CONTINUE
      IF( ILST.LE.NS ) THEN
         IF( NS.EQ.1 ) THEN
            BULGE = .FALSE.
         ELSE
            BULGE = T( NS, NS-1 ).NE.ZERO
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Small spike tip test for deflation ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( .NOT.BULGE ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Real eigenvalue ====
</span><span class="comment">*</span><span class="comment">
</span>            FOO = ABS( T( NS, NS ) )
            IF( FOO.EQ.ZERO )
     $         FOO = ABS( S )
            IF( ABS( S*V( 1, NS ) ).LE.MAX( SMLNUM, ULP*FOO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Deflatable ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = NS - 1
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Undeflatable.   Move it up out of the way.
</span><span class="comment">*</span><span class="comment">              .    (<a name="STREXC.322"></a><a href="strexc.f.html#STREXC.1">STREXC</a> can not fail in this case.) ====
</span><span class="comment">*</span><span class="comment">
</span>               IFST = NS
               CALL <a name="STREXC.325"></a><a href="strexc.f.html#STREXC.1">STREXC</a>( <span class="string">'V'</span>, JW, T, LDT, V, LDV, IFST, ILST, WORK,
     $                      INFO )
               ILST = ILST + 1
            END IF
         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Complex conjugate pair ====
</span><span class="comment">*</span><span class="comment">
</span>            FOO = ABS( T( NS, NS ) ) + SQRT( ABS( T( NS, NS-1 ) ) )*
     $            SQRT( ABS( T( NS-1, NS ) ) )
            IF( FOO.EQ.ZERO )
     $         FOO = ABS( S )
            IF( MAX( ABS( S*V( 1, NS ) ), ABS( S*V( 1, NS-1 ) ) ).LE.
     $          MAX( SMLNUM, ULP*FOO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Deflatable ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = NS - 2
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Undflatable. Move them up out of the way.
</span><span class="comment">*</span><span class="comment">              .    Fortunately, <a name="STREXC.346"></a><a href="strexc.f.html#STREXC.1">STREXC</a> does the right thing with
</span><span class="comment">*</span><span class="comment">              .    ILST in case of a rare exchange failure. ====
</span><span class="comment">*</span><span class="comment">
</span>               IFST = NS
               CALL <a name="STREXC.350"></a><a href="strexc.f.html#STREXC.1">STREXC</a>( <span class="string">'V'</span>, JW, T, LDT, V, LDV, IFST, ILST, WORK,
     $                      INFO )
               ILST = ILST + 2
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== End deflation detection loop ====
</span><span class="comment">*</span><span class="comment">
</span>         GO TO 20
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Return to Hessenberg form ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( NS.EQ.0 )
     $   S = ZERO
<span class="comment">*</span><span class="comment">
</span>      IF( NS.LT.JW ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== sorting diagonal blocks of T improves accuracy for
</span><span class="comment">*</span><span class="comment">        .    graded matrices.  Bubble sort deals well with
</span><span class="comment">*</span><span class="comment">        .    exchange failures. ====
</span><span class="comment">*</span><span class="comment">
</span>         SORTED = .false.
         I = NS + 1
   30    CONTINUE
         IF( SORTED )
     $      GO TO 50
         SORTED = .true.
<span class="comment">*</span><span class="comment">
</span>         KEND = I - 1
         I = INFQR + 1
         IF( I.EQ.NS ) THEN
            K = I + 1
         ELSE IF( T( I+1, I ).EQ.ZERO ) THEN
            K = I + 1
         ELSE
            K = I + 2
         END IF
   40    CONTINUE
         IF( K.LE.KEND ) THEN
            IF( K.EQ.I+1 ) THEN
               EVI = ABS( T( I, I ) )
            ELSE
               EVI = ABS( T( I, I ) ) + SQRT( ABS( T( I+1, I ) ) )*
     $               SQRT( ABS( T( I, I+1 ) ) )
            END IF
<span class="comment">*</span><span class="comment">
</span>            IF( K.EQ.KEND ) THEN
               EVK = ABS( T( K, K ) )
            ELSE IF( T( K+1, K ).EQ.ZERO ) THEN
               EVK = ABS( T( K, K ) )
            ELSE
               EVK = ABS( T( K, K ) ) + SQRT( ABS( T( K+1, K ) ) )*
     $               SQRT( ABS( T( K, K+1 ) ) )
            END IF
<span class="comment">*</span><span class="comment">
</span>            IF( EVI.GE.EVK ) THEN
               I = K
            ELSE
               SORTED = .false.
               IFST = I
               ILST = K
               CALL <a name="STREXC.412"></a><a href="strexc.f.html#STREXC.1">STREXC</a>( <span class="string">'V'</span>, JW, T, LDT, V, LDV, IFST, ILST, WORK,
     $                      INFO )
               IF( INFO.EQ.0 ) THEN
                  I = ILST
               ELSE
                  I = K
               END IF
            END IF
            IF( I.EQ.KEND ) THEN
               K = I + 1
            ELSE IF( T( I+1, I ).EQ.ZERO ) THEN
               K = I + 1
            ELSE
               K = I + 2
            END IF
            GO TO 40
         END IF
         GO TO 30
   50    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Restore shift/eigenvalue array from T ====
</span><span class="comment">*</span><span class="comment">
</span>      I = JW
   60 CONTINUE
      IF( I.GE.INFQR+1 ) THEN
         IF( I.EQ.INFQR+1 ) THEN
            SR( KWTOP+I-1 ) = T( I, I )
            SI( KWTOP+I-1 ) = ZERO
            I = I - 1
         ELSE IF( T( I, I-1 ).EQ.ZERO ) THEN
            SR( KWTOP+I-1 ) = T( I, I )
            SI( KWTOP+I-1 ) = ZERO
            I = I - 1
         ELSE
            AA = T( I-1, I-1 )
            CC = T( I, I-1 )
            BB = T( I-1, I )
            DD = T( I, I )
            CALL <a name="SLANV2.451"></a><a href="slanv2.f.html#SLANV2.1">SLANV2</a>( AA, BB, CC, DD, SR( KWTOP+I-2 ),
     $                   SI( KWTOP+I-2 ), SR( KWTOP+I-1 ),
     $                   SI( KWTOP+I-1 ), CS, SN )
            I = I - 2
         END IF
         GO TO 60
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( NS.LT.JW .OR. S.EQ.ZERO ) THEN
         IF( NS.GT.1 .AND. S.NE.ZERO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Reflect spike back into lower triangle ====
</span><span class="comment">*</span><span class="comment">
</span>            CALL SCOPY( NS, V, LDV, WORK, 1 )
            BETA = WORK( 1 )
            CALL <a name="SLARFG.466"></a><a href="slarfg.f.html#SLARFG.1">SLARFG</a>( NS, BETA, WORK( 2 ), 1, TAU )
            WORK( 1 ) = ONE
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="SLASET.469"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, JW-2, JW-2, ZERO, ZERO, T( 3, 1 ), LDT )
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="SLARF.471"></a><a href="slarf.f.html#SLARF.1">SLARF</a>( <span class="string">'L'</span>, NS, JW, WORK, 1, TAU, T, LDT,
     $                  WORK( JW+1 ) )
            CALL <a name="SLARF.473"></a><a href="slarf.f.html#SLARF.1">SLARF</a>( <span class="string">'R'</span>, NS, NS, WORK, 1, TAU, T, LDT,
     $                  WORK( JW+1 ) )
            CALL <a name="SLARF.475"></a><a href="slarf.f.html#SLARF.1">SLARF</a>( <span class="string">'R'</span>, JW, NS, WORK, 1, TAU, V, LDV,
     $                  WORK( JW+1 ) )
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEHRD.478"></a><a href="sgehrd.f.html#SGEHRD.1">SGEHRD</a>( JW, 1, NS, T, LDT, WORK, WORK( JW+1 ),
     $                   LWORK-JW, INFO )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Copy updated reduced window into place ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( KWTOP.GT.1 )
     $      H( KWTOP, KWTOP-1 ) = S*V( 1, 1 )
         CALL <a name="SLACPY.486"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, JW, JW, T, LDT, H( KWTOP, KWTOP ), LDH )
         CALL SCOPY( JW-1, T( 2, 1 ), LDT+1, H( KWTOP+1, KWTOP ),
     $               LDH+1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Accumulate orthogonal matrix in order update
</span><span class="comment">*</span><span class="comment">        .    H and Z, if requested.  (A modified version
</span><span class="comment">*</span><span class="comment">        .    of  <a name="SORGHR.492"></a><a href="sorghr.f.html#SORGHR.1">SORGHR</a> that accumulates block Householder
</span><span class="comment">*</span><span class="comment">        .    transformations into V directly might be
</span><span class="comment">*</span><span class="comment">        .    marginally more efficient than the following.) ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( NS.GT.1 .AND. S.NE.ZERO ) THEN
            CALL <a name="SORGHR.497"></a><a href="sorghr.f.html#SORGHR.1">SORGHR</a>( JW, 1, NS, T, LDT, WORK, WORK( JW+1 ),
     $                   LWORK-JW, INFO )
            CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, JW, NS, NS, ONE, V, LDV, T, LDT, ZERO,
     $                  WV, LDWV )
            CALL <a name="SLACPY.501"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'A'</span>, JW, NS, WV, LDWV, V, LDV )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Update vertical slab in H ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( WANTT ) THEN
            LTOP = 1
         ELSE
            LTOP = KTOP
         END IF
         DO 70 KROW = LTOP, KWTOP - 1, NV
            KLN = MIN( NV, KWTOP-KROW )
            CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, KLN, JW, JW, ONE, H( KROW, KWTOP ),
     $                  LDH, V, LDV, ZERO, WV, LDWV )
            CALL <a name="SLACPY.515"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'A'</span>, KLN, JW, WV, LDWV, H( KROW, KWTOP ), LDH )
   70    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Update horizontal slab in H ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( WANTT ) THEN
            DO 80 KCOL = KBOT + 1, N, NH
               KLN = MIN( NH, N-KCOL+1 )
               CALL SGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, JW, KLN, JW, ONE, V, LDV,
     $                     H( KWTOP, KCOL ), LDH, ZERO, T, LDT )
               CALL <a name="SLACPY.525"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'A'</span>, JW, KLN, T, LDT, H( KWTOP, KCOL ),
     $                      LDH )
   80       CONTINUE
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Update vertical slab in Z ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( WANTZ ) THEN
            DO 90 KROW = ILOZ, IHIZ, NV
               KLN = MIN( NV, IHIZ-KROW+1 )
               CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, KLN, JW, JW, ONE, Z( KROW, KWTOP ),
     $                     LDZ, V, LDV, ZERO, WV, LDWV )
               CALL <a name="SLACPY.537"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'A'</span>, KLN, JW, WV, LDWV, Z( KROW, KWTOP ),
     $                      LDZ )
   90       CONTINUE
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Return the number of deflations ... ====
</span><span class="comment">*</span><span class="comment">
</span>      ND = JW - NS
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== ... and the number of shifts. (Subtracting
</span><span class="comment">*</span><span class="comment">     .    INFQR from the spike length takes care
</span><span class="comment">*</span><span class="comment">     .    of the case of a rare QR failure while
</span><span class="comment">*</span><span class="comment">     .    calculating eigenvalues of the deflation
</span><span class="comment">*</span><span class="comment">     .    window.)  ====
</span><span class="comment">*</span><span class="comment">
</span>      NS = NS - INFQR
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">      ==== Return optimal workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = REAL( LWKOPT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== End of <a name="SLAQR3.559"></a><a href="slaqr3.f.html#SLAQR3.1">SLAQR3</a> ====
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
