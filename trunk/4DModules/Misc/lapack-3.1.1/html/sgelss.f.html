<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>sgelss.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="SGELSS.1"></a><a href="sgelss.f.html#SGELSS.1">SGELSS</a>( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
     $                   WORK, LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
      REAL               RCOND
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               A( LDA, * ), B( LDB, * ), S( * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="SGELSS.19"></a><a href="sgelss.f.html#SGELSS.1">SGELSS</a> computes the minimum norm solution to a real linear least
</span><span class="comment">*</span><span class="comment">  squares problem:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Minimize 2-norm(| b - A*x |).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  using the singular value decomposition (SVD) of A. A is an M-by-N
</span><span class="comment">*</span><span class="comment">  matrix which may be rank-deficient.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Several right hand side vectors b and solution vectors x can be
</span><span class="comment">*</span><span class="comment">  handled in a single call; they are stored as the columns of the
</span><span class="comment">*</span><span class="comment">  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
</span><span class="comment">*</span><span class="comment">  X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The effective rank of A is determined by treating as zero those
</span><span class="comment">*</span><span class="comment">  singular values which are less than RCOND times the largest singular
</span><span class="comment">*</span><span class="comment">  value.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the matrix A. M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the matrix A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  NRHS    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of right hand sides, i.e., the number of columns
</span><span class="comment">*</span><span class="comment">          of the matrices B and X. NRHS &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) REAL array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, the first min(m,n) rows of A are overwritten with
</span><span class="comment">*</span><span class="comment">          its right singular vectors, stored rowwise.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) REAL array, dimension (LDB,NRHS)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-NRHS right hand side matrix B.
</span><span class="comment">*</span><span class="comment">          On exit, B is overwritten by the N-by-NRHS solution
</span><span class="comment">*</span><span class="comment">          matrix X.  If m &gt;= n and RANK = n, the residual
</span><span class="comment">*</span><span class="comment">          sum-of-squares for the solution in the i-th column is given
</span><span class="comment">*</span><span class="comment">          by the sum of squares of elements n+1:m in that column.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) REAL array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A in decreasing order.
</span><span class="comment">*</span><span class="comment">          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCOND   (input) REAL
</span><span class="comment">*</span><span class="comment">          RCOND is used to determine the effective rank of A.
</span><span class="comment">*</span><span class="comment">          Singular values S(i) &lt;= RCOND*S(1) are treated as zero.
</span><span class="comment">*</span><span class="comment">          If RCOND &lt; 0, machine precision is used instead.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RANK    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The effective rank of A, i.e., the number of singular values
</span><span class="comment">*</span><span class="comment">          which are greater than RCOND*S(1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= 1, and also:
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS )
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.91"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  the algorithm for computing the SVD failed to converge;
</span><span class="comment">*</span><span class="comment">                if INFO = i, i off-diagonal elements of an intermediate
</span><span class="comment">*</span><span class="comment">                bidiagonal form did not converge to zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY
      INTEGER            BDSPAC, BL, CHUNK, I, IASCL, IBSCL, IE, IL,
     $                   ITAU, ITAUP, ITAUQ, IWORK, LDWORK, MAXMN,
     $                   MAXWRK, MINMN, MINWRK, MM, MNTHR
      REAL               ANRM, BIGNUM, BNRM, EPS, SFMIN, SMLNUM, THR
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      REAL               VDUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="SBDSQR.117"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>, SCOPY, <a name="SGEBRD.117"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>, <a name="SGELQF.117"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>, SGEMM, SGEMV,
     $                   <a name="SGEQRF.118"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>, <a name="SLABAD.118"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>, <a name="SLACPY.118"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>, <a name="SLASCL.118"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="SLASET.118"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SORGBR.118"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>,
     $                   <a name="SORMBR.119"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>, <a name="SORMLQ.119"></a><a href="sormlq.f.html#SORMLQ.1">SORMLQ</a>, <a name="SORMQR.119"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>, <a name="SRSCL.119"></a><a href="srscl.f.html#SRSCL.1">SRSCL</a>, <a name="XERBLA.119"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.122"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="SLAMCH.123"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.123"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
      EXTERNAL           <a name="ILAENV.124"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="SLAMCH.124"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.124"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      MAXMN = MAX( M, N )
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, MAXMN ) ) THEN
         INFO = -7
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.154"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( MINMN.GT.0 ) THEN
            MM = M
            MNTHR = <a name="ILAENV.161"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="SGELSS.161"></a><a href="sgelss.f.html#SGELSS.1">SGELSS</a>'</span>, <span class="string">' '</span>, M, N, NRHS, -1 )
            IF( M.GE.N .AND. M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1a - overdetermined, with many more rows than
</span><span class="comment">*</span><span class="comment">                        columns
</span><span class="comment">*</span><span class="comment">
</span>               MM = N
               MAXWRK = MAX( MAXWRK, N + N*<a name="ILAENV.168"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.168"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M,
     $                       N, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, N + NRHS*<a name="ILAENV.170"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMQR.170"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>'</span>, <span class="string">'LT'</span>,
     $                       M, NRHS, N, -1 ) )
            END IF
            IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 - overdetermined or exactly determined
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute workspace needed for <a name="SBDSQR.177"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>               BDSPAC = MAX( 1, 5*N )
               MAXWRK = MAX( MAXWRK, 3*N + ( MM + N )*<a name="ILAENV.180"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="SGEBRD.181"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, MM, N, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, 3*N + NRHS*<a name="ILAENV.182"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.182"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>,
     $                       <span class="string">'QLT'</span>, MM, NRHS, N, -1 ) )
               MAXWRK = MAX( MAXWRK, 3*N + ( N - 1 )*<a name="ILAENV.184"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="SORGBR.185"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MAXWRK = MAX( MAXWRK, N*NRHS )
               MINWRK = MAX( 3*N + MM, 3*N + NRHS, BDSPAC )
               MAXWRK = MAX( MINWRK, MAXWRK )
            END IF
            IF( N.GT.M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute workspace needed for <a name="SBDSQR.193"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>               BDSPAC = MAX( 1, 5*M )
               MINWRK = MAX( 3*M+NRHS, 3*M+N, BDSPAC )
               IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2a - underdetermined, with many more columns
</span><span class="comment">*</span><span class="comment">                 than rows
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.202"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.202"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                                  -1 )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + 2*M*<a name="ILAENV.204"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="SGEBRD.205"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M + NRHS*<a name="ILAENV.206"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="SORMBR.207"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>, <span class="string">'QLT'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, M*M + 4*M +
     $                          ( M - 1 )*<a name="ILAENV.209"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.209"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M,
     $                          M, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, M*M + M + BDSPAC )
                  IF( NRHS.GT.1 ) THEN
                     MAXWRK = MAX( MAXWRK, M*M + M + M*NRHS )
                  ELSE
                     MAXWRK = MAX( MAXWRK, M*M + 2*M )
                  END IF
                  MAXWRK = MAX( MAXWRK, M + NRHS*<a name="ILAENV.217"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMLQ.217"></a><a href="sormlq.f.html#SORMLQ.1">SORMLQ</a>'</span>,
     $                          <span class="string">'LT'</span>, N, NRHS, M, -1 ) )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 - underdetermined
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = 3*M + ( N + M )*<a name="ILAENV.223"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.223"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M,
     $                     N, -1, -1 )
                  MAXWRK = MAX( MAXWRK, 3*M + NRHS*<a name="ILAENV.225"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMBR.225"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>'</span>,
     $                          <span class="string">'QLT'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 3*M + M*<a name="ILAENV.227"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.227"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>,
     $                          <span class="string">'P'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MAXWRK = MAX( MAXWRK, N*NRHS )
               END IF
            END IF
            MAXWRK = MAX( MINWRK, MAXWRK )
         END IF
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY )
     $      INFO = -12
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.242"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="SGELSS.242"></a><a href="sgelss.f.html#SGELSS.1">SGELSS</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RANK = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine parameters
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.257"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SFMIN = <a name="SLAMCH.258"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      SMLNUM = SFMIN / EPS
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.261"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="SLANGE.265"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, WORK )
      IASCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASCL.271"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, INFO )
         IASCL = 1
      ELSE IF( ANRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASCL.277"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, INFO )
         IASCL = 2
      ELSE IF( ANRM.EQ.ZERO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Matrix all zero. Return zero solution.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASET.283"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, MAX( M, N ), NRHS, ZERO, ZERO, B, LDB )
         CALL <a name="SLASET.284"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, MINMN, 1, ZERO, ZERO, S, 1 )
         RANK = 0
         GO TO 70
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="SLANGE.291"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, M, NRHS, B, LDB, WORK )
      IBSCL = 0
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASCL.297"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, SMLNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 1
      ELSE IF( BNRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASCL.303"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BIGNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 2
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Overdetermined case
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 1 - overdetermined or exactly determined
</span><span class="comment">*</span><span class="comment">
</span>         MM = M
         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1a - overdetermined, with many more rows than columns
</span><span class="comment">*</span><span class="comment">
</span>            MM = N
            ITAU = 1
            IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute A=Q*R
</span><span class="comment">*</span><span class="comment">           (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEQRF.325"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                   LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Multiply B by transpose(Q)
</span><span class="comment">*</span><span class="comment">           (Workspace: need N+NRHS, prefer N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SORMQR.331"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>( <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, N, A, LDA, WORK( ITAU ), B,
     $                   LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>            IF( N.GT.1 )
     $         CALL <a name="SLASET.337"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
         END IF
<span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = IE + N
         ITAUP = ITAUQ + N
         IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*N+MM, prefer 3*N+(MM+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGEBRD.348"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( MM, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of R
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*N+NRHS, prefer 3*N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORMBR.355"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, MM, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors of R in A
</span><span class="comment">*</span><span class="comment">        (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORGBR.361"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration
</span><span class="comment">*</span><span class="comment">          multiply B by transpose of left singular vectors
</span><span class="comment">*</span><span class="comment">          compute right singular vectors in A
</span><span class="comment">*</span><span class="comment">        (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SBDSQR.370"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, 0, NRHS, S, WORK( IE ), A, LDA, VDUM,
     $                1, B, LDB, WORK( IWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 10 I = 1, N
            IF( S( I ).GT.THR ) THEN
               CALL <a name="SRSCL.383"></a><a href="srscl.f.html#SRSCL.1">SRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="SLASET.386"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, 1, NRHS, ZERO, ZERO, B( I, 1 ), LDB )
            END IF
   10    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors
</span><span class="comment">*</span><span class="comment">        (Workspace: need N, prefer N*NRHS)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS .AND. NRHS.GT.1 ) THEN
            CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, N, NRHS, N, ONE, A, LDA, B, LDB, ZERO,
     $                  WORK, LDB )
            CALL <a name="SLACPY.396"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'G'</span>, N, NRHS, WORK, LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = LWORK / N
            DO 20 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, N, BL, N, ONE, A, LDA, B( 1, I ),
     $                     LDB, ZERO, WORK, N )
               CALL <a name="SLACPY.403"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'G'</span>, N, BL, WORK, N, B( 1, I ), LDB )
   20       CONTINUE
         ELSE
            CALL SGEMV( <span class="string">'T'</span>, N, N, ONE, A, LDA, B, 1, ZERO, WORK, 1 )
            CALL SCOPY( N, WORK, 1, B, 1 )
         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( N.GE.MNTHR .AND. LWORK.GE.4*M+M*M+
     $         MAX( M, 2*M-4, NRHS, N-3*M ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2a - underdetermined, with many more columns than rows
</span><span class="comment">*</span><span class="comment">        and sufficient workspace for an efficient algorithm
</span><span class="comment">*</span><span class="comment">
</span>         LDWORK = M
         IF( LWORK.GE.MAX( 4*M+M*LDA+MAX( M, 2*M-4, NRHS, N-3*M ),
     $       M*LDA+M+M*NRHS ) )LDWORK = LDA
         ITAU = 1
         IWORK = M + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute A=L*Q
</span><span class="comment">*</span><span class="comment">        (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGELQF.425"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
         IL = IWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Copy L to WORK(IL), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLACPY.431"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWORK )
         CALL <a name="SLASET.432"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, WORK( IL+LDWORK ),
     $                LDWORK )
         IE = IL + LDWORK*M
         ITAUQ = IE + M
         ITAUP = ITAUQ + M
         IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+5*M, prefer M*M+4*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGEBRD.442"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IL ), LDWORK, S, WORK( IE ),
     $                WORK( ITAUQ ), WORK( ITAUP ), WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of L
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORMBR.449"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUQ ), B, LDB, WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors of R in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+5*M-1, prefer M*M+4*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORGBR.456"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IL ), LDWORK, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration,
</span><span class="comment">*</span><span class="comment">           computing right singular vectors of L in WORK(IL) and
</span><span class="comment">*</span><span class="comment">           multiplying B by transpose of left singular vectors
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SBDSQR.465"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, 0, NRHS, S, WORK( IE ), WORK( IL ),
     $                LDWORK, A, LDA, B, LDB, WORK( IWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 30 I = 1, M
            IF( S( I ).GT.THR ) THEN
               CALL <a name="SRSCL.478"></a><a href="srscl.f.html#SRSCL.1">SRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="SLASET.481"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, 1, NRHS, ZERO, ZERO, B( I, 1 ), LDB )
            END IF
   30    CONTINUE
         IWORK = IE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors of L in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+2*M, prefer M*M+M+M*NRHS)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS+IWORK-1 .AND. NRHS.GT.1 ) THEN
            CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, M, NRHS, M, ONE, WORK( IL ), LDWORK,
     $                  B, LDB, ZERO, WORK( IWORK ), LDB )
            CALL <a name="SLACPY.492"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'G'</span>, M, NRHS, WORK( IWORK ), LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = ( LWORK-IWORK+1 ) / M
            DO 40 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, M, BL, M, ONE, WORK( IL ), LDWORK,
     $                     B( 1, I ), LDB, ZERO, WORK( IWORK ), M )
               CALL <a name="SLACPY.499"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'G'</span>, M, BL, WORK( IWORK ), M, B( 1, I ),
     $                      LDB )
   40       CONTINUE
         ELSE
            CALL SGEMV( <span class="string">'T'</span>, M, M, ONE, WORK( IL ), LDWORK, B( 1, 1 ),
     $                  1, ZERO, WORK( IWORK ), 1 )
            CALL SCOPY( M, WORK( IWORK ), 1, B( 1, 1 ), 1 )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Zero out below first M rows of B
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SLASET.510"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, N-M, NRHS, ZERO, ZERO, B( M+1, 1 ), LDB )
         IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply transpose(Q) by B
</span><span class="comment">*</span><span class="comment">        (Workspace: need M+NRHS, prefer M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORMLQ.516"></a><a href="sormlq.f.html#SORMLQ.1">SORMLQ</a>( <span class="string">'L'</span>, <span class="string">'T'</span>, N, NRHS, M, A, LDA, WORK( ITAU ), B,
     $                LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2 - remaining underdetermined cases
</span><span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = IE + M
         ITAUP = ITAUQ + M
         IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize A
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGEBRD.531"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*M+NRHS, prefer 3*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORMBR.538"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">        (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SORGBR.544"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration,
</span><span class="comment">*</span><span class="comment">           computing right singular vectors of A in A and
</span><span class="comment">*</span><span class="comment">           multiplying B by transpose of left singular vectors
</span><span class="comment">*</span><span class="comment">        (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SBDSQR.553"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'L'</span>, M, N, 0, NRHS, S, WORK( IE ), A, LDA, VDUM,
     $                1, B, LDB, WORK( IWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 50 I = 1, M
            IF( S( I ).GT.THR ) THEN
               CALL <a name="SRSCL.566"></a><a href="srscl.f.html#SRSCL.1">SRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="SLASET.569"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, 1, NRHS, ZERO, ZERO, B( I, 1 ), LDB )
            END IF
   50    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors of A
</span><span class="comment">*</span><span class="comment">        (Workspace: need N, prefer N*NRHS)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS .AND. NRHS.GT.1 ) THEN
            CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, N, NRHS, M, ONE, A, LDA, B, LDB, ZERO,
     $                  WORK, LDB )
            CALL <a name="SLACPY.579"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, NRHS, WORK, LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = LWORK / N
            DO 60 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL SGEMM( <span class="string">'T'</span>, <span class="string">'N'</span>, N, BL, M, ONE, A, LDA, B( 1, I ),
     $                     LDB, ZERO, WORK, N )
               CALL <a name="SLACPY.586"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, BL, WORK, N, B( 1, I ), LDB )
   60       CONTINUE
         ELSE
            CALL SGEMV( <span class="string">'T'</span>, M, N, ONE, A, LDA, B, 1, ZERO, WORK, 1 )
            CALL SCOPY( N, WORK, 1, B, 1 )
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling
</span><span class="comment">*</span><span class="comment">
</span>      IF( IASCL.EQ.1 ) THEN
         CALL <a name="SLASCL.597"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.598"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      ELSE IF( IASCL.EQ.2 ) THEN
         CALL <a name="SLASCL.601"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.602"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      END IF
      IF( IBSCL.EQ.1 ) THEN
         CALL <a name="SLASCL.606"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, BNRM, N, NRHS, B, LDB, INFO )
      ELSE IF( IBSCL.EQ.2 ) THEN
         CALL <a name="SLASCL.608"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, BNRM, N, NRHS, B, LDB, INFO )
      END IF
<span class="comment">*</span><span class="comment">
</span>   70 CONTINUE
      WORK( 1 ) = MAXWRK
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="SGELSS.615"></a><a href="sgelss.f.html#SGELSS.1">SGELSS</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
