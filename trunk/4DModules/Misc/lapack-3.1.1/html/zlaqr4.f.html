<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>zlaqr4.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="ZLAQR4.1"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
     $                   IHIZ, Z, LDZ, WORK, LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK auxiliary routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            IHI, IHIZ, ILO, ILOZ, INFO, LDH, LDZ, LWORK, N
      LOGICAL            WANTT, WANTZ
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      COMPLEX*16         H( LDH, * ), W( * ), WORK( * ), Z( LDZ, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     This subroutine implements one level of recursion for <a name="ZLAQR0.16"></a><a href="zlaqr0.f.html#ZLAQR0.1">ZLAQR0</a>.
</span><span class="comment">*</span><span class="comment">     It is a complete implementation of the small bulge multi-shift
</span><span class="comment">*</span><span class="comment">     QR algorithm.  It may be called by <a name="ZLAQR0.18"></a><a href="zlaqr0.f.html#ZLAQR0.1">ZLAQR0</a> and, for large enough
</span><span class="comment">*</span><span class="comment">     deflation window size, it may be called by <a name="ZLAQR3.19"></a><a href="zlaqr3.f.html#ZLAQR3.1">ZLAQR3</a>.  This
</span><span class="comment">*</span><span class="comment">     subroutine is identical to <a name="ZLAQR0.20"></a><a href="zlaqr0.f.html#ZLAQR0.1">ZLAQR0</a> except that it calls <a name="ZLAQR2.20"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>
</span><span class="comment">*</span><span class="comment">     instead of <a name="ZLAQR3.21"></a><a href="zlaqr3.f.html#ZLAQR3.1">ZLAQR3</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Purpose
</span><span class="comment">*</span><span class="comment">     =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     <a name="ZLAQR4.26"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a> computes the eigenvalues of a Hessenberg matrix H
</span><span class="comment">*</span><span class="comment">     and, optionally, the matrices T and Z from the Schur decomposition
</span><span class="comment">*</span><span class="comment">     H = Z T Z**H, where T is an upper triangular matrix (the
</span><span class="comment">*</span><span class="comment">     Schur form), and Z is the unitary matrix of Schur vectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Optionally Z may be postmultiplied into an input unitary
</span><span class="comment">*</span><span class="comment">     matrix Q so that this routine can give the Schur factorization
</span><span class="comment">*</span><span class="comment">     of a matrix A which has been reduced to the Hessenberg form H
</span><span class="comment">*</span><span class="comment">     by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Arguments
</span><span class="comment">*</span><span class="comment">     =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WANTT   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          = .TRUE. : the full Schur form T is required;
</span><span class="comment">*</span><span class="comment">          = .FALSE.: only eigenvalues are required.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WANTZ   (input) LOGICAL
</span><span class="comment">*</span><span class="comment">          = .TRUE. : the matrix of Schur vectors Z is required;
</span><span class="comment">*</span><span class="comment">          = .FALSE.: Schur vectors are not required.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     N     (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The order of the matrix H.  N .GE. 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ILO   (input) INTEGER
</span><span class="comment">*</span><span class="comment">     IHI   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           It is assumed that H is already upper triangular in rows
</span><span class="comment">*</span><span class="comment">           and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
</span><span class="comment">*</span><span class="comment">           H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
</span><span class="comment">*</span><span class="comment">           previous call to <a name="ZGEBAL.55"></a><a href="zgebal.f.html#ZGEBAL.1">ZGEBAL</a>, and then passed to <a name="ZGEHRD.55"></a><a href="zgehrd.f.html#ZGEHRD.1">ZGEHRD</a> when the
</span><span class="comment">*</span><span class="comment">           matrix output by <a name="ZGEBAL.56"></a><a href="zgebal.f.html#ZGEBAL.1">ZGEBAL</a> is reduced to Hessenberg form.
</span><span class="comment">*</span><span class="comment">           Otherwise, ILO and IHI should be set to 1 and N,
</span><span class="comment">*</span><span class="comment">           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
</span><span class="comment">*</span><span class="comment">           If N = 0, then ILO = 1 and IHI = 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     H     (input/output) COMPLEX*16 array, dimension (LDH,N)
</span><span class="comment">*</span><span class="comment">           On entry, the upper Hessenberg matrix H.
</span><span class="comment">*</span><span class="comment">           On exit, if INFO = 0 and WANTT is .TRUE., then H
</span><span class="comment">*</span><span class="comment">           contains the upper triangular matrix T from the Schur
</span><span class="comment">*</span><span class="comment">           decomposition (the Schur form). If INFO = 0 and WANT is
</span><span class="comment">*</span><span class="comment">           .FALSE., then the contents of H are unspecified on exit.
</span><span class="comment">*</span><span class="comment">           (The output value of H when INFO.GT.0 is given under the
</span><span class="comment">*</span><span class="comment">           description of INFO below.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
</span><span class="comment">*</span><span class="comment">           j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDH   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The leading dimension of the array H. LDH .GE. max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     W        (output) COMPLEX*16 array, dimension (N)
</span><span class="comment">*</span><span class="comment">           The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
</span><span class="comment">*</span><span class="comment">           in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
</span><span class="comment">*</span><span class="comment">           stored in the same order as on the diagonal of the Schur
</span><span class="comment">*</span><span class="comment">           form returned in H, with W(i) = H(i,i).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Z     (input/output) COMPLEX*16 array, dimension (LDZ,IHI)
</span><span class="comment">*</span><span class="comment">           If WANTZ is .FALSE., then Z is not referenced.
</span><span class="comment">*</span><span class="comment">           If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
</span><span class="comment">*</span><span class="comment">           replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
</span><span class="comment">*</span><span class="comment">           orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
</span><span class="comment">*</span><span class="comment">           (The output value of Z when INFO.GT.0 is given under
</span><span class="comment">*</span><span class="comment">           the description of INFO below.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LDZ   (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The leading dimension of the array Z.  if WANTZ is .TRUE.
</span><span class="comment">*</span><span class="comment">           then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     WORK  (workspace/output) COMPLEX*16 array, dimension LWORK
</span><span class="comment">*</span><span class="comment">           On exit, if LWORK = -1, WORK(1) returns an estimate of
</span><span class="comment">*</span><span class="comment">           the optimal value for LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     LWORK (input) INTEGER
</span><span class="comment">*</span><span class="comment">           The dimension of the array WORK.  LWORK .GE. max(1,N)
</span><span class="comment">*</span><span class="comment">           is sufficient, but LWORK typically as large as 6*N may
</span><span class="comment">*</span><span class="comment">           be required for optimal performance.  A workspace query
</span><span class="comment">*</span><span class="comment">           to determine the optimal workspace size is recommended.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           If LWORK = -1, then <a name="ZLAQR4.104"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a> does a workspace query.
</span><span class="comment">*</span><span class="comment">           In this case, <a name="ZLAQR4.105"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a> checks the input parameters and
</span><span class="comment">*</span><span class="comment">           estimates the optimal workspace size for the given
</span><span class="comment">*</span><span class="comment">           values of N, ILO and IHI.  The estimate is returned
</span><span class="comment">*</span><span class="comment">           in WORK(1).  No error message related to LWORK is
</span><span class="comment">*</span><span class="comment">           issued by <a name="XERBLA.109"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.  Neither H nor Z are accessed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     INFO  (output) INTEGER
</span><span class="comment">*</span><span class="comment">             =  0:  successful exit
</span><span class="comment">*</span><span class="comment">           .GT. 0:  if INFO = i, <a name="ZLAQR4.114"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a> failed to compute all of
</span><span class="comment">*</span><span class="comment">                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
</span><span class="comment">*</span><span class="comment">                and WI contain those eigenvalues which have been
</span><span class="comment">*</span><span class="comment">                successfully computed.  (Failures are rare.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANT is .FALSE., then on exit,
</span><span class="comment">*</span><span class="comment">                the remaining unconverged eigenvalues are the eigen-
</span><span class="comment">*</span><span class="comment">                values of the upper Hessenberg matrix rows and
</span><span class="comment">*</span><span class="comment">                columns ILO through INFO of the final, output
</span><span class="comment">*</span><span class="comment">                value of H.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTT is .TRUE., then on exit
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           (*)  (initial value of H)*U  = U*(final value of H)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                where U is a unitary matrix.  The final
</span><span class="comment">*</span><span class="comment">                value of  H is upper Hessenberg and triangular in
</span><span class="comment">*</span><span class="comment">                rows and columns INFO+1 through IHI.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTZ is .TRUE., then on exit
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                  (final value of Z(ILO:IHI,ILOZ:IHIZ)
</span><span class="comment">*</span><span class="comment">                   =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                where U is the unitary matrix in (*) (regard-
</span><span class="comment">*</span><span class="comment">                less of the value of WANTT.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
</span><span class="comment">*</span><span class="comment">                accessed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     Based on contributions by
</span><span class="comment">*</span><span class="comment">        Karen Braman and Ralph Byers, Department of Mathematics,
</span><span class="comment">*</span><span class="comment">        University of Kansas, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     References:
</span><span class="comment">*</span><span class="comment">       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
</span><span class="comment">*</span><span class="comment">       Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
</span><span class="comment">*</span><span class="comment">       Performance, SIAM Journal of Matrix Analysis, volume 23, pages
</span><span class="comment">*</span><span class="comment">       929--947, 2002.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
</span><span class="comment">*</span><span class="comment">       Algorithm Part II: Aggressive Early Deflation, SIAM Journal
</span><span class="comment">*</span><span class="comment">       of Matrix Analysis, volume 23, pages 948--973, 2002.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ================================================================
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Matrices of order NTINY or smaller must be processed by
</span><span class="comment">*</span><span class="comment">     .    <a name="ZLAHQR.164"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a> because of insufficient subdiagonal scratch space.
</span><span class="comment">*</span><span class="comment">     .    (This is a hard limit.) ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Exceptional deflation windows:  try to cure rare
</span><span class="comment">*</span><span class="comment">     .    slow convergence by increasing the size of the
</span><span class="comment">*</span><span class="comment">     .    deflation window after KEXNW iterations. =====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Exceptional shifts: try to cure rare slow convergence
</span><span class="comment">*</span><span class="comment">     .    with ad-hoc exceptional shifts every KEXSH iterations.
</span><span class="comment">*</span><span class="comment">     .    The constants WILK1 and WILK2 are used to form the
</span><span class="comment">*</span><span class="comment">     .    exceptional shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>      INTEGER            NTINY
      PARAMETER          ( NTINY = 11 )
      INTEGER            KEXNW, KEXSH
      PARAMETER          ( KEXNW = 5, KEXSH = 6 )
      DOUBLE PRECISION   WILK1
      PARAMETER          ( WILK1 = 0.75d0 )
      COMPLEX*16         ZERO, ONE
      PARAMETER          ( ZERO = ( 0.0d0, 0.0d0 ),
     $                   ONE = ( 1.0d0, 0.0d0 ) )
      DOUBLE PRECISION   TWO
      PARAMETER          ( TWO = 2.0d0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      COMPLEX*16         AA, BB, CC, CDUM, DD, DET, RTDISC, SWAP, TR2
      DOUBLE PRECISION   S
      INTEGER            I, INF, IT, ITMAX, K, KACC22, KBOT, KDU, KS,
     $                   KT, KTOP, KU, KV, KWH, KWTOP, KWV, LD, LS,
     $                   LWKOPT, NDFL, NH, NHO, NIBBLE, NMIN, NS, NSMAX,
     $                   NSR, NVE, NW, NWMAX, NWR
      LOGICAL            NWINC, SORTED
      CHARACTER          JBCMPZ*2
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.199"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      EXTERNAL           <a name="ILAENV.200"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      COMPLEX*16         ZDUM( 1, 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="ZLACPY.206"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>, <a name="ZLAHQR.206"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>, <a name="ZLAQR2.206"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>, <a name="ZLAQR5.206"></a><a href="zlaqr5.f.html#ZLAQR5.1">ZLAQR5</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, DBLE, DCMPLX, DIMAG, INT, MAX, MIN, MOD,
     $                   SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Statement Functions ..
</span>      DOUBLE PRECISION   CABS1
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Statement Function definitions ..
</span>      CABS1( CDUM ) = ABS( DBLE( CDUM ) ) + ABS( DIMAG( CDUM ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span>      INFO = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Quick return for N = 0: nothing to do. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 ) THEN
         WORK( 1 ) = ONE
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Set up job flags for <a name="ILAENV.228"></a><a href="hfy-index.html#ILAENV">ILAENV</a>. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( WANTT ) THEN
         JBCMPZ( 1: 1 ) = <span class="string">'S'</span>
      ELSE
         JBCMPZ( 1: 1 ) = <span class="string">'E'</span>
      END IF
      IF( WANTZ ) THEN
         JBCMPZ( 2: 2 ) = <span class="string">'V'</span>
      ELSE
         JBCMPZ( 2: 2 ) = <span class="string">'N'</span>
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Tiny matrices must use <a name="ZLAHQR.241"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>. ====
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.LE.NTINY ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Estimate optimal workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         LWKOPT = 1
         IF( LWORK.NE.-1 )
     $      CALL <a name="ZLAHQR.249"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>( WANTT, WANTZ, N, ILO, IHI, H, LDH, W, ILOZ,
     $                   IHIZ, Z, LDZ, INFO )
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Use small bulge multi-shift QR with aggressive early
</span><span class="comment">*</span><span class="comment">        .    deflation on larger-than-tiny matrices. ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Hope for the best. ====
</span><span class="comment">*</span><span class="comment">
</span>         INFO = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NWR = recommended deflation window size.  At this
</span><span class="comment">*</span><span class="comment">        .    point,  N .GT. NTINY = 11, so there is enough
</span><span class="comment">*</span><span class="comment">        .    subdiagonal workspace for NWR.GE.2 as required.
</span><span class="comment">*</span><span class="comment">        .    (In fact, there is enough subdiagonal space for
</span><span class="comment">*</span><span class="comment">        .    NWR.GE.3.) ====
</span><span class="comment">*</span><span class="comment">
</span>         NWR = <a name="ILAENV.266"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 13, <span class="string">'<a name="ZLAQR4.266"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NWR = MAX( 2, NWR )
         NWR = MIN( IHI-ILO+1, ( N-1 ) / 3, NWR )
         NW = NWR
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NSR = recommended number of simultaneous shifts.
</span><span class="comment">*</span><span class="comment">        .    At this point N .GT. NTINY = 11, so there is at
</span><span class="comment">*</span><span class="comment">        .    enough subdiagonal workspace for NSR to be even
</span><span class="comment">*</span><span class="comment">        .    and greater than or equal to two as required. ====
</span><span class="comment">*</span><span class="comment">
</span>         NSR = <a name="ILAENV.276"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 15, <span class="string">'<a name="ZLAQR4.276"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NSR = MIN( NSR, ( N+6 ) / 9, IHI-ILO )
         NSR = MAX( 2, NSR-MOD( NSR, 2 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Estimate optimal workspace ====
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Workspace query call to <a name="ZLAQR2.282"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a> ====
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="ZLAQR2.284"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>( WANTT, WANTZ, N, ILO, IHI, NWR+1, H, LDH, ILOZ,
     $                IHIZ, Z, LDZ, LS, LD, W, H, LDH, N, H, LDH, N, H,
     $                LDH, WORK, -1 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Optimal workspace = MAX(<a name="ZLAQR5.288"></a><a href="zlaqr5.f.html#ZLAQR5.1">ZLAQR5</a>, <a name="ZLAQR2.288"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>) ====
</span><span class="comment">*</span><span class="comment">
</span>         LWKOPT = MAX( 3*NSR / 2, INT( WORK( 1 ) ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Quick return in case of workspace query. ====
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.EQ.-1 ) THEN
            WORK( 1 ) = DCMPLX( LWKOPT, 0 )
            RETURN
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== <a name="ZLAHQR.299"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>/<a name="ZLAQR0.299"></a><a href="zlaqr0.f.html#ZLAQR0.1">ZLAQR0</a> crossover point ====
</span><span class="comment">*</span><span class="comment">
</span>         NMIN = <a name="ILAENV.301"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 12, <span class="string">'<a name="ZLAQR4.301"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NMIN = MAX( NTINY, NMIN )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Nibble crossover point ====
</span><span class="comment">*</span><span class="comment">
</span>         NIBBLE = <a name="ILAENV.306"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 14, <span class="string">'<a name="ZLAQR4.306"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         NIBBLE = MAX( 0, NIBBLE )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Accumulate reflections during ttswp?  Use block
</span><span class="comment">*</span><span class="comment">        .    2-by-2 structure during matrix-matrix multiply? ====
</span><span class="comment">*</span><span class="comment">
</span>         KACC22 = <a name="ILAENV.312"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 16, <span class="string">'<a name="ZLAQR4.312"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a>'</span>, JBCMPZ, N, ILO, IHI, LWORK )
         KACC22 = MAX( 0, KACC22 )
         KACC22 = MIN( 2, KACC22 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NWMAX = the largest possible deflation window for
</span><span class="comment">*</span><span class="comment">        .    which there is sufficient workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         NWMAX = MIN( ( N-1 ) / 3, LWORK / 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NSMAX = the Largest number of simultaneous shifts
</span><span class="comment">*</span><span class="comment">        .    for which there is sufficient workspace. ====
</span><span class="comment">*</span><span class="comment">
</span>         NSMAX = MIN( ( N+6 ) / 9, 2*LWORK / 3 )
         NSMAX = NSMAX - MOD( NSMAX, 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== NDFL: an iteration count restarted at deflation. ====
</span><span class="comment">*</span><span class="comment">
</span>         NDFL = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== ITMAX = iteration limit ====
</span><span class="comment">*</span><span class="comment">
</span>         ITMAX = MAX( 30, 2*KEXSH )*MAX( 10, ( IHI-ILO+1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Last row and column in the active block ====
</span><span class="comment">*</span><span class="comment">
</span>         KBOT = IHI
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Main Loop ====
</span><span class="comment">*</span><span class="comment">
</span>         DO 70 IT = 1, ITMAX
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Done when KBOT falls below ILO ====
</span><span class="comment">*</span><span class="comment">
</span>            IF( KBOT.LT.ILO )
     $         GO TO 80
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Locate active block ====
</span><span class="comment">*</span><span class="comment">
</span>            DO 10 K = KBOT, ILO + 1, -1
               IF( H( K, K-1 ).EQ.ZERO )
     $            GO TO 20
   10       CONTINUE
            K = ILO
   20       CONTINUE
            KTOP = K
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Select deflation window size ====
</span><span class="comment">*</span><span class="comment">
</span>            NH = KBOT - KTOP + 1
            IF( NDFL.LT.KEXNW .OR. NH.LT.NW ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Typical deflation window.  If possible and
</span><span class="comment">*</span><span class="comment">              .    advisable, nibble the entire active block.
</span><span class="comment">*</span><span class="comment">              .    If not, use size NWR or NWR+1 depending upon
</span><span class="comment">*</span><span class="comment">              .    which has the smaller corresponding subdiagonal
</span><span class="comment">*</span><span class="comment">              .    entry (a heuristic). ====
</span><span class="comment">*</span><span class="comment">
</span>               NWINC = .TRUE.
               IF( NH.LE.MIN( NMIN, NWMAX ) ) THEN
                  NW = NH
               ELSE
                  NW = MIN( NWR, NH, NWMAX )
                  IF( NW.LT.NWMAX ) THEN
                     IF( NW.GE.NH-1 ) THEN
                        NW = NH
                     ELSE
                        KWTOP = KBOT - NW + 1
                        IF( CABS1( H( KWTOP, KWTOP-1 ) ).GT.
     $                      CABS1( H( KWTOP-1, KWTOP-2 ) ) )NW = NW + 1
                     END IF
                  END IF
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Exceptional deflation window.  If there have
</span><span class="comment">*</span><span class="comment">              .    been no deflations in KEXNW or more iterations,
</span><span class="comment">*</span><span class="comment">              .    then vary the deflation window size.   At first,
</span><span class="comment">*</span><span class="comment">              .    because, larger windows are, in general, more
</span><span class="comment">*</span><span class="comment">              .    powerful than smaller ones, rapidly increase the
</span><span class="comment">*</span><span class="comment">              .    window up to the maximum reasonable and possible.
</span><span class="comment">*</span><span class="comment">              .    Then maybe try a slightly smaller window.  ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( NWINC .AND. NW.LT.MIN( NWMAX, NH ) ) THEN
                  NW = MIN( NWMAX, NH, 2*NW )
               ELSE
                  NWINC = .FALSE.
                  IF( NW.EQ.NH .AND. NH.GT.2 )
     $               NW = NH - 1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Aggressive early deflation:
</span><span class="comment">*</span><span class="comment">           .    split workspace under the subdiagonal into
</span><span class="comment">*</span><span class="comment">           .      - an nw-by-nw work array V in the lower
</span><span class="comment">*</span><span class="comment">           .        left-hand-corner,
</span><span class="comment">*</span><span class="comment">           .      - an NW-by-at-least-NW-but-more-is-better
</span><span class="comment">*</span><span class="comment">           .        (NW-by-NHO) horizontal work array along
</span><span class="comment">*</span><span class="comment">           .        the bottom edge,
</span><span class="comment">*</span><span class="comment">           .      - an at-least-NW-but-more-is-better (NHV-by-NW)
</span><span class="comment">*</span><span class="comment">           .        vertical work array along the left-hand-edge.
</span><span class="comment">*</span><span class="comment">           .        ====
</span><span class="comment">*</span><span class="comment">
</span>            KV = N - NW + 1
            KT = NW + 1
            NHO = ( N-NW-1 ) - KT + 1
            KWV = NW + 2
            NVE = ( N-NW ) - KWV + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Aggressive early deflation ====
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZLAQR2.422"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>( WANTT, WANTZ, N, KTOP, KBOT, NW, H, LDH, ILOZ,
     $                   IHIZ, Z, LDZ, LS, LD, W, H( KV, 1 ), LDH, NHO,
     $                   H( KV, KT ), LDH, NVE, H( KWV, 1 ), LDH, WORK,
     $                   LWORK )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Adjust KBOT accounting for new deflations. ====
</span><span class="comment">*</span><span class="comment">
</span>            KBOT = KBOT - LD
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== KS points to the shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>            KS = KBOT - LS + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Skip an expensive QR sweep if there is a (partly
</span><span class="comment">*</span><span class="comment">           .    heuristic) reason to expect that many eigenvalues
</span><span class="comment">*</span><span class="comment">           .    will deflate without it.  Here, the QR sweep is
</span><span class="comment">*</span><span class="comment">           .    skipped if many eigenvalues have just been deflated
</span><span class="comment">*</span><span class="comment">           .    or if the remaining active block is small.
</span><span class="comment">*</span><span class="comment">
</span>            IF( ( LD.EQ.0 ) .OR. ( ( 100*LD.LE.NW*NIBBLE ) .AND. ( KBOT-
     $          KTOP+1.GT.MIN( NMIN, NWMAX ) ) ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== NS = nominal number of simultaneous shifts.
</span><span class="comment">*</span><span class="comment">              .    This may be lowered (slightly) if <a name="ZLAQR2.445"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a>
</span><span class="comment">*</span><span class="comment">              .    did not provide that many shifts. ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = MIN( NSMAX, NSR, MAX( 2, KBOT-KTOP ) )
               NS = NS - MOD( NS, 2 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== If there have been no deflations
</span><span class="comment">*</span><span class="comment">              .    in a multiple of KEXSH iterations,
</span><span class="comment">*</span><span class="comment">              .    then try exceptional shifts.
</span><span class="comment">*</span><span class="comment">              .    Otherwise use shifts provided by
</span><span class="comment">*</span><span class="comment">              .    <a name="ZLAQR2.455"></a><a href="zlaqr2.f.html#ZLAQR2.1">ZLAQR2</a> above or from the eigenvalues
</span><span class="comment">*</span><span class="comment">              .    of a trailing principal submatrix. ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( MOD( NDFL, KEXSH ).EQ.0 ) THEN
                  KS = KBOT - NS + 1
                  DO 30 I = KBOT, KS + 1, -2
                     W( I ) = H( I, I ) + WILK1*CABS1( H( I, I-1 ) )
                     W( I-1 ) = W( I )
   30             CONTINUE
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 ==== Got NS/2 or fewer shifts? Use <a name="ZLAHQR.466"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>
</span><span class="comment">*</span><span class="comment">                 .    on a trailing principal submatrix to
</span><span class="comment">*</span><span class="comment">                 .    get more. (Since NS.LE.NSMAX.LE.(N+6)/9,
</span><span class="comment">*</span><span class="comment">                 .    there is enough space below the subdiagonal
</span><span class="comment">*</span><span class="comment">                 .    to fit an NS-by-NS scratch array.) ====
</span><span class="comment">*</span><span class="comment">
</span>                  IF( KBOT-KS+1.LE.NS / 2 ) THEN
                     KS = KBOT - NS + 1
                     KT = N - NS + 1
                     CALL <a name="ZLACPY.475"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'A'</span>, NS, NS, H( KS, KS ), LDH,
     $                            H( KT, 1 ), LDH )
                     CALL <a name="ZLAHQR.477"></a><a href="zlahqr.f.html#ZLAHQR.1">ZLAHQR</a>( .false., .false., NS, 1, NS,
     $                            H( KT, 1 ), LDH, W( KS ), 1, 1, ZDUM,
     $                            1, INF )
                     KS = KS + INF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    ==== In case of a rare QR failure use
</span><span class="comment">*</span><span class="comment">                    .    eigenvalues of the trailing 2-by-2
</span><span class="comment">*</span><span class="comment">                    .    principal submatrix.  Scale to avoid
</span><span class="comment">*</span><span class="comment">                    .    overflows, underflows and subnormals.
</span><span class="comment">*</span><span class="comment">                    .    (The scale factor S can not be zero,
</span><span class="comment">*</span><span class="comment">                    .    because H(KBOT,KBOT-1) is nonzero.) ====
</span><span class="comment">*</span><span class="comment">
</span>                     IF( KS.GE.KBOT ) THEN
                        S = CABS1( H( KBOT-1, KBOT-1 ) ) +
     $                      CABS1( H( KBOT, KBOT-1 ) ) +
     $                      CABS1( H( KBOT-1, KBOT ) ) +
     $                      CABS1( H( KBOT, KBOT ) )
                        AA = H( KBOT-1, KBOT-1 ) / S
                        CC = H( KBOT, KBOT-1 ) / S
                        BB = H( KBOT-1, KBOT ) / S
                        DD = H( KBOT, KBOT ) / S
                        TR2 = ( AA+DD ) / TWO
                        DET = ( AA-TR2 )*( DD-TR2 ) - BB*CC
                        RTDISC = SQRT( -DET )
                        W( KBOT-1 ) = ( TR2+RTDISC )*S
                        W( KBOT ) = ( TR2-RTDISC )*S
<span class="comment">*</span><span class="comment">
</span>                        KS = KBOT - 1
                     END IF
                  END IF
<span class="comment">*</span><span class="comment">
</span>                  IF( KBOT-KS+1.GT.NS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    ==== Sort the shifts (Helps a little) ====
</span><span class="comment">*</span><span class="comment">
</span>                     SORTED = .false.
                     DO 50 K = KBOT, KS + 1, -1
                        IF( SORTED )
     $                     GO TO 60
                        SORTED = .true.
                        DO 40 I = KS, K - 1
                           IF( CABS1( W( I ) ).LT.CABS1( W( I+1 ) ) )
     $                          THEN
                              SORTED = .false.
                              SWAP = W( I )
                              W( I ) = W( I+1 )
                              W( I+1 ) = SWAP
                           END IF
   40                   CONTINUE
   50                CONTINUE
   60                CONTINUE
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== If there are only two shifts, then use
</span><span class="comment">*</span><span class="comment">              .    only one.  ====
</span><span class="comment">*</span><span class="comment">
</span>               IF( KBOT-KS+1.EQ.2 ) THEN
                  IF( CABS1( W( KBOT )-H( KBOT, KBOT ) ).LT.
     $                CABS1( W( KBOT-1 )-H( KBOT, KBOT ) ) ) THEN
                     W( KBOT-1 ) = W( KBOT )
                  ELSE
                     W( KBOT ) = W( KBOT-1 )
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Use up to NS of the the smallest magnatiude
</span><span class="comment">*</span><span class="comment">              .    shifts.  If there aren't NS shifts available,
</span><span class="comment">*</span><span class="comment">              .    then use them all, possibly dropping one to
</span><span class="comment">*</span><span class="comment">              .    make the number of shifts even. ====
</span><span class="comment">*</span><span class="comment">
</span>               NS = MIN( NS, KBOT-KS+1 )
               NS = NS - MOD( NS, 2 )
               KS = KBOT - NS + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Small-bulge multi-shift QR sweep:
</span><span class="comment">*</span><span class="comment">              .    split workspace under the subdiagonal into
</span><span class="comment">*</span><span class="comment">              .    - a KDU-by-KDU work array U in the lower
</span><span class="comment">*</span><span class="comment">              .      left-hand-corner,
</span><span class="comment">*</span><span class="comment">              .    - a KDU-by-at-least-KDU-but-more-is-better
</span><span class="comment">*</span><span class="comment">              .      (KDU-by-NHo) horizontal work array WH along
</span><span class="comment">*</span><span class="comment">              .      the bottom edge,
</span><span class="comment">*</span><span class="comment">              .    - and an at-least-KDU-but-more-is-better-by-KDU
</span><span class="comment">*</span><span class="comment">              .      (NVE-by-KDU) vertical work WV arrow along
</span><span class="comment">*</span><span class="comment">              .      the left-hand-edge. ====
</span><span class="comment">*</span><span class="comment">
</span>               KDU = 3*NS - 3
               KU = N - KDU + 1
               KWH = KDU + 1
               NHO = ( N-KDU+1-4 ) - ( KDU+1 ) + 1
               KWV = KDU + 4
               NVE = N - KDU - KWV + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              ==== Small-bulge multi-shift QR sweep ====
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLAQR5.572"></a><a href="zlaqr5.f.html#ZLAQR5.1">ZLAQR5</a>( WANTT, WANTZ, KACC22, N, KTOP, KBOT, NS,
     $                      W( KS ), H, LDH, ILOZ, IHIZ, Z, LDZ, WORK,
     $                      3, H( KU, 1 ), LDH, NVE, H( KWV, 1 ), LDH,
     $                      NHO, H( KU, KWH ), LDH )
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== Note progress (or the lack of it). ====
</span><span class="comment">*</span><span class="comment">
</span>            IF( LD.GT.0 ) THEN
               NDFL = 1
            ELSE
               NDFL = NDFL + 1
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           ==== End of main loop ====
</span>   70    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        ==== Iteration limit exceeded.  Set INFO to show where
</span><span class="comment">*</span><span class="comment">        .    the problem occurred and exit. ====
</span><span class="comment">*</span><span class="comment">
</span>         INFO = KBOT
   80    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== Return the optimal value of LWORK. ====
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = DCMPLX( LWKOPT, 0 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     ==== End of <a name="ZLAQR4.600"></a><a href="zlaqr4.f.html#ZLAQR4.1">ZLAQR4</a> ====
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
