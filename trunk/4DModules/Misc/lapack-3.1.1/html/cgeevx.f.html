<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>cgeevx.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="CGEEVX.1"></a><a href="cgeevx.f.html#CGEEVX.1">CGEEVX</a>( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, W, VL,
     $                   LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, RCONDE,
     $                   RCONDV, WORK, LWORK, RWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          BALANC, JOBVL, JOBVR, SENSE
      INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N
      REAL               ABNRM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               RCONDE( * ), RCONDV( * ), RWORK( * ),
     $                   SCALE( * )
      COMPLEX            A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),
     $                   W( * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="CGEEVX.24"></a><a href="cgeevx.f.html#CGEEVX.1">CGEEVX</a> computes for an N-by-N complex nonsymmetric matrix A, the
</span><span class="comment">*</span><span class="comment">  eigenvalues and, optionally, the left and/or right eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally also, it computes a balancing transformation to improve
</span><span class="comment">*</span><span class="comment">  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
</span><span class="comment">*</span><span class="comment">  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
</span><span class="comment">*</span><span class="comment">  (RCONDE), and reciprocal condition numbers for the right
</span><span class="comment">*</span><span class="comment">  eigenvectors (RCONDV).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The right eigenvector v(j) of A satisfies
</span><span class="comment">*</span><span class="comment">                   A * v(j) = lambda(j) * v(j)
</span><span class="comment">*</span><span class="comment">  where lambda(j) is its eigenvalue.
</span><span class="comment">*</span><span class="comment">  The left eigenvector u(j) of A satisfies
</span><span class="comment">*</span><span class="comment">                u(j)**H * A = lambda(j) * u(j)**H
</span><span class="comment">*</span><span class="comment">  where u(j)**H denotes the conjugate transpose of u(j).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The computed eigenvectors are normalized to have Euclidean norm
</span><span class="comment">*</span><span class="comment">  equal to 1 and largest component real.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Balancing a matrix means permuting the rows and columns to make it
</span><span class="comment">*</span><span class="comment">  more nearly upper triangular, and applying a diagonal similarity
</span><span class="comment">*</span><span class="comment">  transformation D * A * D**(-1), where D is a diagonal matrix, to
</span><span class="comment">*</span><span class="comment">  make its rows and columns closer in norm and the condition numbers
</span><span class="comment">*</span><span class="comment">  of its eigenvalues and eigenvectors smaller.  The computed
</span><span class="comment">*</span><span class="comment">  reciprocal condition numbers correspond to the balanced matrix.
</span><span class="comment">*</span><span class="comment">  Permuting rows and columns will not change the condition numbers
</span><span class="comment">*</span><span class="comment">  (in exact arithmetic) but diagonal scaling will.  For further
</span><span class="comment">*</span><span class="comment">  explanation of balancing, see section 4.10.2 of the LAPACK
</span><span class="comment">*</span><span class="comment">  Users' Guide.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BALANC  (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Indicates how the input matrix should be diagonally scaled
</span><span class="comment">*</span><span class="comment">          and/or permuted to improve the conditioning of its
</span><span class="comment">*</span><span class="comment">          eigenvalues.
</span><span class="comment">*</span><span class="comment">          = 'N': Do not diagonally scale or permute;
</span><span class="comment">*</span><span class="comment">          = 'P': Perform permutations to make the matrix more nearly
</span><span class="comment">*</span><span class="comment">                 upper triangular. Do not diagonally scale;
</span><span class="comment">*</span><span class="comment">          = 'S': Diagonally scale the matrix, ie. replace A by
</span><span class="comment">*</span><span class="comment">                 D*A*D**(-1), where D is a diagonal matrix chosen
</span><span class="comment">*</span><span class="comment">                 to make the rows and columns of A more equal in
</span><span class="comment">*</span><span class="comment">                 norm. Do not permute;
</span><span class="comment">*</span><span class="comment">          = 'B': Both diagonally scale and permute A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          Computed reciprocal condition numbers will be for the matrix
</span><span class="comment">*</span><span class="comment">          after balancing and/or permuting. Permuting does not change
</span><span class="comment">*</span><span class="comment">          condition numbers (in exact arithmetic), but balancing does.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVL   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': left eigenvectors of A are not computed;
</span><span class="comment">*</span><span class="comment">          = 'V': left eigenvectors of A are computed.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', JOBVL must = 'V'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVR   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': right eigenvectors of A are not computed;
</span><span class="comment">*</span><span class="comment">          = 'V': right eigenvectors of A are computed.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', JOBVR must = 'V'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SENSE   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Determines which reciprocal condition numbers are computed.
</span><span class="comment">*</span><span class="comment">          = 'N': None are computed;
</span><span class="comment">*</span><span class="comment">          = 'E': Computed for eigenvalues only;
</span><span class="comment">*</span><span class="comment">          = 'V': Computed for right eigenvectors only;
</span><span class="comment">*</span><span class="comment">          = 'B': Computed for eigenvalues and right eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', both left and right eigenvectors
</span><span class="comment">*</span><span class="comment">          must also be computed (JOBVL = 'V' and JOBVR = 'V').
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrix A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the N-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, A has been overwritten.  If JOBVL = 'V' or
</span><span class="comment">*</span><span class="comment">          JOBVR = 'V', A contains the Schur form of the balanced 
</span><span class="comment">*</span><span class="comment">          version of the matrix A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  W       (output) COMPLEX array, dimension (N)
</span><span class="comment">*</span><span class="comment">          W contains the computed eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VL      (output) COMPLEX array, dimension (LDVL,N)
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'V', the left eigenvectors u(j) are stored one
</span><span class="comment">*</span><span class="comment">          after another in the columns of VL, in the same order
</span><span class="comment">*</span><span class="comment">          as their eigenvalues.
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'N', VL is not referenced.
</span><span class="comment">*</span><span class="comment">          u(j) = VL(:,j), the j-th column of VL.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVL    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VL.  LDVL &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBVL = 'V', LDVL &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VR      (output) COMPLEX array, dimension (LDVR,N)
</span><span class="comment">*</span><span class="comment">          If JOBVR = 'V', the right eigenvectors v(j) are stored one
</span><span class="comment">*</span><span class="comment">          after another in the columns of VR, in the same order
</span><span class="comment">*</span><span class="comment">          as their eigenvalues.
</span><span class="comment">*</span><span class="comment">          If JOBVR = 'N', VR is not referenced.
</span><span class="comment">*</span><span class="comment">          v(j) = VR(:,j), the j-th column of VR.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVR    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VR.  LDVR &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBVR = 'V', LDVR &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ILO     (output) INTEGER
</span><span class="comment">*</span><span class="comment">  IHI     (output) INTEGER
</span><span class="comment">*</span><span class="comment">          ILO and IHI are integer values determined when A was
</span><span class="comment">*</span><span class="comment">          balanced.  The balanced A(i,j) = 0 if I &gt; J and
</span><span class="comment">*</span><span class="comment">          J = 1,...,ILO-1 or I = IHI+1,...,N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SCALE   (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          Details of the permutations and scaling factors applied
</span><span class="comment">*</span><span class="comment">          when balancing A.  If P(j) is the index of the row and column
</span><span class="comment">*</span><span class="comment">          interchanged with row and column j, and D(j) is the scaling
</span><span class="comment">*</span><span class="comment">          factor applied to row and column j, then
</span><span class="comment">*</span><span class="comment">          SCALE(J) = P(J),    for J = 1,...,ILO-1
</span><span class="comment">*</span><span class="comment">                   = D(J),    for J = ILO,...,IHI
</span><span class="comment">*</span><span class="comment">                   = P(J)     for J = IHI+1,...,N.
</span><span class="comment">*</span><span class="comment">          The order in which the interchanges are made is N to IHI+1,
</span><span class="comment">*</span><span class="comment">          then 1 to ILO-1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ABNRM   (output) REAL
</span><span class="comment">*</span><span class="comment">          The one-norm of the balanced matrix (the maximum
</span><span class="comment">*</span><span class="comment">          of the sum of absolute values of elements of any column).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDE  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          RCONDE(j) is the reciprocal condition number of the j-th
</span><span class="comment">*</span><span class="comment">          eigenvalue.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDV  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          RCONDV(j) is the reciprocal condition number of the j-th
</span><span class="comment">*</span><span class="comment">          right eigenvector.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.  If SENSE = 'N' or 'E',
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= max(1,2*N), and if SENSE = 'V' or 'B',
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= N*N+2*N.
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK must generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.172"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) REAL array, dimension (2*N)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
</span><span class="comment">*</span><span class="comment">                eigenvalues, and no eigenvectors or condition numbers
</span><span class="comment">*</span><span class="comment">                have been computed; elements 1:ILO-1 and i+1:N of W
</span><span class="comment">*</span><span class="comment">                contain eigenvalues which have converged.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, SCALEA, WANTVL, WANTVR, WNTSNB, WNTSNE,
     $                   WNTSNN, WNTSNV
      CHARACTER          JOB, SIDE
      INTEGER            HSWORK, I, ICOND, IERR, ITAU, IWRK, K, MAXWRK,
     $                   MINWRK, NOUT
      REAL               ANRM, BIGNUM, CSCALE, EPS, SCL, SMLNUM
      COMPLEX            TMP
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      LOGICAL            SELECT( 1 )
      REAL               DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="CGEBAK.204"></a><a href="cgebak.f.html#CGEBAK.1">CGEBAK</a>, <a name="CGEBAL.204"></a><a href="cgebal.f.html#CGEBAL.1">CGEBAL</a>, <a name="CGEHRD.204"></a><a href="cgehrd.f.html#CGEHRD.1">CGEHRD</a>, <a name="CHSEQR.204"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>, <a name="CLACPY.204"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>, <a name="CLASCL.204"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>,
     $                   CSCAL, CSSCAL, <a name="CTREVC.205"></a><a href="ctrevc.f.html#CTREVC.1">CTREVC</a>, <a name="CTRSNA.205"></a><a href="ctrsna.f.html#CTRSNA.1">CTRSNA</a>, <a name="CUNGHR.205"></a><a href="cunghr.f.html#CUNGHR.1">CUNGHR</a>, <a name="SLABAD.205"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>,
     $                   <a name="SLASCL.206"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="XERBLA.206"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.209"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.210"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, ISAMAX
      REAL               <a name="CLANGE.211"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, SCNRM2, <a name="SLAMCH.211"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      EXTERNAL           <a name="LSAME.212"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.212"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, ISAMAX, <a name="CLANGE.212"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, SCNRM2, <a name="SLAMCH.212"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          AIMAG, CMPLX, CONJG, MAX, REAL, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      LQUERY = ( LWORK.EQ.-1 )
      WANTVL = <a name="LSAME.223"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'V'</span> )
      WANTVR = <a name="LSAME.224"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'V'</span> )
      WNTSNN = <a name="LSAME.225"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'N'</span> )
      WNTSNE = <a name="LSAME.226"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'E'</span> )
      WNTSNV = <a name="LSAME.227"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'V'</span> )
      WNTSNB = <a name="LSAME.228"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'B'</span> )
      IF( .NOT.( <a name="LSAME.229"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'N'</span> ) .OR. <a name="LSAME.229"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'S'</span> ) .OR.
     $    <a name="LSAME.230"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'P'</span> ) .OR. <a name="LSAME.230"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'B'</span> ) ) ) THEN
         INFO = -1
      ELSE IF( ( .NOT.WANTVL ) .AND. ( .NOT.<a name="LSAME.232"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'N'</span> ) ) ) THEN
         INFO = -2
      ELSE IF( ( .NOT.WANTVR ) .AND. ( .NOT.<a name="LSAME.234"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'N'</span> ) ) ) THEN
         INFO = -3
      ELSE IF( .NOT.( WNTSNN .OR. WNTSNE .OR. WNTSNB .OR. WNTSNV ) .OR.
     $         ( ( WNTSNE .OR. WNTSNB ) .AND. .NOT.( WANTVL .AND.
     $         WANTVR ) ) ) THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDVL.LT.1 .OR. ( WANTVL .AND. LDVL.LT.N ) ) THEN
         INFO = -10
      ELSE IF( LDVR.LT.1 .OR. ( WANTVR .AND. LDVR.LT.N ) ) THEN
         INFO = -12
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       CWorkspace refers to complex workspace, and RWorkspace to real
</span><span class="comment">*</span><span class="comment">       workspace. NB refers to the optimal block size for the
</span><span class="comment">*</span><span class="comment">       immediately following subroutine, as returned by <a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.
</span><span class="comment">*</span><span class="comment">       HSWORK refers to the workspace preferred by <a name="CHSEQR.257"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>, as
</span><span class="comment">*</span><span class="comment">       calculated below. HSWORK is computed assuming ILO=1 and IHI=N,
</span><span class="comment">*</span><span class="comment">       the worst case.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         IF( N.EQ.0 ) THEN
            MINWRK = 1
            MAXWRK = 1
         ELSE
            MAXWRK = N + N*<a name="ILAENV.266"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEHRD.266"></a><a href="cgehrd.f.html#CGEHRD.1">CGEHRD</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 )
<span class="comment">*</span><span class="comment">
</span>            IF( WANTVL ) THEN
               CALL <a name="CHSEQR.269"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'S'</span>, <span class="string">'V'</span>, N, 1, N, A, LDA, W, VL, LDVL,
     $                WORK, -1, INFO )
            ELSE IF( WANTVR ) THEN
               CALL <a name="CHSEQR.272"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'S'</span>, <span class="string">'V'</span>, N, 1, N, A, LDA, W, VR, LDVR,
     $                WORK, -1, INFO )
            ELSE
               IF( WNTSNN ) THEN
                  CALL <a name="CHSEQR.276"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'E'</span>, <span class="string">'N'</span>, N, 1, N, A, LDA, W, VR, LDVR,
     $                WORK, -1, INFO )
               ELSE
                  CALL <a name="CHSEQR.279"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'S'</span>, <span class="string">'N'</span>, N, 1, N, A, LDA, W, VR, LDVR,
     $                WORK, -1, INFO )
               END IF
            END IF
            HSWORK = WORK( 1 )
<span class="comment">*</span><span class="comment">
</span>            IF( ( .NOT.WANTVL ) .AND. ( .NOT.WANTVR ) ) THEN
               MINWRK = 2*N
               IF( .NOT.( WNTSNN .OR. WNTSNE ) )
     $            MINWRK = MAX( MINWRK, N*N + 2*N )
               MAXWRK = MAX( MAXWRK, HSWORK )
               IF( .NOT.( WNTSNN .OR. WNTSNE ) )
     $            MAXWRK = MAX( MAXWRK, N*N + 2*N )
            ELSE
               MINWRK = 2*N
               IF( .NOT.( WNTSNN .OR. WNTSNE ) )
     $            MINWRK = MAX( MINWRK, N*N + 2*N )
               MAXWRK = MAX( MAXWRK, HSWORK )
               MAXWRK = MAX( MAXWRK, N + ( N - 1 )*<a name="ILAENV.297"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNGHR.297"></a><a href="cunghr.f.html#CUNGHR.1">CUNGHR</a>'</span>,
     $                       <span class="string">' '</span>, N, 1, N, -1 ) )
               IF( .NOT.( WNTSNN .OR. WNTSNE ) )
     $            MAXWRK = MAX( MAXWRK, N*N + 2*N )
               MAXWRK = MAX( MAXWRK, 2*N )
            END IF
            MAXWRK = MAX( MAXWRK, MINWRK )
         END IF
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -20
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.313"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="CGEEVX.313"></a><a href="cgeevx.f.html#CGEEVX.1">CGEEVX</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.326"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="SLAMCH.327"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.329"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
      SMLNUM = SQRT( SMLNUM ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ICOND = 0
      ANRM = <a name="CLANGE.336"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, N, N, A, LDA, DUM )
      SCALEA = .FALSE.
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         SCALEA = .TRUE.
         CSCALE = SMLNUM
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         SCALEA = .TRUE.
         CSCALE = BIGNUM
      END IF
      IF( SCALEA )
     $   CALL <a name="CLASCL.346"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, CSCALE, N, N, A, LDA, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Balance the matrix and compute ABNRM
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="CGEBAL.350"></a><a href="cgebal.f.html#CGEBAL.1">CGEBAL</a>( BALANC, N, A, LDA, ILO, IHI, SCALE, IERR )
      ABNRM = <a name="CLANGE.351"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'1'</span>, N, N, A, LDA, DUM )
      IF( SCALEA ) THEN
         DUM( 1 ) = ABNRM
         CALL <a name="SLASCL.354"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, 1, 1, DUM, 1, IERR )
         ABNRM = DUM( 1 )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce to upper Hessenberg form
</span><span class="comment">*</span><span class="comment">     (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">     (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>      ITAU = 1
      IWRK = ITAU + N
      CALL <a name="CGEHRD.364"></a><a href="cgehrd.f.html#CGEHRD.1">CGEHRD</a>( N, ILO, IHI, A, LDA, WORK( ITAU ), WORK( IWRK ),
     $             LWORK-IWRK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVL ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Want left eigenvectors
</span><span class="comment">*</span><span class="comment">        Copy Householder vectors to VL
</span><span class="comment">*</span><span class="comment">
</span>         SIDE = <span class="string">'L'</span>
         CALL <a name="CLACPY.373"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, N, N, A, LDA, VL, LDVL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate unitary matrix in VL
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNGHR.379"></a><a href="cunghr.f.html#CUNGHR.1">CUNGHR</a>( N, ILO, IHI, VL, LDVL, WORK( ITAU ), WORK( IWRK ),
     $                LWORK-IWRK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform QR iteration, accumulating Schur vectors in VL
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 1, prefer HSWORK (see comments) )
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IWRK = ITAU
         CALL <a name="CHSEQR.387"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'S'</span>, <span class="string">'V'</span>, N, ILO, IHI, A, LDA, W, VL, LDVL,
     $                WORK( IWRK ), LWORK-IWRK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>         IF( WANTVR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Want left and right eigenvectors
</span><span class="comment">*</span><span class="comment">           Copy Schur vectors to VR
</span><span class="comment">*</span><span class="comment">
</span>            SIDE = <span class="string">'B'</span>
            CALL <a name="CLACPY.396"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'F'</span>, N, N, VL, LDVL, VR, LDVR )
         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( WANTVR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Want right eigenvectors
</span><span class="comment">*</span><span class="comment">        Copy Householder vectors to VR
</span><span class="comment">*</span><span class="comment">
</span>         SIDE = <span class="string">'R'</span>
         CALL <a name="CLACPY.405"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, N, N, A, LDA, VR, LDVR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate unitary matrix in VR
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N-1, prefer N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNGHR.411"></a><a href="cunghr.f.html#CUNGHR.1">CUNGHR</a>( N, ILO, IHI, VR, LDVR, WORK( ITAU ), WORK( IWRK ),
     $                LWORK-IWRK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform QR iteration, accumulating Schur vectors in VR
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 1, prefer HSWORK (see comments) )
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IWRK = ITAU
         CALL <a name="CHSEQR.419"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( <span class="string">'S'</span>, <span class="string">'V'</span>, N, ILO, IHI, A, LDA, W, VR, LDVR,
     $                WORK( IWRK ), LWORK-IWRK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute eigenvalues only
</span><span class="comment">*</span><span class="comment">        If condition numbers desired, compute Schur form
</span><span class="comment">*</span><span class="comment">
</span>         IF( WNTSNN ) THEN
            JOB = <span class="string">'E'</span>
         ELSE
            JOB = <span class="string">'S'</span>
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 1, prefer HSWORK (see comments) )
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IWRK = ITAU
         CALL <a name="CHSEQR.437"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>( JOB, <span class="string">'N'</span>, N, ILO, IHI, A, LDA, W, VR, LDVR,
     $                WORK( IWRK ), LWORK-IWRK+1, INFO )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If INFO &gt; 0 from <a name="CHSEQR.441"></a><a href="chseqr.f.html#CHSEQR.1">CHSEQR</a>, then quit
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.GT.0 )
     $   GO TO 50
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVL .OR. WANTVR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute left and/or right eigenvectors
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CTREVC.452"></a><a href="ctrevc.f.html#CTREVC.1">CTREVC</a>( SIDE, <span class="string">'B'</span>, SELECT, N, A, LDA, VL, LDVL, VR, LDVR,
     $                N, NOUT, WORK( IWRK ), RWORK, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute condition numbers if desired
</span><span class="comment">*</span><span class="comment">     (CWorkspace: need N*N+2*N unless SENSE = 'E')
</span><span class="comment">*</span><span class="comment">     (RWorkspace: need 2*N unless SENSE = 'E')
</span><span class="comment">*</span><span class="comment">
</span>      IF( .NOT.WNTSNN ) THEN
         CALL <a name="CTRSNA.461"></a><a href="ctrsna.f.html#CTRSNA.1">CTRSNA</a>( SENSE, <span class="string">'A'</span>, SELECT, N, A, LDA, VL, LDVL, VR, LDVR,
     $                RCONDE, RCONDV, N, NOUT, WORK( IWRK ), N, RWORK,
     $                ICOND )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVL ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo balancing of left eigenvectors
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBAK.470"></a><a href="cgebak.f.html#CGEBAK.1">CGEBAK</a>( BALANC, <span class="string">'L'</span>, N, ILO, IHI, SCALE, N, VL, LDVL,
     $                IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Normalize left eigenvectors and make largest component real
</span><span class="comment">*</span><span class="comment">
</span>         DO 20 I = 1, N
            SCL = ONE / SCNRM2( N, VL( 1, I ), 1 )
            CALL CSSCAL( N, SCL, VL( 1, I ), 1 )
            DO 10 K = 1, N
               RWORK( K ) = REAL( VL( K, I ) )**2 +
     $                      AIMAG( VL( K, I ) )**2
   10       CONTINUE
            K = ISAMAX( N, RWORK, 1 )
            TMP = CONJG( VL( K, I ) ) / SQRT( RWORK( K ) )
            CALL CSCAL( N, TMP, VL( 1, I ), 1 )
            VL( K, I ) = CMPLX( REAL( VL( K, I ) ), ZERO )
   20    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( WANTVR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo balancing of right eigenvectors
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBAK.493"></a><a href="cgebak.f.html#CGEBAK.1">CGEBAK</a>( BALANC, <span class="string">'R'</span>, N, ILO, IHI, SCALE, N, VR, LDVR,
     $                IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Normalize right eigenvectors and make largest component real
</span><span class="comment">*</span><span class="comment">
</span>         DO 40 I = 1, N
            SCL = ONE / SCNRM2( N, VR( 1, I ), 1 )
            CALL CSSCAL( N, SCL, VR( 1, I ), 1 )
            DO 30 K = 1, N
               RWORK( K ) = REAL( VR( K, I ) )**2 +
     $                      AIMAG( VR( K, I ) )**2
   30       CONTINUE
            K = ISAMAX( N, RWORK, 1 )
            TMP = CONJG( VR( K, I ) ) / SQRT( RWORK( K ) )
            CALL CSCAL( N, TMP, VR( 1, I ), 1 )
            VR( K, I ) = CMPLX( REAL( VR( K, I ) ), ZERO )
   40    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>   50 CONTINUE
      IF( SCALEA ) THEN
         CALL <a name="CLASCL.516"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, N-INFO, 1, W( INFO+1 ),
     $                MAX( N-INFO, 1 ), IERR )
         IF( INFO.EQ.0 ) THEN
            IF( ( WNTSNV .OR. WNTSNB ) .AND. ICOND.EQ.0 )
     $         CALL <a name="SLASCL.520"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, N, 1, RCONDV, N,
     $                      IERR )
         ELSE
            CALL <a name="CLASCL.523"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, CSCALE, ANRM, ILO-1, 1, W, N, IERR )
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="CGEEVX.530"></a><a href="cgeevx.f.html#CGEEVX.1">CGEEVX</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
