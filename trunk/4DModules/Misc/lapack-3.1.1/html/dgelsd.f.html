<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dgelsd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DGELSD.1"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a>( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
     $                   WORK, LWORK, IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
      DOUBLE PRECISION   RCOND
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), S( * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DGELSD.20"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a> computes the minimum-norm solution to a real linear least
</span><span class="comment">*</span><span class="comment">  squares problem:
</span><span class="comment">*</span><span class="comment">      minimize 2-norm(| b - A*x |)
</span><span class="comment">*</span><span class="comment">  using the singular value decomposition (SVD) of A. A is an M-by-N
</span><span class="comment">*</span><span class="comment">  matrix which may be rank-deficient.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Several right hand side vectors b and solution vectors x can be
</span><span class="comment">*</span><span class="comment">  handled in a single call; they are stored as the columns of the
</span><span class="comment">*</span><span class="comment">  M-by-NRHS right hand side matrix B and the N-by-NRHS solution
</span><span class="comment">*</span><span class="comment">  matrix X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The problem is solved in three steps:
</span><span class="comment">*</span><span class="comment">  (1) Reduce the coefficient matrix A to bidiagonal form with
</span><span class="comment">*</span><span class="comment">      Householder transformations, reducing the original problem
</span><span class="comment">*</span><span class="comment">      into a &quot;bidiagonal least squares problem&quot; (BLS)
</span><span class="comment">*</span><span class="comment">  (2) Solve the BLS using a divide and conquer approach.
</span><span class="comment">*</span><span class="comment">  (3) Apply back all the Householder tranformations to solve
</span><span class="comment">*</span><span class="comment">      the original least squares problem.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The effective rank of A is determined by treating as zero those
</span><span class="comment">*</span><span class="comment">  singular values which are less than RCOND times the largest singular
</span><span class="comment">*</span><span class="comment">  value.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The divide and conquer algorithm makes very mild assumptions about
</span><span class="comment">*</span><span class="comment">  floating point arithmetic. It will work on machines with a guard
</span><span class="comment">*</span><span class="comment">  digit in add/subtract, or on those binary machines without guard
</span><span class="comment">*</span><span class="comment">  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
</span><span class="comment">*</span><span class="comment">  Cray-2. It could conceivably fail on hexadecimal or decimal machines
</span><span class="comment">*</span><span class="comment">  without guard digits, but we know of none.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of A. M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  NRHS    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of right hand sides, i.e., the number of columns
</span><span class="comment">*</span><span class="comment">          of the matrices B and X. NRHS &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, A has been destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-NRHS right hand side matrix B.
</span><span class="comment">*</span><span class="comment">          On exit, B is overwritten by the N-by-NRHS solution
</span><span class="comment">*</span><span class="comment">          matrix X.  If m &gt;= n and RANK = n, the residual
</span><span class="comment">*</span><span class="comment">          sum-of-squares for the solution in the i-th column is given
</span><span class="comment">*</span><span class="comment">          by the sum of squares of elements n+1:m in that column.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1,max(M,N)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A in decreasing order.
</span><span class="comment">*</span><span class="comment">          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCOND   (input) DOUBLE PRECISION
</span><span class="comment">*</span><span class="comment">          RCOND is used to determine the effective rank of A.
</span><span class="comment">*</span><span class="comment">          Singular values S(i) &lt;= RCOND*S(1) are treated as zero.
</span><span class="comment">*</span><span class="comment">          If RCOND &lt; 0, machine precision is used instead.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RANK    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The effective rank of A, i.e., the number of singular values
</span><span class="comment">*</span><span class="comment">          which are greater than RCOND*S(1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK must be at least 1.
</span><span class="comment">*</span><span class="comment">          The exact minimum amount of workspace needed depends on M,
</span><span class="comment">*</span><span class="comment">          N and NRHS. As long as LWORK is at least
</span><span class="comment">*</span><span class="comment">              12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,
</span><span class="comment">*</span><span class="comment">          if M is greater than or equal to N or
</span><span class="comment">*</span><span class="comment">              12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,
</span><span class="comment">*</span><span class="comment">          if M is less than N, the code will execute correctly.
</span><span class="comment">*</span><span class="comment">          SMLSIZ is returned by <a name="ILAENV.104"></a><a href="hfy-index.html#ILAENV">ILAENV</a> and is equal to the maximum
</span><span class="comment">*</span><span class="comment">          size of the subproblems at the bottom of the computation
</span><span class="comment">*</span><span class="comment">          tree (usually about 25), and
</span><span class="comment">*</span><span class="comment">             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.113"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))
</span><span class="comment">*</span><span class="comment">          LIWORK &gt;= 3 * MINMN * NLVL + 11 * MINMN,
</span><span class="comment">*</span><span class="comment">          where MINMN = MIN( M,N ).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  the algorithm for computing the SVD failed to converge;
</span><span class="comment">*</span><span class="comment">                if INFO = i, i off-diagonal elements of an intermediate
</span><span class="comment">*</span><span class="comment">                bidiagonal form did not converge to zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Ming Gu and Ren-Cang Li, Computer Science Division, University of
</span><span class="comment">*</span><span class="comment">       California at Berkeley, USA
</span><span class="comment">*</span><span class="comment">     Osni Marques, LBNL/NERSC, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      DOUBLE PRECISION   ZERO, ONE, TWO
      PARAMETER          ( ZERO = 0.0D0, ONE = 1.0D0, TWO = 2.0D0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY
      INTEGER            IASCL, IBSCL, IE, IL, ITAU, ITAUP, ITAUQ,
     $                   LDWORK, MAXMN, MAXWRK, MINMN, MINWRK, MM,
     $                   MNTHR, NLVL, NWORK, SMLSIZ, WLALSD
      DOUBLE PRECISION   ANRM, BIGNUM, BNRM, EPS, SFMIN, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DGEBRD.148"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>, <a name="DGELQF.148"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>, <a name="DGEQRF.148"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>, <a name="DLABAD.148"></a><a href="dlabad.f.html#DLABAD.1">DLABAD</a>, <a name="DLACPY.148"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>, <a name="DLALSD.148"></a><a href="dlalsd.f.html#DLALSD.1">DLALSD</a>,
     $                   <a name="DLASCL.149"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="DLASET.149"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>, <a name="DORMBR.149"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>, <a name="DORMLQ.149"></a><a href="dormlq.f.html#DORMLQ.1">DORMLQ</a>, <a name="DORMQR.149"></a><a href="dormqr.f.html#DORMQR.1">DORMQR</a>, <a name="XERBLA.149"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.152"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.153"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.153"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
      EXTERNAL           <a name="ILAENV.154"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="DLAMCH.154"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANGE.154"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          DBLE, INT, LOG, MAX, MIN
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments.
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      MAXMN = MAX( M, N )
      MNTHR = <a name="ILAENV.166"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="DGELSD.166"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a>'</span>, <span class="string">' '</span>, M, N, NRHS, -1 )
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, MAXMN ) ) THEN
         INFO = -7
      END IF
<span class="comment">*</span><span class="comment">
</span>      SMLSIZ = <a name="ILAENV.180"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 9, <span class="string">'<a name="DGELSD.180"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a>'</span>, <span class="string">' '</span>, 0, 0, 0, 0 )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace.
</span><span class="comment">*</span><span class="comment">     (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">     minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">     as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">     NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">     following subroutine, as returned by <a name="ILAENV.187"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      MINWRK = 1
      MINMN = MAX( 1, MINMN )
      NLVL = MAX( INT( LOG( DBLE( MINMN ) / DBLE( SMLSIZ+1 ) ) /
     $       LOG( TWO ) ) + 1, 0 )
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MAXWRK = 0
         MM = M
         IF( M.GE.N .AND. M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1a - overdetermined, with many more rows than columns.
</span><span class="comment">*</span><span class="comment">
</span>            MM = N
            MAXWRK = MAX( MAXWRK, N+N*<a name="ILAENV.202"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEQRF.202"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>'</span>, <span class="string">' '</span>, M, N,
     $               -1, -1 ) )
            MAXWRK = MAX( MAXWRK, N+NRHS*
     $               <a name="ILAENV.205"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMQR.205"></a><a href="dormqr.f.html#DORMQR.1">DORMQR</a>'</span>, <span class="string">'LT'</span>, M, NRHS, N, -1 ) )
         END IF
         IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1 - overdetermined or exactly determined.
</span><span class="comment">*</span><span class="comment">
</span>            MAXWRK = MAX( MAXWRK, 3*N+( MM+N )*
     $               <a name="ILAENV.212"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.212"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, MM, N, -1, -1 ) )
            MAXWRK = MAX( MAXWRK, 3*N+NRHS*
     $               <a name="ILAENV.214"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.214"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLT'</span>, MM, NRHS, N, -1 ) )
            MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $               <a name="ILAENV.216"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.216"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PLN'</span>, N, NRHS, N, -1 ) )
            WLALSD = 9*N+2*N*SMLSIZ+8*N*NLVL+N*NRHS+(SMLSIZ+1)**2
            MAXWRK = MAX( MAXWRK, 3*N+WLALSD )
            MINWRK = MAX( 3*N+MM, 3*N+NRHS, 3*N+WLALSD )
         END IF
         IF( N.GT.M ) THEN
            WLALSD = 9*M+2*M*SMLSIZ+8*M*NLVL+M*NRHS+(SMLSIZ+1)**2
            IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2a - underdetermined, with many more columns
</span><span class="comment">*</span><span class="comment">              than rows.
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = M + M*<a name="ILAENV.228"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGELQF.228"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
               MAXWRK = MAX( MAXWRK, M*M+4*M+2*M*
     $                  <a name="ILAENV.230"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.230"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, M*M+4*M+NRHS*
     $                  <a name="ILAENV.232"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.232"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLT'</span>, M, NRHS, M, -1 ) )
               MAXWRK = MAX( MAXWRK, M*M+4*M+( M-1 )*
     $                  <a name="ILAENV.234"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.234"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PLN'</span>, M, NRHS, M, -1 ) )
               IF( NRHS.GT.1 ) THEN
                  MAXWRK = MAX( MAXWRK, M*M+M+M*NRHS )
               ELSE
                  MAXWRK = MAX( MAXWRK, M*M+2*M )
               END IF
               MAXWRK = MAX( MAXWRK, M+NRHS*
     $                  <a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMLQ.241"></a><a href="dormlq.f.html#DORMLQ.1">DORMLQ</a>'</span>, <span class="string">'LT'</span>, N, NRHS, M, -1 ) )
               MAXWRK = MAX( MAXWRK, M*M+4*M+WLALSD )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 - remaining underdetermined cases.
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 3*M + ( N+M )*<a name="ILAENV.247"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DGEBRD.247"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               MAXWRK = MAX( MAXWRK, 3*M+NRHS*
     $                  <a name="ILAENV.250"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.250"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'QLT'</span>, M, NRHS, N, -1 ) )
               MAXWRK = MAX( MAXWRK, 3*M+M*
     $                  <a name="ILAENV.252"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="DORMBR.252"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>'</span>, <span class="string">'PLN'</span>, N, NRHS, M, -1 ) )
               MAXWRK = MAX( MAXWRK, 3*M+WLALSD )
            END IF
            MINWRK = MAX( 3*M+NRHS, 3*M+M, 3*M+WLALSD )
         END IF
         MINWRK = MIN( MINWRK, MAXWRK )
         WORK( 1 ) = MAXWRK
         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -12
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.265"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DGELSD.265"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         GO TO 10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RANK = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine parameters.
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.280"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SFMIN = <a name="DLAMCH.281"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> )
      SMLNUM = SFMIN / EPS
      BIGNUM = ONE / SMLNUM
      CALL <a name="DLABAD.284"></a><a href="dlabad.f.html#DLABAD.1">DLABAD</a>( SMLNUM, BIGNUM )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max entry outside range [SMLNUM,BIGNUM].
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="DLANGE.288"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, WORK )
      IASCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASCL.294"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, INFO )
         IASCL = 1
      ELSE IF( ANRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASCL.300"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, INFO )
         IASCL = 2
      ELSE IF( ANRM.EQ.ZERO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Matrix all zero. Return zero solution.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASET.306"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, MAX( M, N ), NRHS, ZERO, ZERO, B, LDB )
         CALL <a name="DLASET.307"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, MINMN, 1, ZERO, ZERO, S, 1 )
         RANK = 0
         GO TO 10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max entry outside range [SMLNUM,BIGNUM].
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="DLANGE.314"></a><a href="dlange.f.html#DLANGE.1">DLANGE</a>( <span class="string">'M'</span>, M, NRHS, B, LDB, WORK )
      IBSCL = 0
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASCL.320"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, SMLNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 1
      ELSE IF( BNRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASCL.326"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BIGNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 2
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If M &lt; N make sure certain entries of B are zero.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.LT.N )
     $   CALL <a name="DLASET.333"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, N-M, NRHS, ZERO, ZERO, B( M+1, 1 ), LDB )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Overdetermined case.
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 1 - overdetermined or exactly determined.
</span><span class="comment">*</span><span class="comment">
</span>         MM = M
         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1a - overdetermined, with many more rows than columns.
</span><span class="comment">*</span><span class="comment">
</span>            MM = N
            ITAU = 1
            NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute A=Q*R.
</span><span class="comment">*</span><span class="comment">           (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DGEQRF.353"></a><a href="dgeqrf.f.html#DGEQRF.1">DGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                   LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Multiply B by transpose(Q).
</span><span class="comment">*</span><span class="comment">           (Workspace: need N+NRHS, prefer N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DORMQR.359"></a><a href="dormqr.f.html#DORMQR.1">DORMQR</a>( <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, N, A, LDA, WORK( ITAU ), B,
     $                   LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Zero out below R.
</span><span class="comment">*</span><span class="comment">
</span>            IF( N.GT.1 ) THEN
               CALL <a name="DLASET.365"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = IE + N
         ITAUP = ITAUQ + N
         NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize R in A.
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*N+MM, prefer 3*N+(MM+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DGEBRD.377"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( MM, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of R.
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*N+NRHS, prefer 3*N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.384"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, MM, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLALSD.389"></a><a href="dlalsd.f.html#DLALSD.1">DLALSD</a>( <span class="string">'U'</span>, SMLSIZ, N, NRHS, S, WORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of R.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.397"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, NRHS, N, A, LDA, WORK( ITAUP ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( N.GE.MNTHR .AND. LWORK.GE.4*M+M*M+
     $         MAX( M, 2*M-4, NRHS, N-3*M, WLALSD ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2a - underdetermined, with many more columns than rows
</span><span class="comment">*</span><span class="comment">        and sufficient workspace for an efficient algorithm.
</span><span class="comment">*</span><span class="comment">
</span>         LDWORK = M
         IF( LWORK.GE.MAX( 4*M+M*LDA+MAX( M, 2*M-4, NRHS, N-3*M ),
     $       M*LDA+M+M*NRHS, 4*M+M*LDA+WLALSD ) )LDWORK = LDA
         ITAU = 1
         NWORK = M + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute A=L*Q.
</span><span class="comment">*</span><span class="comment">        (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DGELQF.415"></a><a href="dgelqf.f.html#DGELQF.1">DGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
         IL = NWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Copy L to WORK(IL), zeroing out above its diagonal.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLACPY.421"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWORK )
         CALL <a name="DLASET.422"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, WORK( IL+LDWORK ),
     $                LDWORK )
         IE = IL + LDWORK*M
         ITAUQ = IE + M
         ITAUP = ITAUQ + M
         NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize L in WORK(IL).
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+5*M, prefer M*M+4*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DGEBRD.432"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, M, WORK( IL ), LDWORK, S, WORK( IE ),
     $                WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of L.
</span><span class="comment">*</span><span class="comment">        (Workspace: need M*M+4*M+NRHS, prefer M*M+4*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.439"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUQ ), B, LDB, WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLALSD.445"></a><a href="dlalsd.f.html#DLALSD.1">DLALSD</a>( <span class="string">'U'</span>, SMLSIZ, M, NRHS, S, WORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of L.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.453"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUP ), B, LDB, WORK( NWORK ),
     $                LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Zero out below first M rows of B.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLASET.459"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'F'</span>, N-M, NRHS, ZERO, ZERO, B( M+1, 1 ), LDB )
         NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply transpose(Q) by B.
</span><span class="comment">*</span><span class="comment">        (Workspace: need M+NRHS, prefer M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMLQ.465"></a><a href="dormlq.f.html#DORMLQ.1">DORMLQ</a>( <span class="string">'L'</span>, <span class="string">'T'</span>, N, NRHS, M, A, LDA, WORK( ITAU ), B,
     $                LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2 - remaining underdetermined cases.
</span><span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = IE + M
         ITAUP = ITAUQ + M
         NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize A.
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DGEBRD.480"></a><a href="dgebrd.f.html#DGEBRD.1">DGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors.
</span><span class="comment">*</span><span class="comment">        (Workspace: need 3*M+NRHS, prefer 3*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.487"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Solve the bidiagonal least squares problem.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DLALSD.492"></a><a href="dlalsd.f.html#DLALSD.1">DLALSD</a>( <span class="string">'L'</span>, SMLSIZ, M, NRHS, S, WORK( IE ), B, LDB,
     $                RCOND, RANK, WORK( NWORK ), IWORK, INFO )
         IF( INFO.NE.0 ) THEN
            GO TO 10
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right bidiagonalizing vectors of A.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="DORMBR.500"></a><a href="dormbr.f.html#DORMBR.1">DORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, NRHS, M, A, LDA, WORK( ITAUP ),
     $                B, LDB, WORK( NWORK ), LWORK-NWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling.
</span><span class="comment">*</span><span class="comment">
</span>      IF( IASCL.EQ.1 ) THEN
         CALL <a name="DLASCL.508"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="DLASCL.509"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      ELSE IF( IASCL.EQ.2 ) THEN
         CALL <a name="DLASCL.512"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="DLASCL.513"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      END IF
      IF( IBSCL.EQ.1 ) THEN
         CALL <a name="DLASCL.517"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, BNRM, N, NRHS, B, LDB, INFO )
      ELSE IF( IBSCL.EQ.2 ) THEN
         CALL <a name="DLASCL.519"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, BNRM, N, NRHS, B, LDB, INFO )
      END IF
<span class="comment">*</span><span class="comment">
</span>   10 CONTINUE
      WORK( 1 ) = MAXWRK
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DGELSD.526"></a><a href="dgelsd.f.html#DGELSD.1">DGELSD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
