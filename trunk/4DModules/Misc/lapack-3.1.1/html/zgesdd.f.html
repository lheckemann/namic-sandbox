<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>zgesdd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="ZGESDD.1"></a><a href="zgesdd.f.html#ZGESDD.1">ZGESDD</a>( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,
     $                   LWORK, RWORK, IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">     8-15-00:  Improve consistency of WS calculations (eca)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBZ
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      INTEGER            IWORK( * )
      DOUBLE PRECISION   RWORK( * ), S( * )
      COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),
     $                   WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="ZGESDD.23"></a><a href="zgesdd.f.html#ZGESDD.1">ZGESDD</a> computes the singular value decomposition (SVD) of a complex
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and/or right singular
</span><span class="comment">*</span><span class="comment">  vectors, by using divide-and-conquer method. The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * conjugate-transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns VT = V**H, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The divide and conquer algorithm makes very mild assumptions about
</span><span class="comment">*</span><span class="comment">  floating point arithmetic. It will work on machines with a guard
</span><span class="comment">*</span><span class="comment">  digit in add/subtract, or on those binary machines without guard
</span><span class="comment">*</span><span class="comment">  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
</span><span class="comment">*</span><span class="comment">  Cray-2. It could conceivably fail on hexadecimal or decimal machines
</span><span class="comment">*</span><span class="comment">  without guard digits, but we know of none.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBZ    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U and all N rows of V**H are
</span><span class="comment">*</span><span class="comment">                  returned in the arrays U and VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(M,N) columns of U and the first
</span><span class="comment">*</span><span class="comment">                  min(M,N) rows of V**H are returned in the arrays U
</span><span class="comment">*</span><span class="comment">                  and VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  If M &gt;= N, the first N columns of U are overwritten
</span><span class="comment">*</span><span class="comment">                  in the array A and all rows of V**H are returned in
</span><span class="comment">*</span><span class="comment">                  the array VT;
</span><span class="comment">*</span><span class="comment">                  otherwise, all columns of U are returned in the
</span><span class="comment">*</span><span class="comment">                  array U and the first M rows of V**H are overwritten
</span><span class="comment">*</span><span class="comment">                  in the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U or rows of V**H are computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX*16 array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O',  A is overwritten with the first N columns
</span><span class="comment">*</span><span class="comment">                          of U (the left singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          columnwise) if M &gt;= N;
</span><span class="comment">*</span><span class="comment">                          A is overwritten with the first M rows
</span><span class="comment">*</span><span class="comment">                          of V**H (the right singular vectors, stored
</span><span class="comment">*</span><span class="comment">                          rowwise) otherwise.
</span><span class="comment">*</span><span class="comment">          if JOBZ .ne. 'O', the contents of A are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
</span><span class="comment">*</span><span class="comment">          UCOL = min(M,N) if JOBZ = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
</span><span class="comment">*</span><span class="comment">          unitary matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', U contains the first min(M,N) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) COMPLEX*16 array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, VT contains the
</span><span class="comment">*</span><span class="comment">          N-by-N unitary matrix V**H;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', VT contains the first min(M,N) rows of
</span><span class="comment">*</span><span class="comment">          V**H (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBZ = 'A' or JOBZ = 'O' and M &gt;= N, LDVT &gt;= N;
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= 1.
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'N', LWORK &gt;= 2*min(M,N)+max(M,N).
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'O',
</span><span class="comment">*</span><span class="comment">                LWORK &gt;= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
</span><span class="comment">*</span><span class="comment">          if JOBZ = 'S' or 'A',
</span><span class="comment">*</span><span class="comment">                LWORK &gt;= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, a workspace query is assumed.  The optimal
</span><span class="comment">*</span><span class="comment">          size for the WORK array is calculated and stored in WORK(1),
</span><span class="comment">*</span><span class="comment">          and no other work except argument checking is performed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
</span><span class="comment">*</span><span class="comment">          If JOBZ = 'N', LRWORK &gt;= 5*min(M,N).
</span><span class="comment">*</span><span class="comment">          Otherwise, LRWORK &gt;= 5*min(M,N)*min(M,N) + 7*min(M,N)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  The updating process of <a name="DBDSDC.136"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a> did not converge.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Ming Gu and Huan Ren, Computer Science Division, University of
</span><span class="comment">*</span><span class="comment">     California at Berkeley, USA
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      INTEGER            LQUERV
      PARAMETER          ( LQUERV = -1 )
      COMPLEX*16         CZERO, CONE
      PARAMETER          ( CZERO = ( 0.0D+0, 0.0D+0 ),
     $                   CONE = ( 1.0D+0, 0.0D+0 ) )
      DOUBLE PRECISION   ZERO, ONE
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            WNTQA, WNTQAS, WNTQN, WNTQO, WNTQS
      INTEGER            BLK, CHUNK, I, IE, IERR, IL, IR, IRU, IRVT,
     $                   ISCL, ITAU, ITAUP, ITAUQ, IU, IVT, LDWKVT,
     $                   LDWRKL, LDWRKR, LDWRKU, MAXWRK, MINMN, MINWRK,
     $                   MNTHR1, MNTHR2, NRWORK, NWORK, WRKBL
      DOUBLE PRECISION   ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      INTEGER            IDUM( 1 )
      DOUBLE PRECISION   DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DBDSDC.169"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>, <a name="DLASCL.169"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>, <a name="XERBLA.169"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>, <a name="ZGEBRD.169"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>, <a name="ZGELQF.169"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>, ZGEMM,
     $                   <a name="ZGEQRF.170"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>, <a name="ZLACP2.170"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>, <a name="ZLACPY.170"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>, <a name="ZLACRM.170"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>, <a name="ZLARCM.170"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>, <a name="ZLASCL.170"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>,
     $                   <a name="ZLASET.171"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>, <a name="ZUNGBR.171"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>, <a name="ZUNGLQ.171"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>, <a name="ZUNGQR.171"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>, <a name="ZUNMBR.171"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.174"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.175"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      DOUBLE PRECISION   <a name="DLAMCH.176"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="ZLANGE.176"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>
      EXTERNAL           <a name="LSAME.177"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.177"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="DLAMCH.177"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="ZLANGE.177"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          INT, MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      MNTHR1 = INT( MINMN*17.0D0 / 9.0D0 )
      MNTHR2 = INT( MINMN*5.0D0 / 3.0D0 )
      WNTQA = <a name="LSAME.190"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'A'</span> )
      WNTQS = <a name="LSAME.191"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'S'</span> )
      WNTQAS = WNTQA .OR. WNTQS
      WNTQO = <a name="LSAME.193"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'O'</span> )
      WNTQN = <a name="LSAME.194"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBZ, <span class="string">'N'</span> )
      MINWRK = 1
      MAXWRK = 1
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTQA .OR. WNTQS .OR. WNTQO .OR. WNTQN ) ) THEN
         INFO = -1
      ELSE IF( M.LT.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDU.LT.1 .OR. ( WNTQAS .AND. LDU.LT.M ) .OR.
     $         ( WNTQO .AND. M.LT.N .AND. LDU.LT.M ) ) THEN
         INFO = -8
      ELSE IF( LDVT.LT.1 .OR. ( WNTQA .AND. LDVT.LT.N ) .OR.
     $         ( WNTQS .AND. LDVT.LT.MINMN ) .OR.
     $         ( WNTQO .AND. M.GE.N .AND. LDVT.LT.N ) ) THEN
         INFO = -10
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       CWorkspace refers to complex workspace, and RWorkspace to
</span><span class="comment">*</span><span class="comment">       real workspace. NB refers to the optimal block size for the
</span><span class="comment">*</span><span class="comment">       immediately following subroutine, as returned by <a name="ILAENV.221"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 .AND. M.GT.0 .AND. N.GT.0 ) THEN
         IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           There is no complex work space needed for bidiagonal SVD
</span><span class="comment">*</span><span class="comment">           The real work space needed for bidiagonal SVD is BDSPAC
</span><span class="comment">*</span><span class="comment">           for computing singular values and singular vectors; BDSPAN
</span><span class="comment">*</span><span class="comment">           for computing singular values only.
</span><span class="comment">*</span><span class="comment">           BDSPAC = 5*N*N + 7*N
</span><span class="comment">*</span><span class="comment">           BDSPAN = MAX(7*N+4, 3*N+2+SMLSIZ*(SMLSIZ+8))
</span><span class="comment">*</span><span class="comment">
</span>            IF( M.GE.MNTHR1 ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = N + N*<a name="ILAENV.238"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.238"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 2*N+2*N*
     $                     <a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.241"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  MINWRK = 3*N
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.247"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.247"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.248"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.248"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.251"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.251"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.253"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.253"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.255"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.255"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = M*N + N*N + WRKBL
                  MINWRK = 2*N*N + 3*N
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.262"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.262"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.263"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.263"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.266"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.266"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.268"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.268"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.270"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.270"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = N*N + 3*N
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.277"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEQRF.277"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.278"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGQR.278"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+2*N*
     $                    <a name="ILAENV.281"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.281"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.283"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.283"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 2*N+N*
     $                    <a name="ILAENV.285"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.285"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = N*N + WRKBL
                  MINWRK = N*N + 2*N + M
               END IF
            ELSE IF( M.GE.MNTHR2 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5 (M much larger than N, but not as much as MNTHR1)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*N + ( M+N )*<a name="ILAENV.293"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.293"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               MINWRK = 2*N + M
               IF( WNTQO ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.298"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.298"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.300"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.300"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, N, N, -1 ) )
                  MAXWRK = MAXWRK + M*N
                  MINWRK = MINWRK + N*N
               ELSE IF( WNTQS ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.305"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.305"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.307"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.307"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, N, N, -1 ) )
               ELSE IF( WNTQA ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.310"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.310"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+M*
     $                     <a name="ILAENV.312"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.312"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 6 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*N + ( M+N )*<a name="ILAENV.318"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.318"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               MINWRK = 2*N + M
               IF( WNTQO ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.323"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.323"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.325"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.325"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
                  MAXWRK = MAXWRK + M*N
                  MINWRK = MINWRK + N*N
               ELSE IF( WNTQS ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.330"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.330"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.332"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.332"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, N, N, -1 ) )
               ELSE IF( WNTQA ) THEN
                  MAXWRK = MAX( MAXWRK, 2*N+N*
     $                     <a name="ILAENV.335"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.335"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'PRC'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*N+M*
     $                     <a name="ILAENV.337"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.337"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
               END IF
            END IF
         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           There is no complex work space needed for bidiagonal SVD
</span><span class="comment">*</span><span class="comment">           The real work space needed for bidiagonal SVD is BDSPAC
</span><span class="comment">*</span><span class="comment">           for computing singular values and singular vectors; BDSPAN
</span><span class="comment">*</span><span class="comment">           for computing singular values only.
</span><span class="comment">*</span><span class="comment">           BDSPAC = 5*M*M + 7*M
</span><span class="comment">*</span><span class="comment">           BDSPAN = MAX(7*M+4, 3*M+2+SMLSIZ*(SMLSIZ+8))
</span><span class="comment">*</span><span class="comment">
</span>            IF( N.GE.MNTHR1 ) THEN
               IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.354"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.354"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 2*M+2*M*
     $                     <a name="ILAENV.357"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.357"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MINWRK = 3*M
               ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.363"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.363"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.364"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.364"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.367"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.367"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.369"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.369"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.371"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.371"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  MAXWRK = M*N + M*M + WRKBL
                  MINWRK = 2*M*M + 3*M
               ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.378"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.378"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.379"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.379"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.382"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.382"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.384"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.384"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.386"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.386"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = M*M + 3*M
               ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.393"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGELQF.393"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.394"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGLQ.394"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+2*M*
     $                    <a name="ILAENV.397"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.397"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.399"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.399"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 2*M+M*
     $                    <a name="ILAENV.401"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.401"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, M, -1 ) )
                  MAXWRK = M*M + WRKBL
                  MINWRK = M*M + 2*M + N
               END IF
            ELSE IF( N.GE.MNTHR2 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 5t (N much larger than M, but not as much as MNTHR1)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*M + ( M+N )*<a name="ILAENV.409"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.409"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               MINWRK = 2*M + N
               IF( WNTQO ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.414"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.416"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.416"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
                  MAXWRK = MAXWRK + M*N
                  MINWRK = MINWRK + M*M
               ELSE IF( WNTQS ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.421"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.421"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.423"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.423"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               ELSE IF( WNTQA ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+N*
     $                     <a name="ILAENV.426"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.426"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.428"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.428"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 6t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 2*M + ( M+N )*<a name="ILAENV.434"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZGEBRD.434"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               MINWRK = 2*M + N
               IF( WNTQO ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.439"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.439"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'PRC'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.441"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNMBR.441"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
                  MAXWRK = MAXWRK + M*N
                  MINWRK = MINWRK + M*M
               ELSE IF( WNTQS ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.446"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.446"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'PRC'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.448"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.448"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
               ELSE IF( WNTQA ) THEN
                  MAXWRK = MAX( MAXWRK, 2*M+N*
     $                     <a name="ILAENV.451"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.451"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'PRC'</span>, N, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M+M*
     $                     <a name="ILAENV.453"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="ZUNGBR.453"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>'</span>, <span class="string">'QLN'</span>, M, M, N, -1 ) )
               END IF
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
      END IF
      IF( INFO.EQ.0 ) THEN
         WORK( 1 ) = MAXWRK
         IF( LWORK.LT.MINWRK .AND. LWORK.NE.LQUERV )
     $      INFO = -13
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick returns
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.468"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="ZGESDD.468"></a><a href="zgesdd.f.html#ZGESDD.1">ZGESDD</a>'</span>, -INFO )
         RETURN
      END IF
      IF( LWORK.EQ.LQUERV )
     $   RETURN
      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.479"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="DLAMCH.480"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="ZLANGE.485"></a><a href="zlange.f.html#ZLANGE.1">ZLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="ZLASCL.489"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="ZLASCL.492"></a><a href="zlascl.f.html#ZLASCL.1">ZLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR1 ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEQRF.515"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.520"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, A( 2, 1 ),
     $                      LDA )
               IE = 1
               ITAUQ = 1
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.531"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, compute singular values only
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.540"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBZ='O')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IU = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKU = N
               IR = IU + LDWRKU*N
               IF( LWORK.GE.M*N+N*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IR) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKR = M
               ELSE
                  LDWRKR = ( LWORK-N*N-3*N ) / N
               END IF
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+2*N, prefer M*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEQRF.570"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK( IR ), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.575"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="ZLASET.576"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGQR.583"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer M*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.594"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, RWORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of R in WORK(IRU) and computing right singular vectors
</span><span class="comment">*</span><span class="comment">              of R in WORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = IE + N
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.607"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by the left singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N*N+3*N, prefer M*N+N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.616"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, WORK( IU ),
     $                      LDWRKU )
               CALL <a name="ZUNMBR.618"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by the right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.627"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.628"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in WORK(IR) and copying to A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N*N, prefer N*N+M*N)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               DO 10 I = 1, M, LDWRKR
                  CHUNK = MIN( M-I+1, LDWRKR )
                  CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, CONE, A( I, 1 ),
     $                        LDA, WORK( IU ), LDWRKU, CZERO,
     $                        WORK( IR ), LDWRKR )
                  CALL <a name="ZLACPY.642"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IR ), LDWRKR,
     $                         A( I, 1 ), LDA )
   10          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBZ='S')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IR = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKR = N
               ITAU = IR + LDWRKR*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEQRF.664"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.669"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
               CALL <a name="ZLASET.670"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, WORK( IR+1 ),
     $                      LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGQR.677"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer N*N+2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.688"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, RWORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = IE + N
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.701"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.710"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, U, LDU )
               CALL <a name="ZUNMBR.711"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.720"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.721"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.730"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, U, LDU, WORK( IR ), LDWRKR )
               CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, A, LDA, WORK( IR ),
     $                     LDWRKR, CZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 4 (M much larger than N, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IU = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKU = N
               ITAU = IU + LDWRKU*N
               NWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEQRF.752"></a><a href="zgeqrf.f.html#ZGEQRF.1">ZGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="ZLACPY.754"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGQR.760"></a><a href="zungqr.f.html#ZUNGQR.1">ZUNGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce R in A, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.765"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, A( 2, 1 ),
     $                      LDA )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + N
               NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.776"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( N, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               IRU = IE + N
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.789"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer N*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.798"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, WORK( IU ),
     $                      LDWRKU )
               CALL <a name="ZUNMBR.800"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of R
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.809"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.810"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">              WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, CONE, U, LDU, WORK( IU ),
     $                     LDWRKU, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.824"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE IF( M.GE.MNTHR2 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           MNTHR2 &lt;= M &lt; MNTHR1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5 (M much larger than N, but not as much as MNTHR1)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition, use
</span><span class="comment">*</span><span class="comment">           <a name="ZUNGBR.834"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a> and matrix multiplication to compute singular vectors
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            NRWORK = IE + N
            ITAUQ = 1
            ITAUP = ITAUQ + N
            NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.846"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute singular values only
</span><span class="comment">*</span><span class="comment">              (Cworkspace: 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.855"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               IU = NWORK
               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to VT, generate P**H
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.867"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.868"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.875"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = M
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IU) is LDWRKU by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = ( LWORK-3*N ) / N
               END IF
               NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.897"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply real matrix RWORK(IRVT) by P**H in VT,
</span><span class="comment">*</span><span class="comment">              storing the result in WORK(IU), copying to VT
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLARCM.906"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( N, N, RWORK( IRVT ), N, VT, LDVT,
     $                      WORK( IU ), LDWRKU, RWORK( NRWORK ) )
               CALL <a name="ZLACPY.908"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IU ), LDWRKU, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in A by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">              result in WORK(IU), copying to A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N, prefer M*N)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*N*N, prefer N*N+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>               NRWORK = IRVT
               DO 20 I = 1, M, LDWRKU
                  CHUNK = MIN( M-I+1, LDWRKU )
                  CALL <a name="ZLACRM.918"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( CHUNK, N, A( I, 1 ), LDA, RWORK( IRU ),
     $                         N, WORK( IU ), LDWRKU, RWORK( NRWORK ) )
                  CALL <a name="ZLACPY.920"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                         A( I, 1 ), LDA )
   20          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to VT, generate P**H
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.930"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.931"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to U, generate Q
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.938"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.939"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, N, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.951"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply real matrix RWORK(IRVT) by P**H in VT,
</span><span class="comment">*</span><span class="comment">              storing the result in A, copying to VT
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLARCM.960"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( N, N, RWORK( IRVT ), N, VT, LDVT, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.962"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">              result in A, copying to U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need N*N+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>               NRWORK = IRVT
               CALL <a name="ZLACRM.970"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( M, N, U, LDU, RWORK( IRU ), N, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.972"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to VT, generate P**H
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.979"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.980"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to U, generate Q
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.987"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.988"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.1000"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply real matrix RWORK(IRVT) by P**H in VT,
</span><span class="comment">*</span><span class="comment">              storing the result in A, copying to VT
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*N*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLARCM.1009"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( N, N, RWORK( IRVT ), N, VT, LDVT, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1011"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, N, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">              result in A, copying to U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*N*N)
</span><span class="comment">*</span><span class="comment">
</span>               NRWORK = IRVT
               CALL <a name="ZLACRM.1019"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( M, N, U, LDU, RWORK( IRU ), N, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1021"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR2
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 6 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">           Use <a name="ZUNMBR.1030"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a> to compute singular vectors
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            NRWORK = IE + N
            ITAUQ = 1
            ITAUP = ITAUQ + N
            NWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*N+M, prefer 2*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.1042"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute singular values only
</span><span class="comment">*</span><span class="comment">              (Cworkspace: 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1051"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, N, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               IU = NWORK
               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               IF( LWORK.GE.M*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = M
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IU ) is LDWRKU by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKU = ( LWORK-3*N ) / N
               END IF
               NWORK = IU + LDWRKU*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1077"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1086"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.1087"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by left singular vectors of A, copying
</span><span class="comment">*</span><span class="comment">              to A
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need M*N+2*N, prefer M*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLASET.1099"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, WORK( IU ),
     $                         LDWRKU )
                  CALL <a name="ZLACP2.1101"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, WORK( IU ),
     $                         LDWRKU )
                  CALL <a name="ZUNMBR.1103"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                         WORK( ITAUQ ), WORK( IU ), LDWRKU,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
                  CALL <a name="ZLACPY.1106"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IU ), LDWRKU, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Cworkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">                 (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.1113"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">                 result in WORK(IU), copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need N*N, prefer M*N)
</span><span class="comment">*</span><span class="comment">                 (Rworkspace: need 3*N*N, prefer N*N+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  NRWORK = IRVT
                  DO 30 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL <a name="ZLACRM.1124"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( CHUNK, N, A( I, 1 ), LDA,
     $                            RWORK( IRU ), N, WORK( IU ), LDWRKU,
     $                            RWORK( NRWORK ) )
                     CALL <a name="ZLACPY.1127"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   30             CONTINUE
               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.1143"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1152"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, U, LDU )
               CALL <a name="ZLACP2.1153"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, U, LDU )
               CALL <a name="ZUNMBR.1154"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1163"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.1164"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = NRWORK
               IRVT = IRU + N*N
               NRWORK = IRVT + N*N
               CALL <a name="DBDSDC.1178"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, N, S, RWORK( IE ), RWORK( IRU ),
     $                      N, RWORK( IRVT ), N, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set the right corner of U to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1184"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, M, CZERO, CZERO, U, LDU )
               IF( M.GT.N ) THEN
                  CALL <a name="ZLASET.1186"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M-N, M-N, CZERO, CONE,
     $                         U( N+1, N+1 ), LDU )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*N+M, prefer 2*N+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1195"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRU ), N, U, LDU )
               CALL <a name="ZUNMBR.1196"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*N, prefer 2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1205"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, N, N, RWORK( IRVT ), N, VT, LDVT )
               CALL <a name="ZUNMBR.1206"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, N, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR1 ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t (N much larger than M, JOBZ='N')
</span><span class="comment">*</span><span class="comment">              No singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGELQF.1233"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1238"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, A( 1, 2 ),
     $                      LDA )
               IE = 1
               ITAUQ = 1
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.1249"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
               NRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, compute singular values only
</span><span class="comment">*</span><span class="comment">              (CWorkspace: 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1258"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'N'</span>, M, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t (N much larger than M, JOBZ='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
               LDWKVT = M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IVT) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               IL = IVT + LDWKVT*M
               IF( LWORK.GE.M*N+M*M+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) M by N
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKL = M
                  CHUNK = N
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK(IL) is M by CHUNK
</span><span class="comment">*</span><span class="comment">
</span>                  LDWRKL = M
                  CHUNK = ( LWORK-M*M-3*M ) / M
               END IF
               ITAU = IL + LDWRKL*CHUNK
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGELQF.1293"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1298"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="ZLASET.1299"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGLQ.1306"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.1317"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, RWORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = IE + M
               IRVT = IRU + M*M
               NRWORK = IRVT + M*M
               CALL <a name="DBDSDC.1330"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix WORK(IU)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IU) by the left singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1339"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1340"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IVT) by the right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need N*N+3*N, prefer M*N+2*N+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1349"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, WORK( IVT ),
     $                      LDWKVT )
               CALL <a name="ZUNMBR.1351"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IL) by Q
</span><span class="comment">*</span><span class="comment">              in A, storing result in WORK(IL) and copying to A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M*M, prefer M*M+M*N))
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               DO 40 I = 1, N, CHUNK
                  BLK = MIN( N-I+1, CHUNK )
                  CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, CONE, WORK( IVT ), M,
     $                        A( 1, I ), LDA, CZERO, WORK( IL ),
     $                        LDWRKL )
                  CALL <a name="ZLACPY.1365"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IL ), LDWRKL,
     $                         A( 1, I ), LDA )
   40          CONTINUE
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">             Path 3t (N much larger than M, JOBZ='S')
</span><span class="comment">*</span><span class="comment">             M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">             M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IL = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IL) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWRKL = M
               ITAU = IL + LDWRKL*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGELQF.1387"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy L to WORK(IL), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1392"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWRKL )
               CALL <a name="ZLASET.1393"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO,
     $                      WORK( IL+LDWRKL ), LDWRKL )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGLQ.1400"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.1411"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, WORK( IL ), LDWRKL, S, RWORK( IE ),
     $                      WORK( ITAUQ ), WORK( ITAUP ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = IE + M
               IRVT = IRU + M*M
               NRWORK = IRVT + M*M
               CALL <a name="DBDSDC.1424"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1433"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1434"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by left singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1443"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, VT, LDVT )
               CALL <a name="ZUNMBR.1444"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, M, M, M, WORK( IL ), LDWRKL,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy VT to WORK(IL), multiply right singular vectors of L
</span><span class="comment">*</span><span class="comment">              in WORK(IL) by Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1453"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, VT, LDVT, WORK( IL ), LDWRKL )
               CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IL ), LDWRKL,
     $                     A, LDA, CZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTQA ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 9t (N much larger than M, JOBZ='A')
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IVT = 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              WORK(IVT) is M by M
</span><span class="comment">*</span><span class="comment">
</span>               LDWKVT = M
               ITAU = IVT + LDWKVT*M
               NWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGELQF.1475"></a><a href="zgelqf.f.html#ZGELQF.1">ZGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
               CALL <a name="ZLACPY.1477"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate Q in VT
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGLQ.1483"></a><a href="zunglq.f.html#ZUNGLQ.1">ZUNGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Produce L in A, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1488"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, A( 1, 2 ),
     $                      LDA )
               IE = 1
               ITAUQ = ITAU
               ITAUP = ITAUQ + M
               NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZGEBRD.1499"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, M, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                      IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRU = IE + M
               IRVT = IRU + M*M
               NRWORK = IRVT + M*M
               CALL <a name="DBDSDC.1512"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'U'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1521"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1522"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IVT) by right singular vectors of L
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M+3*M, prefer M*M+2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1531"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, WORK( IVT ),
     $                      LDWKVT )
               CALL <a name="ZUNMBR.1533"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, M, M, M, A, LDA,
     $                      WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply right singular vectors of L in WORK(IVT) by
</span><span class="comment">*</span><span class="comment">              Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL ZGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, CONE, WORK( IVT ), LDWKVT,
     $                     VT, LDVT, CZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1547"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE IF( N.GE.MNTHR2 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           MNTHR2 &lt;= N &lt; MNTHR1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 5t (N much larger than M, but not as much as MNTHR1)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition, use
</span><span class="comment">*</span><span class="comment">           <a name="ZUNGBR.1557"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a> and matrix multiplication to compute singular vectors
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            NRWORK = IE + M
            ITAUQ = 1
            ITAUP = ITAUQ + M
            NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: M)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.1570"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
<span class="comment">*</span><span class="comment">
</span>            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute singular values only
</span><span class="comment">*</span><span class="comment">              (Cworkspace: 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1580"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'N'</span>, M, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
               IVT = NWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to U, generate Q
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1592"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.1593"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Generate P**H in A
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZUNGBR.1600"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               LDWKVT = M
               IF( LWORK.GE.M*N+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  NWORK = IVT + LDWKVT*N
                  CHUNK = N
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by CHUNK
</span><span class="comment">*</span><span class="comment">
</span>                  CHUNK = ( LWORK-3*M ) / M
                  NWORK = IVT + LDWKVT*CHUNK
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1624"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by real matrix RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              storing the result in WORK(IVT), copying to U
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 2*M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACRM.1633"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( M, M, U, LDU, RWORK( IRU ), M, WORK( IVT ),
     $                      LDWKVT, RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1635"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IVT ), LDWKVT, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply RWORK(IRVT) by P**H in A, storing the
</span><span class="comment">*</span><span class="comment">              result in WORK(IVT), copying to A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need M*M, prefer M*N)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 2*M*M, prefer 2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>               NRWORK = IRU
               DO 50 I = 1, N, CHUNK
                  BLK = MIN( N-I+1, CHUNK )
                  CALL <a name="ZLARCM.1645"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( M, BLK, RWORK( IRVT ), M, A( 1, I ), LDA,
     $                         WORK( IVT ), LDWKVT, RWORK( NRWORK ) )
                  CALL <a name="ZLACPY.1647"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IVT ), LDWKVT,
     $                         A( 1, I ), LDA )
   50          CONTINUE
            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to U, generate Q
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1656"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.1657"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to VT, generate P**H
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1664"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.1665"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
               CALL <a name="DBDSDC.1677"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">              result in A, copying to U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACRM.1686"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( M, M, U, LDU, RWORK( IRU ), M, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1688"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply real matrix RWORK(IRVT) by P**H in VT,
</span><span class="comment">*</span><span class="comment">              storing the result in A, copying to VT
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need M*M+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>               NRWORK = IRU
               CALL <a name="ZLARCM.1696"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( M, N, RWORK( IRVT ), M, VT, LDVT, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1698"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to U, generate Q
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1705"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="ZUNGBR.1706"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy A to VT, generate P**H
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACPY.1713"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
               CALL <a name="ZUNGBR.1714"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, N, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
               CALL <a name="DBDSDC.1726"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply Q in U by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">              result in A, copying to U
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 3*M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACRM.1735"></a><a href="zlacrm.f.html#ZLACRM.1">ZLACRM</a>( M, M, U, LDU, RWORK( IRU ), M, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1737"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, M, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Multiply real matrix RWORK(IRVT) by P**H in VT,
</span><span class="comment">*</span><span class="comment">              storing the result in A, copying to VT
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need M*M+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLARCM.1744"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( M, N, RWORK( IRVT ), M, VT, LDVT, A, LDA,
     $                      RWORK( NRWORK ) )
               CALL <a name="ZLACPY.1746"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR2
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 6t (N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">           Use <a name="ZUNMBR.1755"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a> to compute singular vectors
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            NRWORK = IE + M
            ITAUQ = 1
            ITAUP = ITAUQ + M
            NWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*M+N, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: M)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="ZGEBRD.1767"></a><a href="zgebrd.f.html#ZGEBRD.1">ZGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( NWORK ), LWORK-NWORK+1,
     $                   IERR )
            IF( WNTQN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute singular values only
</span><span class="comment">*</span><span class="comment">              (Cworkspace: 0)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need BDSPAN)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1776"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'N'</span>, M, S, RWORK( IE ), DUM, 1, DUM, 1,
     $                      DUM, IDUM, RWORK( NRWORK ), IWORK, INFO )
            ELSE IF( WNTQO ) THEN
               LDWKVT = M
               IVT = NWORK
               IF( LWORK.GE.M*N+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by N
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLASET.1785"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, WORK( IVT ),
     $                         LDWKVT )
                  NWORK = IVT + LDWKVT*N
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 WORK( IVT ) is M by CHUNK
</span><span class="comment">*</span><span class="comment">
</span>                  CHUNK = ( LWORK-3*M ) / M
                  NWORK = IVT + LDWKVT*CHUNK
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
               CALL <a name="DBDSDC.1805"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1814"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1815"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*N+3*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix WORK(IVT)
</span><span class="comment">*</span><span class="comment">              Overwrite WORK(IVT) by right singular vectors of A,
</span><span class="comment">*</span><span class="comment">              copying to A
</span><span class="comment">*</span><span class="comment">              (Cworkspace: need M*N+2*M, prefer M*N+M+M*NB)
</span><span class="comment">*</span><span class="comment">              (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZLACP2.1827"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, WORK( IVT ),
     $                         LDWKVT )
                  CALL <a name="ZUNMBR.1829"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                         WORK( ITAUP ), WORK( IVT ), LDWKVT,
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
                  CALL <a name="ZLACPY.1832"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, N, WORK( IVT ), LDWKVT, A, LDA )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate P**H in A
</span><span class="comment">*</span><span class="comment">                 (Cworkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">                 (Rworkspace: need 0)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="ZUNGBR.1839"></a><a href="zungbr.f.html#ZUNGBR.1">ZUNGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( NWORK ), LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by real matrix RWORK(IRU), storing the
</span><span class="comment">*</span><span class="comment">                 result in WORK(IU), copying to A
</span><span class="comment">*</span><span class="comment">                 (CWorkspace: need M*M, prefer M*N)
</span><span class="comment">*</span><span class="comment">                 (Rworkspace: need 3*M*M, prefer M*M+2*M*N)
</span><span class="comment">*</span><span class="comment">
</span>                  NRWORK = IRU
                  DO 60 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL <a name="ZLARCM.1850"></a><a href="zlarcm.f.html#ZLARCM.1">ZLARCM</a>( M, BLK, RWORK( IRVT ), M, A( 1, I ),
     $                            LDA, WORK( IVT ), LDWKVT,
     $                            RWORK( NRWORK ) )
                     CALL <a name="ZLACPY.1853"></a><a href="zlacpy.f.html#ZLACPY.1">ZLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IVT ), LDWKVT,
     $                            A( 1, I ), LDA )
   60             CONTINUE
               END IF
            ELSE IF( WNTQS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
               CALL <a name="DBDSDC.1868"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1877"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1878"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1887"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, M, N, CZERO, CZERO, VT, LDVT )
               CALL <a name="ZLACP2.1888"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, VT, LDVT )
               CALL <a name="ZUNMBR.1889"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, M, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal SVD, computing left singular vectors
</span><span class="comment">*</span><span class="comment">              of bidiagonal matrix in RWORK(IRU) and computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of bidiagonal matrix in RWORK(IRVT)
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 0)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               IRVT = NRWORK
               IRU = IRVT + M*M
               NRWORK = IRU + M*M
<span class="comment">*</span><span class="comment">
</span>               CALL <a name="DBDSDC.1904"></a><a href="dbdsdc.f.html#DBDSDC.1">DBDSDC</a>( <span class="string">'L'</span>, <span class="string">'I'</span>, M, S, RWORK( IE ), RWORK( IRU ),
     $                      M, RWORK( IRVT ), M, DUM, IDUM,
     $                      RWORK( NRWORK ), IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRU) to complex matrix U
</span><span class="comment">*</span><span class="comment">              Overwrite U by left singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1913"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRU ), M, U, LDU )
               CALL <a name="ZUNMBR.1914"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'N'</span>, M, M, N, A, LDA,
     $                      WORK( ITAUQ ), U, LDU, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Set all of VT to identity matrix
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLASET.1920"></a><a href="zlaset.f.html#ZLASET.1">ZLASET</a>( <span class="string">'F'</span>, N, N, CZERO, CONE, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy real matrix RWORK(IRVT) to complex matrix VT
</span><span class="comment">*</span><span class="comment">              Overwrite VT by right singular vectors of A
</span><span class="comment">*</span><span class="comment">              (CWorkspace: need 2*M+N, prefer 2*M+N*NB)
</span><span class="comment">*</span><span class="comment">              (RWorkspace: M*M)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="ZLACP2.1927"></a><a href="zlacp2.f.html#ZLACP2.1">ZLACP2</a>( <span class="string">'F'</span>, M, M, RWORK( IRVT ), M, VT, LDVT )
               CALL <a name="ZUNMBR.1928"></a><a href="zunmbr.f.html#ZUNMBR.1">ZUNMBR</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, <span class="string">'C'</span>, N, N, M, A, LDA,
     $                      WORK( ITAUP ), VT, LDVT, WORK( NWORK ),
     $                      LWORK-NWORK+1, IERR )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.1941"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )
     $      CALL <a name="DLASCL.1944"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN-1, 1,
     $                   RWORK( IE ), MINMN, IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.1947"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )
     $      CALL <a name="DLASCL.1950"></a><a href="dlascl.f.html#DLASCL.1">DLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN-1, 1,
     $                   RWORK( IE ), MINMN, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="ZGESDD.1960"></a><a href="zgesdd.f.html#ZGESDD.1">ZGESDD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
