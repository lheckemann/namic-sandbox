<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dhgeqz.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DHGEQZ.1"></a><a href="dhgeqz.f.html#DHGEQZ.1">DHGEQZ</a>( JOB, COMPQ, COMPZ, N, ILO, IHI, H, LDH, T, LDT,
     $                   ALPHAR, ALPHAI, BETA, Q, LDQ, Z, LDZ, WORK,
     $                   LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          COMPQ, COMPZ, JOB
      INTEGER            IHI, ILO, INFO, LDH, LDQ, LDT, LDZ, LWORK, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      DOUBLE PRECISION   ALPHAI( * ), ALPHAR( * ), BETA( * ),
     $                   H( LDH, * ), Q( LDQ, * ), T( LDT, * ),
     $                   WORK( * ), Z( LDZ, * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DHGEQZ.22"></a><a href="dhgeqz.f.html#DHGEQZ.1">DHGEQZ</a> computes the eigenvalues of a real matrix pair (H,T),
</span><span class="comment">*</span><span class="comment">  where H is an upper Hessenberg matrix and T is upper triangular,
</span><span class="comment">*</span><span class="comment">  using the double-shift QZ method.
</span><span class="comment">*</span><span class="comment">  Matrix pairs of this type are produced by the reduction to
</span><span class="comment">*</span><span class="comment">  generalized upper Hessenberg form of a real matrix pair (A,B):
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  as computed by <a name="DGGHRD.30"></a><a href="dgghrd.f.html#DGGHRD.1">DGGHRD</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If JOB='S', then the Hessenberg-triangular pair (H,T) is
</span><span class="comment">*</span><span class="comment">  also reduced to generalized Schur form,
</span><span class="comment">*</span><span class="comment">  
</span><span class="comment">*</span><span class="comment">     H = Q*S*Z**T,  T = Q*P*Z**T,
</span><span class="comment">*</span><span class="comment">  
</span><span class="comment">*</span><span class="comment">  where Q and Z are orthogonal matrices, P is an upper triangular
</span><span class="comment">*</span><span class="comment">  matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
</span><span class="comment">*</span><span class="comment">  diagonal blocks.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
</span><span class="comment">*</span><span class="comment">  (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
</span><span class="comment">*</span><span class="comment">  eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Additionally, the 2-by-2 upper triangular diagonal blocks of P
</span><span class="comment">*</span><span class="comment">  corresponding to 2-by-2 blocks of S are reduced to positive diagonal
</span><span class="comment">*</span><span class="comment">  form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
</span><span class="comment">*</span><span class="comment">  P(j,j) &gt; 0, and P(j+1,j+1) &gt; 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally, the orthogonal matrix Q from the generalized Schur
</span><span class="comment">*</span><span class="comment">  factorization may be postmultiplied into an input matrix Q1, and the
</span><span class="comment">*</span><span class="comment">  orthogonal matrix Z may be postmultiplied into an input matrix Z1.
</span><span class="comment">*</span><span class="comment">  If Q1 and Z1 are the orthogonal matrices from <a name="DGGHRD.53"></a><a href="dgghrd.f.html#DGGHRD.1">DGGHRD</a> that reduced
</span><span class="comment">*</span><span class="comment">  the matrix pair (A,B) to generalized upper Hessenberg form, then the
</span><span class="comment">*</span><span class="comment">  output matrices Q1*Q and Z1*Z are the orthogonal factors from the
</span><span class="comment">*</span><span class="comment">  generalized Schur factorization of (A,B):
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
</span><span class="comment">*</span><span class="comment">  
</span><span class="comment">*</span><span class="comment">  To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
</span><span class="comment">*</span><span class="comment">  of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
</span><span class="comment">*</span><span class="comment">  complex and beta real.
</span><span class="comment">*</span><span class="comment">  If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
</span><span class="comment">*</span><span class="comment">  generalized nonsymmetric eigenvalue problem (GNEP)
</span><span class="comment">*</span><span class="comment">     A*x = lambda*B*x
</span><span class="comment">*</span><span class="comment">  and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
</span><span class="comment">*</span><span class="comment">  alternate form of the GNEP
</span><span class="comment">*</span><span class="comment">     mu*A*y = B*y.
</span><span class="comment">*</span><span class="comment">  Real eigenvalues can be read directly from the generalized Schur
</span><span class="comment">*</span><span class="comment">  form: 
</span><span class="comment">*</span><span class="comment">    alpha = S(i,i), beta = P(i,i).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix
</span><span class="comment">*</span><span class="comment">       Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),
</span><span class="comment">*</span><span class="comment">       pp. 241--256.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOB     (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'E': Compute eigenvalues only;
</span><span class="comment">*</span><span class="comment">          = 'S': Compute eigenvalues and the Schur form. 
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  COMPQ   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': Left Schur vectors (Q) are not computed;
</span><span class="comment">*</span><span class="comment">          = 'I': Q is initialized to the unit matrix and the matrix Q
</span><span class="comment">*</span><span class="comment">                 of left Schur vectors of (H,T) is returned;
</span><span class="comment">*</span><span class="comment">          = 'V': Q must contain an orthogonal matrix Q1 on entry and
</span><span class="comment">*</span><span class="comment">                 the product Q1*Q is returned.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  COMPZ   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N': Right Schur vectors (Z) are not computed;
</span><span class="comment">*</span><span class="comment">          = 'I': Z is initialized to the unit matrix and the matrix Z
</span><span class="comment">*</span><span class="comment">                 of right Schur vectors of (H,T) is returned;
</span><span class="comment">*</span><span class="comment">          = 'V': Z must contain an orthogonal matrix Z1 on entry and
</span><span class="comment">*</span><span class="comment">                 the product Z1*Z is returned.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices H, T, Q, and Z.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ILO     (input) INTEGER
</span><span class="comment">*</span><span class="comment">  IHI     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          ILO and IHI mark the rows and columns of H which are in
</span><span class="comment">*</span><span class="comment">          Hessenberg form.  It is assumed that A is already upper
</span><span class="comment">*</span><span class="comment">          triangular in rows and columns 1:ILO-1 and IHI+1:N.
</span><span class="comment">*</span><span class="comment">          If N &gt; 0, 1 &lt;= ILO &lt;= IHI &lt;= N; if N = 0, ILO=1 and IHI=0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  H       (input/output) DOUBLE PRECISION array, dimension (LDH, N)
</span><span class="comment">*</span><span class="comment">          On entry, the N-by-N upper Hessenberg matrix H.
</span><span class="comment">*</span><span class="comment">          On exit, if JOB = 'S', H contains the upper quasi-triangular
</span><span class="comment">*</span><span class="comment">          matrix S from the generalized Schur factorization;
</span><span class="comment">*</span><span class="comment">          2-by-2 diagonal blocks (corresponding to complex conjugate
</span><span class="comment">*</span><span class="comment">          pairs of eigenvalues) are returned in standard form, with
</span><span class="comment">*</span><span class="comment">          H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) &lt; 0.
</span><span class="comment">*</span><span class="comment">          If JOB = 'E', the diagonal blocks of H match those of S, but
</span><span class="comment">*</span><span class="comment">          the rest of H is unspecified.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDH     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array H.  LDH &gt;= max( 1, N ).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  T       (input/output) DOUBLE PRECISION array, dimension (LDT, N)
</span><span class="comment">*</span><span class="comment">          On entry, the N-by-N upper triangular matrix T.
</span><span class="comment">*</span><span class="comment">          On exit, if JOB = 'S', T contains the upper triangular
</span><span class="comment">*</span><span class="comment">          matrix P from the generalized Schur factorization;
</span><span class="comment">*</span><span class="comment">          2-by-2 diagonal blocks of P corresponding to 2-by-2 blocks of S
</span><span class="comment">*</span><span class="comment">          are reduced to positive diagonal form, i.e., if H(j+1,j) is
</span><span class="comment">*</span><span class="comment">          non-zero, then T(j+1,j) = T(j,j+1) = 0, T(j,j) &gt; 0, and
</span><span class="comment">*</span><span class="comment">          T(j+1,j+1) &gt; 0.
</span><span class="comment">*</span><span class="comment">          If JOB = 'E', the diagonal blocks of T match those of P, but
</span><span class="comment">*</span><span class="comment">          the rest of T is unspecified.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDT     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array T.  LDT &gt;= max( 1, N ).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The real parts of each scalar alpha defining an eigenvalue
</span><span class="comment">*</span><span class="comment">          of GNEP.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The imaginary parts of each scalar alpha defining an
</span><span class="comment">*</span><span class="comment">          eigenvalue of GNEP.
</span><span class="comment">*</span><span class="comment">          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if
</span><span class="comment">*</span><span class="comment">          positive, then the j-th and (j+1)-st eigenvalues are a
</span><span class="comment">*</span><span class="comment">          complex conjugate pair, with ALPHAI(j+1) = -ALPHAI(j).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BETA    (output) DOUBLE PRECISION array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The scalars beta that define the eigenvalues of GNEP.
</span><span class="comment">*</span><span class="comment">          Together, the quantities alpha = (ALPHAR(j),ALPHAI(j)) and
</span><span class="comment">*</span><span class="comment">          beta = BETA(j) represent the j-th eigenvalue of the matrix
</span><span class="comment">*</span><span class="comment">          pair (A,B), in one of the forms lambda = alpha/beta or
</span><span class="comment">*</span><span class="comment">          mu = beta/alpha.  Since either lambda or mu may overflow,
</span><span class="comment">*</span><span class="comment">          they should not, in general, be computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
</span><span class="comment">*</span><span class="comment">          On entry, if COMPZ = 'V', the orthogonal matrix Q1 used in
</span><span class="comment">*</span><span class="comment">          the reduction of (A,B) to generalized Hessenberg form.
</span><span class="comment">*</span><span class="comment">          On exit, if COMPZ = 'I', the orthogonal matrix of left Schur
</span><span class="comment">*</span><span class="comment">          vectors of (H,T), and if COMPZ = 'V', the orthogonal matrix
</span><span class="comment">*</span><span class="comment">          of left Schur vectors of (A,B).
</span><span class="comment">*</span><span class="comment">          Not referenced if COMPZ = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDQ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array Q.  LDQ &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If COMPQ='V' or 'I', then LDQ &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
</span><span class="comment">*</span><span class="comment">          On entry, if COMPZ = 'V', the orthogonal matrix Z1 used in
</span><span class="comment">*</span><span class="comment">          the reduction of (A,B) to generalized Hessenberg form.
</span><span class="comment">*</span><span class="comment">          On exit, if COMPZ = 'I', the orthogonal matrix of
</span><span class="comment">*</span><span class="comment">          right Schur vectors of (H,T), and if COMPZ = 'V', the
</span><span class="comment">*</span><span class="comment">          orthogonal matrix of right Schur vectors of (A,B).
</span><span class="comment">*</span><span class="comment">          Not referenced if COMPZ = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDZ     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array Z.  LDZ &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If COMPZ='V' or 'I', then LDZ &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.  LWORK &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.187"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0: successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0: if INFO = -i, the i-th argument had an illegal value
</span><span class="comment">*</span><span class="comment">          = 1,...,N: the QZ iteration did not converge.  (H,T) is not
</span><span class="comment">*</span><span class="comment">                     in Schur form, but ALPHAR(i), ALPHAI(i), and
</span><span class="comment">*</span><span class="comment">                     BETA(i), i=INFO+1,...,N should be correct.
</span><span class="comment">*</span><span class="comment">          = N+1,...,2*N: the shift calculation failed.  (H,T) is not
</span><span class="comment">*</span><span class="comment">                     in Schur form, but ALPHAR(i), ALPHAI(i), and
</span><span class="comment">*</span><span class="comment">                     BETA(i), i=INFO-N+1,...,N should be correct.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Iteration counters:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JITER  -- counts iterations.
</span><span class="comment">*</span><span class="comment">  IITER  -- counts iterations run since ILAST was last
</span><span class="comment">*</span><span class="comment">            changed.  This is therefore reset only when a 1-by-1 or
</span><span class="comment">*</span><span class="comment">            2-by-2 block deflates off the bottom.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span><span class="comment">*</span><span class="comment">    $                     SAFETY = 1.0E+0 )
</span>      DOUBLE PRECISION   HALF, ZERO, ONE, SAFETY
      PARAMETER          ( HALF = 0.5D+0, ZERO = 0.0D+0, ONE = 1.0D+0,
     $                   SAFETY = 1.0D+2 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            ILAZR2, ILAZRO, ILPIVT, ILQ, ILSCHR, ILZ,
     $                   LQUERY
      INTEGER            ICOMPQ, ICOMPZ, IFIRST, IFRSTM, IITER, ILAST,
     $                   ILASTM, IN, ISCHUR, ISTART, J, JC, JCH, JITER,
     $                   JR, MAXIT
      DOUBLE PRECISION   A11, A12, A1I, A1R, A21, A22, A2I, A2R, AD11,
     $                   AD11L, AD12, AD12L, AD21, AD21L, AD22, AD22L,
     $                   AD32L, AN, ANORM, ASCALE, ATOL, B11, B1A, B1I,
     $                   B1R, B22, B2A, B2I, B2R, BN, BNORM, BSCALE,
     $                   BTOL, C, C11I, C11R, C12, C21, C22I, C22R, CL,
     $                   CQ, CR, CZ, ESHIFT, S, S1, S1INV, S2, SAFMAX,
     $                   SAFMIN, SCALE, SL, SQI, SQR, SR, SZI, SZR, T1,
     $                   TAU, TEMP, TEMP2, TEMPI, TEMPR, U1, U12, U12L,
     $                   U2, ULP, VS, W11, W12, W21, W22, WABS, WI, WR,
     $                   WR2
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   V( 3 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.238"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      DOUBLE PRECISION   <a name="DLAMCH.239"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANHS.239"></a><a href="dlanhs.f.html#DLANHS.1">DLANHS</a>, <a name="DLAPY2.239"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>, <a name="DLAPY3.239"></a><a href="dlapy3.f.html#DLAPY3.1">DLAPY3</a>
      EXTERNAL           <a name="LSAME.240"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="DLAMCH.240"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLANHS.240"></a><a href="dlanhs.f.html#DLANHS.1">DLANHS</a>, <a name="DLAPY2.240"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>, <a name="DLAPY3.240"></a><a href="dlapy3.f.html#DLAPY3.1">DLAPY3</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="DLAG2.243"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a>, <a name="DLARFG.243"></a><a href="dlarfg.f.html#DLARFG.1">DLARFG</a>, <a name="DLARTG.243"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>, <a name="DLASET.243"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>, <a name="DLASV2.243"></a><a href="dlasv2.f.html#DLASV2.1">DLASV2</a>, DROT,
     $                   <a name="XERBLA.244"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, DBLE, MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode JOB, COMPQ, COMPZ
</span><span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.253"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'E'</span> ) ) THEN
         ILSCHR = .FALSE.
         ISCHUR = 1
      ELSE IF( <a name="LSAME.256"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'S'</span> ) ) THEN
         ILSCHR = .TRUE.
         ISCHUR = 2
      ELSE
         ISCHUR = 0
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.263"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPQ, <span class="string">'N'</span> ) ) THEN
         ILQ = .FALSE.
         ICOMPQ = 1
      ELSE IF( <a name="LSAME.266"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPQ, <span class="string">'V'</span> ) ) THEN
         ILQ = .TRUE.
         ICOMPQ = 2
      ELSE IF( <a name="LSAME.269"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPQ, <span class="string">'I'</span> ) ) THEN
         ILQ = .TRUE.
         ICOMPQ = 3
      ELSE
         ICOMPQ = 0
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.276"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPZ, <span class="string">'N'</span> ) ) THEN
         ILZ = .FALSE.
         ICOMPZ = 1
      ELSE IF( <a name="LSAME.279"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPZ, <span class="string">'V'</span> ) ) THEN
         ILZ = .TRUE.
         ICOMPZ = 2
      ELSE IF( <a name="LSAME.282"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( COMPZ, <span class="string">'I'</span> ) ) THEN
         ILZ = .TRUE.
         ICOMPZ = 3
      ELSE
         ICOMPZ = 0
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Check Argument Values
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      WORK( 1 ) = MAX( 1, N )
      LQUERY = ( LWORK.EQ.-1 )
      IF( ISCHUR.EQ.0 ) THEN
         INFO = -1
      ELSE IF( ICOMPQ.EQ.0 ) THEN
         INFO = -2
      ELSE IF( ICOMPZ.EQ.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( ILO.LT.1 ) THEN
         INFO = -5
      ELSE IF( IHI.GT.N .OR. IHI.LT.ILO-1 ) THEN
         INFO = -6
      ELSE IF( LDH.LT.N ) THEN
         INFO = -8
      ELSE IF( LDT.LT.N ) THEN
         INFO = -10
      ELSE IF( LDQ.LT.1 .OR. ( ILQ .AND. LDQ.LT.N ) ) THEN
         INFO = -15
      ELSE IF( LDZ.LT.1 .OR. ( ILZ .AND. LDZ.LT.N ) ) THEN
         INFO = -17
      ELSE IF( LWORK.LT.MAX( 1, N ) .AND. .NOT.LQUERY ) THEN
         INFO = -19
      END IF
      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.318"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DHGEQZ.318"></a><a href="dhgeqz.f.html#DHGEQZ.1">DHGEQZ</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.LE.0 ) THEN
         WORK( 1 ) = DBLE( 1 )
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Initialize Q and Z
</span><span class="comment">*</span><span class="comment">
</span>      IF( ICOMPQ.EQ.3 )
     $   CALL <a name="DLASET.334"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'Full'</span>, N, N, ZERO, ONE, Q, LDQ )
      IF( ICOMPZ.EQ.3 )
     $   CALL <a name="DLASET.336"></a><a href="dlaset.f.html#DLASET.1">DLASET</a>( <span class="string">'Full'</span>, N, N, ZERO, ONE, Z, LDZ )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Machine Constants
</span><span class="comment">*</span><span class="comment">
</span>      IN = IHI + 1 - ILO
      SAFMIN = <a name="DLAMCH.341"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> )
      SAFMAX = ONE / SAFMIN
      ULP = <a name="DLAMCH.343"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'E'</span> )*<a name="DLAMCH.343"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'B'</span> )
      ANORM = <a name="DLANHS.344"></a><a href="dlanhs.f.html#DLANHS.1">DLANHS</a>( <span class="string">'F'</span>, IN, H( ILO, ILO ), LDH, WORK )
      BNORM = <a name="DLANHS.345"></a><a href="dlanhs.f.html#DLANHS.1">DLANHS</a>( <span class="string">'F'</span>, IN, T( ILO, ILO ), LDT, WORK )
      ATOL = MAX( SAFMIN, ULP*ANORM )
      BTOL = MAX( SAFMIN, ULP*BNORM )
      ASCALE = ONE / MAX( SAFMIN, ANORM )
      BSCALE = ONE / MAX( SAFMIN, BNORM )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Set Eigenvalues IHI+1:N
</span><span class="comment">*</span><span class="comment">
</span>      DO 30 J = IHI + 1, N
         IF( T( J, J ).LT.ZERO ) THEN
            IF( ILSCHR ) THEN
               DO 10 JR = 1, J
                  H( JR, J ) = -H( JR, J )
                  T( JR, J ) = -T( JR, J )
   10          CONTINUE
            ELSE
               H( J, J ) = -H( J, J )
               T( J, J ) = -T( J, J )
            END IF
            IF( ILZ ) THEN
               DO 20 JR = 1, N
                  Z( JR, J ) = -Z( JR, J )
   20          CONTINUE
            END IF
         END IF
         ALPHAR( J ) = H( J, J )
         ALPHAI( J ) = ZERO
         BETA( J ) = T( J, J )
   30 CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If IHI &lt; ILO, skip QZ steps
</span><span class="comment">*</span><span class="comment">
</span>      IF( IHI.LT.ILO )
     $   GO TO 380
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     MAIN QZ ITERATION LOOP
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Initialize dynamic indices
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Eigenvalues ILAST+1:N have been found.
</span><span class="comment">*</span><span class="comment">        Column operations modify rows IFRSTM:whatever.
</span><span class="comment">*</span><span class="comment">        Row operations modify columns whatever:ILASTM.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If only eigenvalues are being computed, then
</span><span class="comment">*</span><span class="comment">        IFRSTM is the row of the last splitting row above row ILAST;
</span><span class="comment">*</span><span class="comment">        this is always at least ILO.
</span><span class="comment">*</span><span class="comment">     IITER counts iterations since the last eigenvalue was found,
</span><span class="comment">*</span><span class="comment">        to tell when to use an extraordinary shift.
</span><span class="comment">*</span><span class="comment">     MAXIT is the maximum number of QZ sweeps allowed.
</span><span class="comment">*</span><span class="comment">
</span>      ILAST = IHI
      IF( ILSCHR ) THEN
         IFRSTM = 1
         ILASTM = N
      ELSE
         IFRSTM = ILO
         ILASTM = IHI
      END IF
      IITER = 0
      ESHIFT = ZERO
      MAXIT = 30*( IHI-ILO+1 )
<span class="comment">*</span><span class="comment">
</span>      DO 360 JITER = 1, MAXIT
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Split the matrix if possible.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Two tests:
</span><span class="comment">*</span><span class="comment">           1: H(j,j-1)=0  or  j=ILO
</span><span class="comment">*</span><span class="comment">           2: T(j,j)=0
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILAST.EQ.ILO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Special case: j=ILAST
</span><span class="comment">*</span><span class="comment">
</span>            GO TO 80
         ELSE
            IF( ABS( H( ILAST, ILAST-1 ) ).LE.ATOL ) THEN
               H( ILAST, ILAST-1 ) = ZERO
               GO TO 80
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         IF( ABS( T( ILAST, ILAST ) ).LE.BTOL ) THEN
            T( ILAST, ILAST ) = ZERO
            GO TO 70
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        General case: j&lt;ILAST
</span><span class="comment">*</span><span class="comment">
</span>         DO 60 J = ILAST - 1, ILO, -1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Test 1: for H(j,j-1)=0 or j=ILO
</span><span class="comment">*</span><span class="comment">
</span>            IF( J.EQ.ILO ) THEN
               ILAZRO = .TRUE.
            ELSE
               IF( ABS( H( J, J-1 ) ).LE.ATOL ) THEN
                  H( J, J-1 ) = ZERO
                  ILAZRO = .TRUE.
               ELSE
                  ILAZRO = .FALSE.
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Test 2: for T(j,j)=0
</span><span class="comment">*</span><span class="comment">
</span>            IF( ABS( T( J, J ) ).LT.BTOL ) THEN
               T( J, J ) = ZERO
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Test 1a: Check for 2 consecutive small subdiagonals in A
</span><span class="comment">*</span><span class="comment">
</span>               ILAZR2 = .FALSE.
               IF( .NOT.ILAZRO ) THEN
                  TEMP = ABS( H( J, J-1 ) )
                  TEMP2 = ABS( H( J, J ) )
                  TEMPR = MAX( TEMP, TEMP2 )
                  IF( TEMPR.LT.ONE .AND. TEMPR.NE.ZERO ) THEN
                     TEMP = TEMP / TEMPR
                     TEMP2 = TEMP2 / TEMPR
                  END IF
                  IF( TEMP*( ASCALE*ABS( H( J+1, J ) ) ).LE.TEMP2*
     $                ( ASCALE*ATOL ) )ILAZR2 = .TRUE.
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If both tests pass (1 &amp; 2), i.e., the leading diagonal
</span><span class="comment">*</span><span class="comment">              element of B in the block is zero, split a 1x1 block off
</span><span class="comment">*</span><span class="comment">              at the top. (I.e., at the J-th row/column) The leading
</span><span class="comment">*</span><span class="comment">              diagonal element of the remainder can also be zero, so
</span><span class="comment">*</span><span class="comment">              this may have to be done repeatedly.
</span><span class="comment">*</span><span class="comment">
</span>               IF( ILAZRO .OR. ILAZR2 ) THEN
                  DO 40 JCH = J, ILAST - 1
                     TEMP = H( JCH, JCH )
                     CALL <a name="DLARTG.478"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, H( JCH+1, JCH ), C, S,
     $                            H( JCH, JCH ) )
                     H( JCH+1, JCH ) = ZERO
                     CALL DROT( ILASTM-JCH, H( JCH, JCH+1 ), LDH,
     $                          H( JCH+1, JCH+1 ), LDH, C, S )
                     CALL DROT( ILASTM-JCH, T( JCH, JCH+1 ), LDT,
     $                          T( JCH+1, JCH+1 ), LDT, C, S )
                     IF( ILQ )
     $                  CALL DROT( N, Q( 1, JCH ), 1, Q( 1, JCH+1 ), 1,
     $                             C, S )
                     IF( ILAZR2 )
     $                  H( JCH, JCH-1 ) = H( JCH, JCH-1 )*C
                     ILAZR2 = .FALSE.
                     IF( ABS( T( JCH+1, JCH+1 ) ).GE.BTOL ) THEN
                        IF( JCH+1.GE.ILAST ) THEN
                           GO TO 80
                        ELSE
                           IFIRST = JCH + 1
                           GO TO 110
                        END IF
                     END IF
                     T( JCH+1, JCH+1 ) = ZERO
   40             CONTINUE
                  GO TO 70
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Only test 2 passed -- chase the zero to T(ILAST,ILAST)
</span><span class="comment">*</span><span class="comment">                 Then process as in the case T(ILAST,ILAST)=0
</span><span class="comment">*</span><span class="comment">
</span>                  DO 50 JCH = J, ILAST - 1
                     TEMP = T( JCH, JCH+1 )
                     CALL <a name="DLARTG.509"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, T( JCH+1, JCH+1 ), C, S,
     $                            T( JCH, JCH+1 ) )
                     T( JCH+1, JCH+1 ) = ZERO
                     IF( JCH.LT.ILASTM-1 )
     $                  CALL DROT( ILASTM-JCH-1, T( JCH, JCH+2 ), LDT,
     $                             T( JCH+1, JCH+2 ), LDT, C, S )
                     CALL DROT( ILASTM-JCH+2, H( JCH, JCH-1 ), LDH,
     $                          H( JCH+1, JCH-1 ), LDH, C, S )
                     IF( ILQ )
     $                  CALL DROT( N, Q( 1, JCH ), 1, Q( 1, JCH+1 ), 1,
     $                             C, S )
                     TEMP = H( JCH+1, JCH )
                     CALL <a name="DLARTG.521"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, H( JCH+1, JCH-1 ), C, S,
     $                            H( JCH+1, JCH ) )
                     H( JCH+1, JCH-1 ) = ZERO
                     CALL DROT( JCH+1-IFRSTM, H( IFRSTM, JCH ), 1,
     $                          H( IFRSTM, JCH-1 ), 1, C, S )
                     CALL DROT( JCH-IFRSTM, T( IFRSTM, JCH ), 1,
     $                          T( IFRSTM, JCH-1 ), 1, C, S )
                     IF( ILZ )
     $                  CALL DROT( N, Z( 1, JCH ), 1, Z( 1, JCH-1 ), 1,
     $                             C, S )
   50             CONTINUE
                  GO TO 70
               END IF
            ELSE IF( ILAZRO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Only test 1 passed -- work on J:ILAST
</span><span class="comment">*</span><span class="comment">
</span>               IFIRST = J
               GO TO 110
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Neither test passed -- try next J
</span><span class="comment">*</span><span class="comment">
</span>   60    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        (Drop-through is &quot;impossible&quot;)
</span><span class="comment">*</span><span class="comment">
</span>         INFO = N + 1
         GO TO 420
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        T(ILAST,ILAST)=0 -- clear H(ILAST,ILAST-1) to split off a
</span><span class="comment">*</span><span class="comment">        1x1 block.
</span><span class="comment">*</span><span class="comment">
</span>   70    CONTINUE
         TEMP = H( ILAST, ILAST )
         CALL <a name="DLARTG.556"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, H( ILAST, ILAST-1 ), C, S,
     $                H( ILAST, ILAST ) )
         H( ILAST, ILAST-1 ) = ZERO
         CALL DROT( ILAST-IFRSTM, H( IFRSTM, ILAST ), 1,
     $              H( IFRSTM, ILAST-1 ), 1, C, S )
         CALL DROT( ILAST-IFRSTM, T( IFRSTM, ILAST ), 1,
     $              T( IFRSTM, ILAST-1 ), 1, C, S )
         IF( ILZ )
     $      CALL DROT( N, Z( 1, ILAST ), 1, Z( 1, ILAST-1 ), 1, C, S )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        H(ILAST,ILAST-1)=0 -- Standardize B, set ALPHAR, ALPHAI,
</span><span class="comment">*</span><span class="comment">                              and BETA
</span><span class="comment">*</span><span class="comment">
</span>   80    CONTINUE
         IF( T( ILAST, ILAST ).LT.ZERO ) THEN
            IF( ILSCHR ) THEN
               DO 90 J = IFRSTM, ILAST
                  H( J, ILAST ) = -H( J, ILAST )
                  T( J, ILAST ) = -T( J, ILAST )
   90          CONTINUE
            ELSE
               H( ILAST, ILAST ) = -H( ILAST, ILAST )
               T( ILAST, ILAST ) = -T( ILAST, ILAST )
            END IF
            IF( ILZ ) THEN
               DO 100 J = 1, N
                  Z( J, ILAST ) = -Z( J, ILAST )
  100          CONTINUE
            END IF
         END IF
         ALPHAR( ILAST ) = H( ILAST, ILAST )
         ALPHAI( ILAST ) = ZERO
         BETA( ILAST ) = T( ILAST, ILAST )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Go to next block -- exit if finished.
</span><span class="comment">*</span><span class="comment">
</span>         ILAST = ILAST - 1
         IF( ILAST.LT.ILO )
     $      GO TO 380
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Reset counters
</span><span class="comment">*</span><span class="comment">
</span>         IITER = 0
         ESHIFT = ZERO
         IF( .NOT.ILSCHR ) THEN
            ILASTM = ILAST
            IF( IFRSTM.GT.ILAST )
     $         IFRSTM = ILO
         END IF
         GO TO 350
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        QZ step
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        This iteration only involves rows/columns IFIRST:ILAST. We
</span><span class="comment">*</span><span class="comment">        assume IFIRST &lt; ILAST, and that the diagonal of B is non-zero.
</span><span class="comment">*</span><span class="comment">
</span>  110    CONTINUE
         IITER = IITER + 1
         IF( .NOT.ILSCHR ) THEN
            IFRSTM = IFIRST
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute single shifts.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        At this point, IFIRST &lt; ILAST, and the diagonal elements of
</span><span class="comment">*</span><span class="comment">        T(IFIRST:ILAST,IFIRST,ILAST) are larger than BTOL (in
</span><span class="comment">*</span><span class="comment">        magnitude)
</span><span class="comment">*</span><span class="comment">
</span>         IF( ( IITER / 10 )*10.EQ.IITER ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Exceptional shift.  Chosen for no particularly good reason.
</span><span class="comment">*</span><span class="comment">           (Single shift only.)
</span><span class="comment">*</span><span class="comment">
</span>            IF( ( DBLE( MAXIT )*SAFMIN )*ABS( H( ILAST-1, ILAST ) ).LT.
     $          ABS( T( ILAST-1, ILAST-1 ) ) ) THEN
               ESHIFT = ESHIFT + H( ILAST-1, ILAST ) /
     $                  T( ILAST-1, ILAST-1 )
            ELSE
               ESHIFT = ESHIFT + ONE / ( SAFMIN*DBLE( MAXIT ) )
            END IF
            S1 = ONE
            WR = ESHIFT
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Shifts based on the generalized eigenvalues of the
</span><span class="comment">*</span><span class="comment">           bottom-right 2x2 block of A and B. The first eigenvalue
</span><span class="comment">*</span><span class="comment">           returned by <a name="DLAG2.643"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a> is the Wilkinson shift (AEP p.512),
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLAG2.645"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a>( H( ILAST-1, ILAST-1 ), LDH,
     $                  T( ILAST-1, ILAST-1 ), LDT, SAFMIN*SAFETY, S1,
     $                  S2, WR, WR2, WI )
<span class="comment">*</span><span class="comment">
</span>            TEMP = MAX( S1, SAFMIN*MAX( ONE, ABS( WR ), ABS( WI ) ) )
            IF( WI.NE.ZERO )
     $         GO TO 200
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Fiddle with shift to avoid overflow
</span><span class="comment">*</span><span class="comment">
</span>         TEMP = MIN( ASCALE, ONE )*( HALF*SAFMAX )
         IF( S1.GT.TEMP ) THEN
            SCALE = TEMP / S1
         ELSE
            SCALE = ONE
         END IF
<span class="comment">*</span><span class="comment">
</span>         TEMP = MIN( BSCALE, ONE )*( HALF*SAFMAX )
         IF( ABS( WR ).GT.TEMP )
     $      SCALE = MIN( SCALE, TEMP / ABS( WR ) )
         S1 = SCALE*S1
         WR = SCALE*WR
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Now check for two consecutive small subdiagonals.
</span><span class="comment">*</span><span class="comment">
</span>         DO 120 J = ILAST - 1, IFIRST + 1, -1
            ISTART = J
            TEMP = ABS( S1*H( J, J-1 ) )
            TEMP2 = ABS( S1*H( J, J )-WR*T( J, J ) )
            TEMPR = MAX( TEMP, TEMP2 )
            IF( TEMPR.LT.ONE .AND. TEMPR.NE.ZERO ) THEN
               TEMP = TEMP / TEMPR
               TEMP2 = TEMP2 / TEMPR
            END IF
            IF( ABS( ( ASCALE*H( J+1, J ) )*TEMP ).LE.( ASCALE*ATOL )*
     $          TEMP2 )GO TO 130
  120    CONTINUE
<span class="comment">*</span><span class="comment">
</span>         ISTART = IFIRST
  130    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Do an implicit single-shift QZ sweep.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Initial Q
</span><span class="comment">*</span><span class="comment">
</span>         TEMP = S1*H( ISTART, ISTART ) - WR*T( ISTART, ISTART )
         TEMP2 = S1*H( ISTART+1, ISTART )
         CALL <a name="DLARTG.693"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, TEMP2, C, S, TEMPR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Sweep
</span><span class="comment">*</span><span class="comment">
</span>         DO 190 J = ISTART, ILAST - 1
            IF( J.GT.ISTART ) THEN
               TEMP = H( J, J-1 )
               CALL <a name="DLARTG.700"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, H( J+1, J-1 ), C, S, H( J, J-1 ) )
               H( J+1, J-1 ) = ZERO
            END IF
<span class="comment">*</span><span class="comment">
</span>            DO 140 JC = J, ILASTM
               TEMP = C*H( J, JC ) + S*H( J+1, JC )
               H( J+1, JC ) = -S*H( J, JC ) + C*H( J+1, JC )
               H( J, JC ) = TEMP
               TEMP2 = C*T( J, JC ) + S*T( J+1, JC )
               T( J+1, JC ) = -S*T( J, JC ) + C*T( J+1, JC )
               T( J, JC ) = TEMP2
  140       CONTINUE
            IF( ILQ ) THEN
               DO 150 JR = 1, N
                  TEMP = C*Q( JR, J ) + S*Q( JR, J+1 )
                  Q( JR, J+1 ) = -S*Q( JR, J ) + C*Q( JR, J+1 )
                  Q( JR, J ) = TEMP
  150          CONTINUE
            END IF
<span class="comment">*</span><span class="comment">
</span>            TEMP = T( J+1, J+1 )
            CALL <a name="DLARTG.721"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, T( J+1, J ), C, S, T( J+1, J+1 ) )
            T( J+1, J ) = ZERO
<span class="comment">*</span><span class="comment">
</span>            DO 160 JR = IFRSTM, MIN( J+2, ILAST )
               TEMP = C*H( JR, J+1 ) + S*H( JR, J )
               H( JR, J ) = -S*H( JR, J+1 ) + C*H( JR, J )
               H( JR, J+1 ) = TEMP
  160       CONTINUE
            DO 170 JR = IFRSTM, J
               TEMP = C*T( JR, J+1 ) + S*T( JR, J )
               T( JR, J ) = -S*T( JR, J+1 ) + C*T( JR, J )
               T( JR, J+1 ) = TEMP
  170       CONTINUE
            IF( ILZ ) THEN
               DO 180 JR = 1, N
                  TEMP = C*Z( JR, J+1 ) + S*Z( JR, J )
                  Z( JR, J ) = -S*Z( JR, J+1 ) + C*Z( JR, J )
                  Z( JR, J+1 ) = TEMP
  180          CONTINUE
            END IF
  190    CONTINUE
<span class="comment">*</span><span class="comment">
</span>         GO TO 350
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Use Francis double-shift
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Note: the Francis double-shift should work with real shifts,
</span><span class="comment">*</span><span class="comment">              but only if the block is at least 3x3.
</span><span class="comment">*</span><span class="comment">              This code may break if this point is reached with
</span><span class="comment">*</span><span class="comment">              a 2x2 block with real eigenvalues.
</span><span class="comment">*</span><span class="comment">
</span>  200    CONTINUE
         IF( IFIRST+1.EQ.ILAST ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Special case -- 2x2 block with complex eigenvectors
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Step 1: Standardize, that is, rotate so that
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       ( B11  0  )
</span><span class="comment">*</span><span class="comment">                   B = (         )  with B11 non-negative.
</span><span class="comment">*</span><span class="comment">                       (  0  B22 )
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLASV2.763"></a><a href="dlasv2.f.html#DLASV2.1">DLASV2</a>( T( ILAST-1, ILAST-1 ), T( ILAST-1, ILAST ),
     $                   T( ILAST, ILAST ), B22, B11, SR, CR, SL, CL )
<span class="comment">*</span><span class="comment">
</span>            IF( B11.LT.ZERO ) THEN
               CR = -CR
               SR = -SR
               B11 = -B11
               B22 = -B22
            END IF
<span class="comment">*</span><span class="comment">
</span>            CALL DROT( ILASTM+1-IFIRST, H( ILAST-1, ILAST-1 ), LDH,
     $                 H( ILAST, ILAST-1 ), LDH, CL, SL )
            CALL DROT( ILAST+1-IFRSTM, H( IFRSTM, ILAST-1 ), 1,
     $                 H( IFRSTM, ILAST ), 1, CR, SR )
<span class="comment">*</span><span class="comment">
</span>            IF( ILAST.LT.ILASTM )
     $         CALL DROT( ILASTM-ILAST, T( ILAST-1, ILAST+1 ), LDT,
     $                    T( ILAST, ILAST+1 ), LDH, CL, SL )
            IF( IFRSTM.LT.ILAST-1 )
     $         CALL DROT( IFIRST-IFRSTM, T( IFRSTM, ILAST-1 ), 1,
     $                    T( IFRSTM, ILAST ), 1, CR, SR )
<span class="comment">*</span><span class="comment">
</span>            IF( ILQ )
     $         CALL DROT( N, Q( 1, ILAST-1 ), 1, Q( 1, ILAST ), 1, CL,
     $                    SL )
            IF( ILZ )
     $         CALL DROT( N, Z( 1, ILAST-1 ), 1, Z( 1, ILAST ), 1, CR,
     $                    SR )
<span class="comment">*</span><span class="comment">
</span>            T( ILAST-1, ILAST-1 ) = B11
            T( ILAST-1, ILAST ) = ZERO
            T( ILAST, ILAST-1 ) = ZERO
            T( ILAST, ILAST ) = B22
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           If B22 is negative, negate column ILAST
</span><span class="comment">*</span><span class="comment">
</span>            IF( B22.LT.ZERO ) THEN
               DO 210 J = IFRSTM, ILAST
                  H( J, ILAST ) = -H( J, ILAST )
                  T( J, ILAST ) = -T( J, ILAST )
  210          CONTINUE
<span class="comment">*</span><span class="comment">
</span>               IF( ILZ ) THEN
                  DO 220 J = 1, N
                     Z( J, ILAST ) = -Z( J, ILAST )
  220             CONTINUE
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Step 2: Compute ALPHAR, ALPHAI, and BETA (see refs.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Recompute shift
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLAG2.816"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a>( H( ILAST-1, ILAST-1 ), LDH,
     $                  T( ILAST-1, ILAST-1 ), LDT, SAFMIN*SAFETY, S1,
     $                  TEMP, WR, TEMP2, WI )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           If standardization has perturbed the shift onto real line,
</span><span class="comment">*</span><span class="comment">           do another (real single-shift) QR step.
</span><span class="comment">*</span><span class="comment">
</span>            IF( WI.EQ.ZERO )
     $         GO TO 350
            S1INV = ONE / S1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Do EISPACK (QZVAL) computation of alpha and beta
</span><span class="comment">*</span><span class="comment">
</span>            A11 = H( ILAST-1, ILAST-1 )
            A21 = H( ILAST, ILAST-1 )
            A12 = H( ILAST-1, ILAST )
            A22 = H( ILAST, ILAST )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute complex Givens rotation on right
</span><span class="comment">*</span><span class="comment">           (Assume some element of C = (sA - wB) &gt; unfl )
</span><span class="comment">*</span><span class="comment">                            __
</span><span class="comment">*</span><span class="comment">           (sA - wB) ( CZ   -SZ )
</span><span class="comment">*</span><span class="comment">                     ( SZ    CZ )
</span><span class="comment">*</span><span class="comment">
</span>            C11R = S1*A11 - WR*B11
            C11I = -WI*B11
            C12 = S1*A12
            C21 = S1*A21
            C22R = S1*A22 - WR*B22
            C22I = -WI*B22
<span class="comment">*</span><span class="comment">
</span>            IF( ABS( C11R )+ABS( C11I )+ABS( C12 ).GT.ABS( C21 )+
     $          ABS( C22R )+ABS( C22I ) ) THEN
               T1 = <a name="DLAPY3.849"></a><a href="dlapy3.f.html#DLAPY3.1">DLAPY3</a>( C12, C11R, C11I )
               CZ = C12 / T1
               SZR = -C11R / T1
               SZI = -C11I / T1
            ELSE
               CZ = <a name="DLAPY2.854"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( C22R, C22I )
               IF( CZ.LE.SAFMIN ) THEN
                  CZ = ZERO
                  SZR = ONE
                  SZI = ZERO
               ELSE
                  TEMPR = C22R / CZ
                  TEMPI = C22I / CZ
                  T1 = <a name="DLAPY2.862"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( CZ, C21 )
                  CZ = CZ / T1
                  SZR = -C21*TEMPR / T1
                  SZI = C21*TEMPI / T1
               END IF
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute Givens rotation on left
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           (  CQ   SQ )
</span><span class="comment">*</span><span class="comment">           (  __      )  A or B
</span><span class="comment">*</span><span class="comment">           ( -SQ   CQ )
</span><span class="comment">*</span><span class="comment">
</span>            AN = ABS( A11 ) + ABS( A12 ) + ABS( A21 ) + ABS( A22 )
            BN = ABS( B11 ) + ABS( B22 )
            WABS = ABS( WR ) + ABS( WI )
            IF( S1*AN.GT.WABS*BN ) THEN
               CQ = CZ*B11
               SQR = SZR*B22
               SQI = -SZI*B22
            ELSE
               A1R = CZ*A11 + SZR*A12
               A1I = SZI*A12
               A2R = CZ*A21 + SZR*A22
               A2I = SZI*A22
               CQ = <a name="DLAPY2.887"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( A1R, A1I )
               IF( CQ.LE.SAFMIN ) THEN
                  CQ = ZERO
                  SQR = ONE
                  SQI = ZERO
               ELSE
                  TEMPR = A1R / CQ
                  TEMPI = A1I / CQ
                  SQR = TEMPR*A2R + TEMPI*A2I
                  SQI = TEMPI*A2R - TEMPR*A2I
               END IF
            END IF
            T1 = <a name="DLAPY3.899"></a><a href="dlapy3.f.html#DLAPY3.1">DLAPY3</a>( CQ, SQR, SQI )
            CQ = CQ / T1
            SQR = SQR / T1
            SQI = SQI / T1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute diagonal elements of QBZ
</span><span class="comment">*</span><span class="comment">
</span>            TEMPR = SQR*SZR - SQI*SZI
            TEMPI = SQR*SZI + SQI*SZR
            B1R = CQ*CZ*B11 + TEMPR*B22
            B1I = TEMPI*B22
            B1A = <a name="DLAPY2.910"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( B1R, B1I )
            B2R = CQ*CZ*B22 + TEMPR*B11
            B2I = -TEMPI*B11
            B2A = <a name="DLAPY2.913"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( B2R, B2I )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Normalize so beta &gt; 0, and Im( alpha1 ) &gt; 0
</span><span class="comment">*</span><span class="comment">
</span>            BETA( ILAST-1 ) = B1A
            BETA( ILAST ) = B2A
            ALPHAR( ILAST-1 ) = ( WR*B1A )*S1INV
            ALPHAI( ILAST-1 ) = ( WI*B1A )*S1INV
            ALPHAR( ILAST ) = ( WR*B2A )*S1INV
            ALPHAI( ILAST ) = -( WI*B2A )*S1INV
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Step 3: Go to next block -- exit if finished.
</span><span class="comment">*</span><span class="comment">
</span>            ILAST = IFIRST - 1
            IF( ILAST.LT.ILO )
     $         GO TO 380
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Reset counters
</span><span class="comment">*</span><span class="comment">
</span>            IITER = 0
            ESHIFT = ZERO
            IF( .NOT.ILSCHR ) THEN
               ILASTM = ILAST
               IF( IFRSTM.GT.ILAST )
     $            IFRSTM = ILO
            END IF
            GO TO 350
         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Usual case: 3x3 or larger block, using Francis implicit
</span><span class="comment">*</span><span class="comment">                       double-shift
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                                    2
</span><span class="comment">*</span><span class="comment">           Eigenvalue equation is  w  - c w + d = 0,
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                                         -1 2        -1
</span><span class="comment">*</span><span class="comment">           so compute 1st column of  (A B  )  - c A B   + d
</span><span class="comment">*</span><span class="comment">           using the formula in QZIT (from EISPACK)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           We assume that the block is at least 3x3
</span><span class="comment">*</span><span class="comment">
</span>            AD11 = ( ASCALE*H( ILAST-1, ILAST-1 ) ) /
     $             ( BSCALE*T( ILAST-1, ILAST-1 ) )
            AD21 = ( ASCALE*H( ILAST, ILAST-1 ) ) /
     $             ( BSCALE*T( ILAST-1, ILAST-1 ) )
            AD12 = ( ASCALE*H( ILAST-1, ILAST ) ) /
     $             ( BSCALE*T( ILAST, ILAST ) )
            AD22 = ( ASCALE*H( ILAST, ILAST ) ) /
     $             ( BSCALE*T( ILAST, ILAST ) )
            U12 = T( ILAST-1, ILAST ) / T( ILAST, ILAST )
            AD11L = ( ASCALE*H( IFIRST, IFIRST ) ) /
     $              ( BSCALE*T( IFIRST, IFIRST ) )
            AD21L = ( ASCALE*H( IFIRST+1, IFIRST ) ) /
     $              ( BSCALE*T( IFIRST, IFIRST ) )
            AD12L = ( ASCALE*H( IFIRST, IFIRST+1 ) ) /
     $              ( BSCALE*T( IFIRST+1, IFIRST+1 ) )
            AD22L = ( ASCALE*H( IFIRST+1, IFIRST+1 ) ) /
     $              ( BSCALE*T( IFIRST+1, IFIRST+1 ) )
            AD32L = ( ASCALE*H( IFIRST+2, IFIRST+1 ) ) /
     $              ( BSCALE*T( IFIRST+1, IFIRST+1 ) )
            U12L = T( IFIRST, IFIRST+1 ) / T( IFIRST+1, IFIRST+1 )
<span class="comment">*</span><span class="comment">
</span>            V( 1 ) = ( AD11-AD11L )*( AD22-AD11L ) - AD12*AD21 +
     $               AD21*U12*AD11L + ( AD12L-AD11L*U12L )*AD21L
            V( 2 ) = ( ( AD22L-AD11L )-AD21L*U12L-( AD11-AD11L )-
     $               ( AD22-AD11L )+AD21*U12 )*AD21L
            V( 3 ) = AD32L*AD21L
<span class="comment">*</span><span class="comment">
</span>            ISTART = IFIRST
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLARFG.983"></a><a href="dlarfg.f.html#DLARFG.1">DLARFG</a>( 3, V( 1 ), V( 2 ), 1, TAU )
            V( 1 ) = ONE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Sweep
</span><span class="comment">*</span><span class="comment">
</span>            DO 290 J = ISTART, ILAST - 2
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              All but last elements: use 3x3 Householder transforms.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero (j-1)st column of A
</span><span class="comment">*</span><span class="comment">
</span>               IF( J.GT.ISTART ) THEN
                  V( 1 ) = H( J, J-1 )
                  V( 2 ) = H( J+1, J-1 )
                  V( 3 ) = H( J+2, J-1 )
<span class="comment">*</span><span class="comment">
</span>                  CALL <a name="DLARFG.999"></a><a href="dlarfg.f.html#DLARFG.1">DLARFG</a>( 3, H( J, J-1 ), V( 2 ), 1, TAU )
                  V( 1 ) = ONE
                  H( J+1, J-1 ) = ZERO
                  H( J+2, J-1 ) = ZERO
               END IF
<span class="comment">*</span><span class="comment">
</span>               DO 230 JC = J, ILASTM
                  TEMP = TAU*( H( J, JC )+V( 2 )*H( J+1, JC )+V( 3 )*
     $                   H( J+2, JC ) )
                  H( J, JC ) = H( J, JC ) - TEMP
                  H( J+1, JC ) = H( J+1, JC ) - TEMP*V( 2 )
                  H( J+2, JC ) = H( J+2, JC ) - TEMP*V( 3 )
                  TEMP2 = TAU*( T( J, JC )+V( 2 )*T( J+1, JC )+V( 3 )*
     $                    T( J+2, JC ) )
                  T( J, JC ) = T( J, JC ) - TEMP2
                  T( J+1, JC ) = T( J+1, JC ) - TEMP2*V( 2 )
                  T( J+2, JC ) = T( J+2, JC ) - TEMP2*V( 3 )
  230          CONTINUE
               IF( ILQ ) THEN
                  DO 240 JR = 1, N
                     TEMP = TAU*( Q( JR, J )+V( 2 )*Q( JR, J+1 )+V( 3 )*
     $                      Q( JR, J+2 ) )
                     Q( JR, J ) = Q( JR, J ) - TEMP
                     Q( JR, J+1 ) = Q( JR, J+1 ) - TEMP*V( 2 )
                     Q( JR, J+2 ) = Q( JR, J+2 ) - TEMP*V( 3 )
  240             CONTINUE
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero j-th column of B (see DLAGBC for details)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Swap rows to pivot
</span><span class="comment">*</span><span class="comment">
</span>               ILPIVT = .FALSE.
               TEMP = MAX( ABS( T( J+1, J+1 ) ), ABS( T( J+1, J+2 ) ) )
               TEMP2 = MAX( ABS( T( J+2, J+1 ) ), ABS( T( J+2, J+2 ) ) )
               IF( MAX( TEMP, TEMP2 ).LT.SAFMIN ) THEN
                  SCALE = ZERO
                  U1 = ONE
                  U2 = ZERO
                  GO TO 250
               ELSE IF( TEMP.GE.TEMP2 ) THEN
                  W11 = T( J+1, J+1 )
                  W21 = T( J+2, J+1 )
                  W12 = T( J+1, J+2 )
                  W22 = T( J+2, J+2 )
                  U1 = T( J+1, J )
                  U2 = T( J+2, J )
               ELSE
                  W21 = T( J+1, J+1 )
                  W11 = T( J+2, J+1 )
                  W22 = T( J+1, J+2 )
                  W12 = T( J+2, J+2 )
                  U2 = T( J+1, J )
                  U1 = T( J+2, J )
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Swap columns if nec.
</span><span class="comment">*</span><span class="comment">
</span>               IF( ABS( W12 ).GT.ABS( W11 ) ) THEN
                  ILPIVT = .TRUE.
                  TEMP = W12
                  TEMP2 = W22
                  W12 = W11
                  W22 = W21
                  W11 = TEMP
                  W21 = TEMP2
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              LU-factor
</span><span class="comment">*</span><span class="comment">
</span>               TEMP = W21 / W11
               U2 = U2 - TEMP*U1
               W22 = W22 - TEMP*W12
               W21 = ZERO
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute SCALE
</span><span class="comment">*</span><span class="comment">
</span>               SCALE = ONE
               IF( ABS( W22 ).LT.SAFMIN ) THEN
                  SCALE = ZERO
                  U2 = ONE
                  U1 = -W12 / W11
                  GO TO 250
               END IF
               IF( ABS( W22 ).LT.ABS( U2 ) )
     $            SCALE = ABS( W22 / U2 )
               IF( ABS( W11 ).LT.ABS( U1 ) )
     $            SCALE = MIN( SCALE, ABS( W11 / U1 ) )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Solve
</span><span class="comment">*</span><span class="comment">
</span>               U2 = ( SCALE*U2 ) / W22
               U1 = ( SCALE*U1-W12*U2 ) / W11
<span class="comment">*</span><span class="comment">
</span>  250          CONTINUE
               IF( ILPIVT ) THEN
                  TEMP = U2
                  U2 = U1
                  U1 = TEMP
               END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute Householder Vector
</span><span class="comment">*</span><span class="comment">
</span>               T1 = SQRT( SCALE**2+U1**2+U2**2 )
               TAU = ONE + SCALE / T1
               VS = -ONE / ( SCALE+T1 )
               V( 1 ) = ONE
               V( 2 ) = VS*U1
               V( 3 ) = VS*U2
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Apply transformations from the right.
</span><span class="comment">*</span><span class="comment">
</span>               DO 260 JR = IFRSTM, MIN( J+3, ILAST )
                  TEMP = TAU*( H( JR, J )+V( 2 )*H( JR, J+1 )+V( 3 )*
     $                   H( JR, J+2 ) )
                  H( JR, J ) = H( JR, J ) - TEMP
                  H( JR, J+1 ) = H( JR, J+1 ) - TEMP*V( 2 )
                  H( JR, J+2 ) = H( JR, J+2 ) - TEMP*V( 3 )
  260          CONTINUE
               DO 270 JR = IFRSTM, J + 2
                  TEMP = TAU*( T( JR, J )+V( 2 )*T( JR, J+1 )+V( 3 )*
     $                   T( JR, J+2 ) )
                  T( JR, J ) = T( JR, J ) - TEMP
                  T( JR, J+1 ) = T( JR, J+1 ) - TEMP*V( 2 )
                  T( JR, J+2 ) = T( JR, J+2 ) - TEMP*V( 3 )
  270          CONTINUE
               IF( ILZ ) THEN
                  DO 280 JR = 1, N
                     TEMP = TAU*( Z( JR, J )+V( 2 )*Z( JR, J+1 )+V( 3 )*
     $                      Z( JR, J+2 ) )
                     Z( JR, J ) = Z( JR, J ) - TEMP
                     Z( JR, J+1 ) = Z( JR, J+1 ) - TEMP*V( 2 )
                     Z( JR, J+2 ) = Z( JR, J+2 ) - TEMP*V( 3 )
  280             CONTINUE
               END IF
               T( J+1, J ) = ZERO
               T( J+2, J ) = ZERO
  290       CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Last elements: Use Givens rotations
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Rotations from the left
</span><span class="comment">*</span><span class="comment">
</span>            J = ILAST - 1
            TEMP = H( J, J-1 )
            CALL <a name="DLARTG.1144"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, H( J+1, J-1 ), C, S, H( J, J-1 ) )
            H( J+1, J-1 ) = ZERO
<span class="comment">*</span><span class="comment">
</span>            DO 300 JC = J, ILASTM
               TEMP = C*H( J, JC ) + S*H( J+1, JC )
               H( J+1, JC ) = -S*H( J, JC ) + C*H( J+1, JC )
               H( J, JC ) = TEMP
               TEMP2 = C*T( J, JC ) + S*T( J+1, JC )
               T( J+1, JC ) = -S*T( J, JC ) + C*T( J+1, JC )
               T( J, JC ) = TEMP2
  300       CONTINUE
            IF( ILQ ) THEN
               DO 310 JR = 1, N
                  TEMP = C*Q( JR, J ) + S*Q( JR, J+1 )
                  Q( JR, J+1 ) = -S*Q( JR, J ) + C*Q( JR, J+1 )
                  Q( JR, J ) = TEMP
  310          CONTINUE
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Rotations from the right.
</span><span class="comment">*</span><span class="comment">
</span>            TEMP = T( J+1, J+1 )
            CALL <a name="DLARTG.1166"></a><a href="dlartg.f.html#DLARTG.1">DLARTG</a>( TEMP, T( J+1, J ), C, S, T( J+1, J+1 ) )
            T( J+1, J ) = ZERO
<span class="comment">*</span><span class="comment">
</span>            DO 320 JR = IFRSTM, ILAST
               TEMP = C*H( JR, J+1 ) + S*H( JR, J )
               H( JR, J ) = -S*H( JR, J+1 ) + C*H( JR, J )
               H( JR, J+1 ) = TEMP
  320       CONTINUE
            DO 330 JR = IFRSTM, ILAST - 1
               TEMP = C*T( JR, J+1 ) + S*T( JR, J )
               T( JR, J ) = -S*T( JR, J+1 ) + C*T( JR, J )
               T( JR, J+1 ) = TEMP
  330       CONTINUE
            IF( ILZ ) THEN
               DO 340 JR = 1, N
                  TEMP = C*Z( JR, J+1 ) + S*Z( JR, J )
                  Z( JR, J ) = -S*Z( JR, J+1 ) + C*Z( JR, J )
                  Z( JR, J+1 ) = TEMP
  340          CONTINUE
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           End of Double-Shift code
</span><span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>         GO TO 350
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        End of iteration loop
</span><span class="comment">*</span><span class="comment">
</span>  350    CONTINUE
  360 CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Drop-through = non-convergence
</span><span class="comment">*</span><span class="comment">
</span>      INFO = ILAST
      GO TO 420
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Successful completion of all QZ steps
</span><span class="comment">*</span><span class="comment">
</span>  380 CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Set Eigenvalues 1:ILO-1
</span><span class="comment">*</span><span class="comment">
</span>      DO 410 J = 1, ILO - 1
         IF( T( J, J ).LT.ZERO ) THEN
            IF( ILSCHR ) THEN
               DO 390 JR = 1, J
                  H( JR, J ) = -H( JR, J )
                  T( JR, J ) = -T( JR, J )
  390          CONTINUE
            ELSE
               H( J, J ) = -H( J, J )
               T( J, J ) = -T( J, J )
            END IF
            IF( ILZ ) THEN
               DO 400 JR = 1, N
                  Z( JR, J ) = -Z( JR, J )
  400          CONTINUE
            END IF
         END IF
         ALPHAR( J ) = H( J, J )
         ALPHAI( J ) = ZERO
         BETA( J ) = T( J, J )
  410 CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Normal Termination
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Exit (other than argument error) -- return optimal workspace size
</span><span class="comment">*</span><span class="comment">
</span>  420 CONTINUE
      WORK( 1 ) = DBLE( N )
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DHGEQZ.1241"></a><a href="dhgeqz.f.html#DHGEQZ.1">DHGEQZ</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
