<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>sgesvd.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="SGESVD.1"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a>( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,
     $                   WORK, LWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBU, JOBVT
      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               A( LDA, * ), S( * ), U( LDU, * ),
     $                   VT( LDVT, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="SGESVD.20"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a> computes the singular value decomposition (SVD) of a real
</span><span class="comment">*</span><span class="comment">  M-by-N matrix A, optionally computing the left and/or right singular
</span><span class="comment">*</span><span class="comment">  vectors. The SVD is written
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       A = U * SIGMA * transpose(V)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where SIGMA is an M-by-N matrix which is zero except for its
</span><span class="comment">*</span><span class="comment">  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
</span><span class="comment">*</span><span class="comment">  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
</span><span class="comment">*</span><span class="comment">  are the singular values of A; they are real and non-negative, and
</span><span class="comment">*</span><span class="comment">  are returned in descending order.  The first min(m,n) columns of
</span><span class="comment">*</span><span class="comment">  U and V are the left and right singular vectors of A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note that the routine returns V**T, not V.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBU    (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix U:
</span><span class="comment">*</span><span class="comment">          = 'A':  all M columns of U are returned in array U:
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array U;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) columns of U (the left singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no columns of U (no left singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVT   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies options for computing all or part of the matrix
</span><span class="comment">*</span><span class="comment">          V**T:
</span><span class="comment">*</span><span class="comment">          = 'A':  all N rows of V**T are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'S':  the first min(m,n) rows of V**T (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are returned in the array VT;
</span><span class="comment">*</span><span class="comment">          = 'O':  the first min(m,n) rows of V**T (the right singular
</span><span class="comment">*</span><span class="comment">                  vectors) are overwritten on the array A;
</span><span class="comment">*</span><span class="comment">          = 'N':  no rows of V**T (no right singular vectors) are
</span><span class="comment">*</span><span class="comment">                  computed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          JOBVT and JOBU cannot both be 'O'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the input matrix A.  M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the input matrix A.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) REAL array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit,
</span><span class="comment">*</span><span class="comment">          if JOBU = 'O',  A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          columns of U (the left singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'O', A is overwritten with the first min(m,n)
</span><span class="comment">*</span><span class="comment">                          rows of V**T (the right singular vectors,
</span><span class="comment">*</span><span class="comment">                          stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBU .ne. 'O' and JOBVT .ne. 'O', the contents of A
</span><span class="comment">*</span><span class="comment">                          are destroyed.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A.  LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) REAL array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A, sorted so that S(i) &gt;= S(i+1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  U       (output) REAL array, dimension (LDU,UCOL)
</span><span class="comment">*</span><span class="comment">          (LDU,M) if JOBU = 'A' or (LDU,min(M,N)) if JOBU = 'S'.
</span><span class="comment">*</span><span class="comment">          If JOBU = 'A', U contains the M-by-M orthogonal matrix U;
</span><span class="comment">*</span><span class="comment">          if JOBU = 'S', U contains the first min(m,n) columns of U
</span><span class="comment">*</span><span class="comment">          (the left singular vectors, stored columnwise);
</span><span class="comment">*</span><span class="comment">          if JOBU = 'N' or 'O', U is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDU     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array U.  LDU &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBU = 'S' or 'A', LDU &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VT      (output) REAL array, dimension (LDVT,N)
</span><span class="comment">*</span><span class="comment">          If JOBVT = 'A', VT contains the N-by-N orthogonal matrix
</span><span class="comment">*</span><span class="comment">          V**T;
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'S', VT contains the first min(m,n) rows of
</span><span class="comment">*</span><span class="comment">          V**T (the right singular vectors, stored rowwise);
</span><span class="comment">*</span><span class="comment">          if JOBVT = 'N' or 'O', VT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVT    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VT.  LDVT &gt;= 1; if
</span><span class="comment">*</span><span class="comment">          JOBVT = 'A', LDVT &gt;= N; if JOBVT = 'S', LDVT &gt;= min(M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
</span><span class="comment">*</span><span class="comment">          if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged
</span><span class="comment">*</span><span class="comment">          superdiagonal elements of an upper bidiagonal matrix B
</span><span class="comment">*</span><span class="comment">          whose diagonal is in S (not necessarily sorted). B
</span><span class="comment">*</span><span class="comment">          satisfies A = U * B * VT, so it has the same singular values
</span><span class="comment">*</span><span class="comment">          as A, and singular vectors related by U and VT.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.123"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit.
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  if <a name="SBDSQR.128"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a> did not converge, INFO specifies how many
</span><span class="comment">*</span><span class="comment">                superdiagonals of an intermediate bidiagonal form B
</span><span class="comment">*</span><span class="comment">                did not converge to zero. See the description of WORK
</span><span class="comment">*</span><span class="comment">                above for details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, WNTUA, WNTUAS, WNTUN, WNTUO, WNTUS,
     $                   WNTVA, WNTVAS, WNTVN, WNTVO, WNTVS
      INTEGER            BDSPAC, BLK, CHUNK, I, IE, IERR, IR, ISCL,
     $                   ITAU, ITAUP, ITAUQ, IU, IWORK, LDWRKR, LDWRKU,
     $                   MAXWRK, MINMN, MINWRK, MNTHR, NCU, NCVT, NRU,
     $                   NRVT, WRKBL
      REAL               ANRM, BIGNUM, EPS, SMLNUM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      REAL               DUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="SBDSQR.152"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>, <a name="SGEBRD.152"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>, <a name="SGELQF.152"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>, SGEMM, <a name="SGEQRF.152"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>, <a name="SLACPY.152"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>,
     $                   <a name="SLASCL.153"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="SLASET.153"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SORGBR.153"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>, <a name="SORGLQ.153"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>, <a name="SORGQR.153"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>, <a name="SORMBR.153"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>,
     $                   <a name="XERBLA.154"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.157"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.158"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="SLAMCH.159"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.159"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
      EXTERNAL           <a name="LSAME.160"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.160"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="SLAMCH.160"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.160"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      WNTUA = <a name="LSAME.171"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'A'</span> )
      WNTUS = <a name="LSAME.172"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'S'</span> )
      WNTUAS = WNTUA .OR. WNTUS
      WNTUO = <a name="LSAME.174"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'O'</span> )
      WNTUN = <a name="LSAME.175"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBU, <span class="string">'N'</span> )
      WNTVA = <a name="LSAME.176"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'A'</span> )
      WNTVS = <a name="LSAME.177"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'S'</span> )
      WNTVAS = WNTVA .OR. WNTVS
      WNTVO = <a name="LSAME.179"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'O'</span> )
      WNTVN = <a name="LSAME.180"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVT, <span class="string">'N'</span> )
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.( WNTUA .OR. WNTUS .OR. WNTUO .OR. WNTUN ) ) THEN
         INFO = -1
      ELSE IF( .NOT.( WNTVA .OR. WNTVS .OR. WNTVO .OR. WNTVN ) .OR.
     $         ( WNTVO .AND. WNTUO ) ) THEN
         INFO = -2
      ELSE IF( M.LT.0 ) THEN
         INFO = -3
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -6
      ELSE IF( LDU.LT.1 .OR. ( WNTUAS .AND. LDU.LT.M ) ) THEN
         INFO = -9
      ELSE IF( LDVT.LT.1 .OR. ( WNTVA .AND. LDVT.LT.N ) .OR.
     $         ( WNTVS .AND. LDVT.LT.MINMN ) ) THEN
         INFO = -11
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.206"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( M.GE.N .AND. MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="SBDSQR.213"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.215"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="SGESVD.215"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*N
            IF( M.GE.MNTHR ) THEN
               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = N + N*<a name="ILAENV.222"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.222"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*N+2*N*
     $                     <a name="ILAENV.225"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.225"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  IF( WNTVO .OR. WNTVAS )
     $               MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                        <a name="ILAENV.228"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.228"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*N, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.235"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.235"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.236"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.236"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.239"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.239"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.241"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.241"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3 (M much larger than N, JOBU='O', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.250"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.250"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.251"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.251"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.254"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.254"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.256"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.256"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.258"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.258"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( N*N+WRKBL, N*N+M*N+N )
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.266"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.266"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.267"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.267"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.270"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.270"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.272"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.272"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.280"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.280"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.281"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.281"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.284"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.284"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.286"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.286"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.288"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.288"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUS .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.297"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.297"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+N*<a name="ILAENV.298"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.298"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.301"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.301"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.303"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.303"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.305"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.305"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.313"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.313"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.314"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.314"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.317"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.317"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.319"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.319"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.327"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.327"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.328"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.328"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.331"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.331"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.333"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.333"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.335"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.335"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               ELSE IF( WNTUA .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S' or
</span><span class="comment">*</span><span class="comment">                 'A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = N + N*<a name="ILAENV.344"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.344"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, N+M*<a name="ILAENV.345"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.345"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, M,
     $                    M, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+2*N*
     $                    <a name="ILAENV.348"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.348"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+N*
     $                    <a name="ILAENV.350"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.350"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, 3*N+( N-1 )*
     $                    <a name="ILAENV.352"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.352"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = N*N + WRKBL
                  MINWRK = MAX( 3*N+M, BDSPAC )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 3*N + ( M+N )*<a name="ILAENV.361"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.361"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTUS .OR. WNTUO )
     $            MAXWRK = MAX( MAXWRK, 3*N+N*
     $                     <a name="ILAENV.365"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.365"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, N, N, -1 ) )
               IF( WNTUA )
     $            MAXWRK = MAX( MAXWRK, 3*N+M*
     $                     <a name="ILAENV.368"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.368"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, N, -1 ) )
               IF( .NOT.WNTVN )
     $            MAXWRK = MAX( MAXWRK, 3*N+( N-1 )*
     $                     <a name="ILAENV.371"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.371"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*N+M, BDSPAC )
            END IF
         ELSE IF( MINMN.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute space needed for <a name="SBDSQR.377"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>
</span><span class="comment">*</span><span class="comment">
</span>            MNTHR = <a name="ILAENV.379"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="SGESVD.379"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a>'</span>, JOBU // JOBVT, M, N, 0, 0 )
            BDSPAC = 5*M
            IF( N.GE.MNTHR ) THEN
               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.386"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.386"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*M+2*M*
     $                     <a name="ILAENV.389"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.389"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  IF( WNTUO .OR. WNTUAS )
     $               MAXWRK = MAX( MAXWRK, 3*M+M*
     $                        <a name="ILAENV.392"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.392"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, BDSPAC )
                  MINWRK = MAX( 4*M, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.399"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.399"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.400"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.400"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.403"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.403"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.405"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.405"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 3t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='O')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.414"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.414"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.415"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.415"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.418"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.418"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.420"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.420"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.422"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.422"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = MAX( M*M+WRKBL, M*M+M*N+M )
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.430"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.430"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.431"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.431"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.434"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.434"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.436"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.436"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVS .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.444"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.444"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.445"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.445"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.448"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.448"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.450"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.450"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.452"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.452"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
                  MAXWRK = MAX( MAXWRK, MINWRK )
               ELSE IF( WNTVS .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='S')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.462"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.462"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+M*<a name="ILAENV.463"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.463"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, M,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.466"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.466"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.468"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.468"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.470"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.470"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.478"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.478"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.479"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.479"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.482"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.482"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.484"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.484"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.492"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.492"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.493"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.493"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.496"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.496"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.498"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.498"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.500"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.500"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = 2*M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               ELSE IF( WNTVA .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                 JOBVT='A')
</span><span class="comment">*</span><span class="comment">
</span>                  WRKBL = M + M*<a name="ILAENV.509"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGELQF.509"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1, -1 )
                  WRKBL = MAX( WRKBL, M+N*<a name="ILAENV.510"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGLQ.510"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>'</span>, <span class="string">' '</span>, N,
     $                    N, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+2*M*
     $                    <a name="ILAENV.513"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.513"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+( M-1 )*
     $                    <a name="ILAENV.515"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.515"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, 3*M+M*
     $                    <a name="ILAENV.517"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.517"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
                  WRKBL = MAX( WRKBL, BDSPAC )
                  MAXWRK = M*M + WRKBL
                  MINWRK = MAX( 3*M+N, BDSPAC )
               END IF
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = 3*M + ( M+N )*<a name="ILAENV.526"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEBRD.526"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>'</span>, <span class="string">' '</span>, M, N,
     $                  -1, -1 )
               IF( WNTVS .OR. WNTVO )
     $            MAXWRK = MAX( MAXWRK, 3*M+M*
     $                     <a name="ILAENV.530"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.530"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, M, N, M, -1 ) )
               IF( WNTVA )
     $            MAXWRK = MAX( MAXWRK, 3*M+N*
     $                     <a name="ILAENV.533"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.533"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'P'</span>, N, N, M, -1 ) )
               IF( .NOT.WNTUN )
     $            MAXWRK = MAX( MAXWRK, 3*M+( M-1 )*
     $                     <a name="ILAENV.536"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGBR.536"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>'</span>, <span class="string">'Q'</span>, M, M, M, -1 ) )
               MAXWRK = MAX( MAXWRK, BDSPAC )
               MINWRK = MAX( 3*M+N, BDSPAC )
            END IF
         END IF
         MAXWRK = MAX( MAXWRK, MINWRK )
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -13
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.550"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="SGESVD.550"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.564"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = SQRT( <a name="SLAMCH.565"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> ) ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="SLANGE.570"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, DUM )
      ISCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ISCL = 1
         CALL <a name="SLASCL.574"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, IERR )
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ISCL = 1
         CALL <a name="SLASCL.577"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has at least as many rows as columns. If A has sufficiently
</span><span class="comment">*</span><span class="comment">        more rows than columns, first reduce using the QR
</span><span class="comment">*</span><span class="comment">        decomposition (if sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 (M much larger than N, JOBU='N')
</span><span class="comment">*</span><span class="comment">              No left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=Q*R
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEQRF.599"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.604"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ), LDA )
               IE = 1
               ITAUQ = IE + N
               ITAUP = ITAUQ + N
               IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.613"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               NCVT = 0
               IF( WNTVO .OR. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If right singular vectors desired, generate P'.
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.622"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  NCVT = N
               END IF
               IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">              singular vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.632"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, NCVT, 0, 0, S, WORK( IE ), A, LDA,
     $                      DUM, 1, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTVAS )
     $            CALL <a name="SLACPY.638"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2 (M much larger than N, JOBU='O', JOBVT='N')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N, WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEQRF.676"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to WORK(IR) and zero out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.681"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="SLASET.682"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, WORK( IR+1 ),
     $                         LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGQR.688"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.698"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.705"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.714"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM, 1,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 10 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="SLACPY.728"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   10             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.744"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N, prefer 3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.751"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.759"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM, 1,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUO .AND. WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3 (M much larger than N, JOBU='O', JOBVT='S' or 'A')
</span><span class="comment">*</span><span class="comment">              N left singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+N )+N*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     LDWRKR = N
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDWRKU by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = ( LWORK-N*N-N ) / N
                     LDWRKR = N
                  END IF
                  ITAU = IR + LDWRKR*N
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEQRF.800"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.805"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="SLASET.807"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGQR.813"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.823"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="SLACPY.826"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, N, N, VT, LDVT, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.831"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                         WORK( ITAUQ ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+4*N-1, prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.838"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in WORK(IR) and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.847"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT, LDVT,
     $                         WORK( IR ), LDWRKR, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                 WORK(IR), storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need N*N+2*N, prefer N*N+M*N+N)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 20 I = 1, M, LDWRKU
                     CHUNK = MIN( M-I+1, LDWRKU )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, CHUNK, N, N, ONE, A( I, 1 ),
     $                           LDA, WORK( IR ), LDWRKR, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="SLACPY.861"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, CHUNK, N, WORK( IU ), LDWRKU,
     $                            A( I, 1 ), LDA )
   20             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEQRF.875"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.880"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                  IF( N.GT.1 )
     $               CALL <a name="SLASET.882"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            VT( 2, 1 ), LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGQR.888"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + N
                  ITAUP = ITAUQ + N
                  IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.898"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply Q in A by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORMBR.905"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                         WORK( ITAUQ ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing R in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.912"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.921"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT, LDVT,
     $                         A, LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4 (M much larger than N, JOBU='S', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.956"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.961"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="SLASET.963"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.969"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.979"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left vectors bidiagonalizing R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.987"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.996"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IR ), LDWRKR, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1017"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1019"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1024"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.1033"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1039"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1046"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1055"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5 (M much larger than N, JOBU='S', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1100"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1105"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.1107"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1113"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1125"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1129"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1135"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1143"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1153"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R to A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1167"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1180"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1182"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1187"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.1196"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1202"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left vectors bidiagonalizing R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1209"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1216"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1225"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6 (M much larger than N, JOBU='S', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 N left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1260"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1265"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.1267"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1273"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1283"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1287"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1293"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1301"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1310"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in A by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, A, LDA,
     $                           WORK( IU ), LDWRKU, ZERO, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1331"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1333"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1338"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, N, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1343"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="SLASET.1345"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1355"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1363"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1370"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1379"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTUA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7 (M much larger than N, JOBU='A', JOBVT='N')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 no right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1417"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1419"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IR), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1423"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="SLASET.1425"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IR+1 ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1431"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1441"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1449"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1458"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, N, 0, S, WORK( IE ), DUM,
     $                            1, WORK( IR ), LDWRKR, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IR), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IR ), LDWRKR, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1471"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1483"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1485"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1490"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.1499"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1505"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1513"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1522"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, 0, M, 0, S, WORK( IE ), DUM,
     $                            1, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8 (M much larger than N, JOBU='A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+N )*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N and WORK(IR) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                        IR = IU + LDWRKU*N
                        LDWRKR = N
                     END IF
                     ITAU = IR + LDWRKR*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+2*N, prefer 2*N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1567"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1569"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+N+M, prefer 2*N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1574"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1579"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.1581"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1593"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1597"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N, prefer 2*N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1603"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1611"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1621"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, WORK( IU ),
     $                            LDWRKU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1634"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of R from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1638"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, N, N, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1651"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1653"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1658"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out below R in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.1667"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO, A( 2, 1 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1673"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1681"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, A, LDA,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1688"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1697"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), A,
     $                            LDA, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9 (M much larger than N, JOBU='A', JOBVT='S'
</span><span class="comment">*</span><span class="comment">                         or 'A')
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U and
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.N*N+MAX( N+M, 4*N, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is N by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = N
                     END IF
                     ITAU = IU + LDWRKU*N
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+2*N, prefer N*N+N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1732"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1734"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+N+M, prefer N*N+N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1739"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1744"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.1746"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                            WORK( IU+1 ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in WORK(IU), copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1756"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1760"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, WORK( IU ), LDWRKU, VT,
     $                            LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N, prefer N*N+3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1766"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, N, N, N, WORK( IU ), LDWRKU,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+4*N-1,
</span><span class="comment">*</span><span class="comment">                                prefer N*N+3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1774"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of R in WORK(IU) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1783"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, N, 0, S, WORK( IE ), VT,
     $                            LDVT, WORK( IU ), LDWRKU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left singular vectors of R in
</span><span class="comment">*</span><span class="comment">                    WORK(IU), storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N*N)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, N, ONE, U, LDU,
     $                           WORK( IU ), LDWRKU, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from A to U
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1796"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=Q*R, copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEQRF.1808"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.1810"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need N+M, prefer N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGQR.1815"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( M, M, N, U, LDU, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy R from A to VT, zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.1820"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
                     IF( N.GT.1 )
     $                  CALL <a name="SLASET.1822"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'L'</span>, N-1, N-1, ZERO, ZERO,
     $                               VT( 2, 1 ), LDVT )
                     IE = ITAU
                     ITAUQ = IE + N
                     ITAUP = ITAUQ + N
                     IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize R in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N, prefer 3*N+2*N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.1832"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( N, N, VT, LDVT, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply Q in U by left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*N+M, prefer 3*N+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.1840"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'N'</span>, M, N, N, VT, LDVT,
     $                            WORK( ITAUQ ), U, LDU, WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.1847"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.1856"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           M .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10 (M at least N, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without QR decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + N
            ITAUP = ITAUQ + N
            IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*N+M, prefer 3*N+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEBRD.1881"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*N+NCU, prefer 3*N+NCU*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.1890"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, N, A, LDA, U, LDU )
               IF( WNTUS )
     $            NCU = N
               IF( WNTUA )
     $            NCU = M
               CALL <a name="SORGBR.1895"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, NCU, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.1904"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, N, N, A, LDA, VT, LDVT )
               CALL <a name="SORGBR.1905"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N, prefer 3*N+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGBR.1914"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, N, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*N-1, prefer 3*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGBR.1923"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + N
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.1942"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.1951"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.1960"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, N, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        A has more columns than rows. If A has sufficiently more
</span><span class="comment">*</span><span class="comment">        columns than rows, first reduce using the LQ decomposition (if
</span><span class="comment">*</span><span class="comment">        sufficient workspace available)
</span><span class="comment">*</span><span class="comment">
</span>         IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span>            IF( WNTVN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1t(N much larger than M, JOBVT='N')
</span><span class="comment">*</span><span class="comment">              No right singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               ITAU = 1
               IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute A=L*Q
</span><span class="comment">*</span><span class="comment">              (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGELQF.1985"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                      LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Zero out above L
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLASET.1990"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ), LDA )
               IE = 1
               ITAUQ = IE + M
               ITAUP = ITAUQ + M
               IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SGEBRD.1999"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                      WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                      IERR )
               IF( WNTUO .OR. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 If left singular vectors desired, generate Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2007"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
               END IF
               IWORK = IE + M
               NRU = 0
               IF( WNTUO .OR. WNTUAS )
     $            NRU = M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, computing left singular
</span><span class="comment">*</span><span class="comment">              vectors of A in A if desired
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.2019"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, 0, NRU, 0, S, WORK( IE ), DUM, 1, A,
     $                      LDA, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy them there
</span><span class="comment">*</span><span class="comment">
</span>               IF( WNTUAS )
     $            CALL <a name="SLACPY.2025"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, M, A, LDA, U, LDU )
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 2t(N much larger than M, JOBU='N', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGELQF.2066"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to WORK(IR) and zero out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.2071"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ), LDWRKR )
                  CALL <a name="SLASET.2072"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                         WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGLQ.2078"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.2088"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IR ), LDWRKR, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2095"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.2104"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M*N+M)
</span><span class="comment">*</span><span class="comment">
</span>                  DO 30 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="SLACPY.2118"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   30             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IE = 1
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.2134"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2141"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.2149"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'L'</span>, M, N, 0, 0, S, WORK( IE ), A, LDA,
     $                         DUM, 1, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVO .AND. WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 3t(N much larger than M, JOBU='S' or 'A', JOBVT='O')
</span><span class="comment">*</span><span class="comment">              M right singular vectors to be overwritten on A and
</span><span class="comment">*</span><span class="comment">              M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>               IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  IR = 1
                  IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = LDA
                  ELSE IF( LWORK.GE.MAX( WRKBL, LDA*N+M )+M*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is LDA by N and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = LDA
                     CHUNK = N
                     LDWRKR = M
                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    WORK(IU) is M by CHUNK and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                     LDWRKU = M
                     CHUNK = ( LWORK-M*M-M ) / M
                     LDWRKR = M
                  END IF
                  ITAU = IR + LDWRKR*M
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGELQF.2193"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing about above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.2198"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="SLASET.2199"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGLQ.2205"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U, copying result to WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.2215"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  CALL <a name="SLACPY.2218"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, M, U, LDU, WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate right vectors bidiagonalizing L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2223"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                         WORK( ITAUP ), WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2230"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in U, and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.2239"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                         WORK( IR ), LDWRKR, U, LDU, DUM, 1,
     $                         WORK( IWORK ), INFO )
                  IU = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right singular vectors of L in WORK(IR) by Q
</span><span class="comment">*</span><span class="comment">                 in A, storing result in WORK(IU) and copying to A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need M*M+2*M, prefer M*M+M*N+M))
</span><span class="comment">*</span><span class="comment">
</span>                  DO 40 I = 1, N, CHUNK
                     BLK = MIN( N-I+1, CHUNK )
                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, BLK, M, ONE, WORK( IR ),
     $                           LDWRKR, A( 1, I ), LDA, ZERO,
     $                           WORK( IU ), LDWRKU )
                     CALL <a name="SLACPY.2253"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, BLK, WORK( IU ), LDWRKU,
     $                            A( 1, I ), LDA )
   40             CONTINUE
<span class="comment">*</span><span class="comment">
</span>               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                  ITAU = 1
                  IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGELQF.2267"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SLACPY.2272"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                  CALL <a name="SLASET.2273"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                         LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGLQ.2279"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IE = ITAU
                  ITAUQ = IE + M
                  ITAUP = ITAUQ + M
                  IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SGEBRD.2289"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                         WORK( ITAUQ ), WORK( ITAUP ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Multiply right vectors bidiagonalizing L by Q in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORMBR.2296"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                         WORK( ITAUP ), A, LDA, WORK( IWORK ),
     $                         LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Generate left vectors bidiagonalizing L in U
</span><span class="comment">*</span><span class="comment">                 (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SORGBR.2303"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                         WORK( IWORK ), LWORK-IWORK+1, IERR )
                  IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                 singular vectors of A in A
</span><span class="comment">*</span><span class="comment">                 (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                  CALL <a name="SBDSQR.2312"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), A, LDA,
     $                         U, LDU, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVS ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 4t(N much larger than M, JOBU='N', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2347"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2352"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="SLASET.2354"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2360"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2370"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right vectors bidiagonalizing L in
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2379"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2388"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2409"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy result to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2414"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2419"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.2428"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2434"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.2441"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2450"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 5t(N much larger than M, JOBU='O', JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2495"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out below it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2500"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.2502"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2508"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2520"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2524"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2531"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2538"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2548"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of L to A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2562"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2575"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2577"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2582"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.2591"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2597"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right vectors bidiagonalizing L by Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.2604"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors of L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2611"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, compute left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and compute right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2620"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 6t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='S')
</span><span class="comment">*</span><span class="comment">                 M right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by N
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2655"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2660"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.2662"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2668"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2678"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2682"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2689"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2696"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2705"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in A, storing result in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, A, LDA, ZERO, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2726"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2728"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2733"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( M, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2738"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="SLASET.2739"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2749"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.2757"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2764"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2773"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            ELSE IF( WNTVA ) THEN
<span class="comment">*</span><span class="comment">
</span>               IF( WNTUN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 7t(N much larger than M, JOBU='N', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 no left singular vectors to be computed
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IR = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2811"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2813"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IR), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2817"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IR ),
     $                            LDWRKR )
                     CALL <a name="SLASET.2819"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IR+LDWRKR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2825"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2835"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IR ), LDWRKR, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2844"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2853"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, 0, 0, S, WORK( IE ),
     $                            WORK( IR ), LDWRKR, DUM, 1, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IR) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IR ),
     $                           LDWRKR, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2866"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2878"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2880"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2885"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.2894"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2900"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.2908"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.2917"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, 0, 0, S, WORK( IE ), VT,
     $                            LDVT, DUM, 1, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 8t(N much larger than M, JOBU='O', JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be overwritten on A
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.2*M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+2*LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = LDA
                     ELSE IF( LWORK.GE.WRKBL+( LDA+M )*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M and WORK(IR) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                        IR = IU + LDWRKU*M
                        LDWRKR = M
                     END IF
                     ITAU = IR + LDWRKR*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+2*M, prefer 2*M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.2962"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2964"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+M+N, prefer 2*M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.2969"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.2974"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.2976"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to
</span><span class="comment">*</span><span class="comment">                    WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.2988"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.2992"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU,
     $                            WORK( IR ), LDWRKR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M-1,
</span><span class="comment">*</span><span class="comment">                                prefer 2*M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.2999"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in WORK(IR)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+4*M, prefer 2*M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.3006"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, WORK( IR ), LDWRKR,
     $                            WORK( ITAUQ ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IR) and computing
</span><span class="comment">*</span><span class="comment">                    right singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.3016"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, WORK( IR ),
     $                            LDWRKR, DUM, 1, WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.3029"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy left singular vectors of A from WORK(IR) to A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.3033"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, M, WORK( IR ), LDWRKR, A,
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.3046"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.3048"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.3053"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Zero out above L in A
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLASET.3062"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, A( 1, 2 ),
     $                            LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.3068"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, A, LDA, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in A by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.3076"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, A, LDA,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.3083"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, A, LDA, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in A and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.3092"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, A, LDA, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               ELSE IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 9t(N much larger than M, JOBU='S' or 'A',
</span><span class="comment">*</span><span class="comment">                         JOBVT='A')
</span><span class="comment">*</span><span class="comment">                 N right singular vectors to be computed in VT and
</span><span class="comment">*</span><span class="comment">                 M left singular vectors to be computed in U
</span><span class="comment">*</span><span class="comment">
</span>                  IF( LWORK.GE.M*M+MAX( N+M, 4*M, BDSPAC ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Sufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     IU = 1
                     IF( LWORK.GE.WRKBL+LDA*M ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is LDA by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = LDA
                     ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                       WORK(IU) is M by M
</span><span class="comment">*</span><span class="comment">
</span>                        LDWRKU = M
                     END IF
                     ITAU = IU + LDWRKU*M
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+2*M, prefer M*M+M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.3127"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.3129"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+M+N, prefer M*M+M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.3134"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to WORK(IU), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.3139"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IU ),
     $                            LDWRKU )
                     CALL <a name="SLASET.3141"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO,
     $                            WORK( IU+LDWRKU ), LDWRKU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in WORK(IU), copying result to U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.3151"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, WORK( IU ), LDWRKU, S,
     $                            WORK( IE ), WORK( ITAUQ ),
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.3155"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, WORK( IU ), LDWRKU, U,
     $                            LDU )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate right bidiagonalizing vectors in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.3161"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IU ), LDWRKU,
     $                            WORK( ITAUP ), WORK( IWORK ),
     $                            LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+4*M, prefer M*M+3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.3168"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of L in WORK(IU)
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M+BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.3177"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, M, M, 0, S, WORK( IE ),
     $                            WORK( IU ), LDWRKU, U, LDU, DUM, 1,
     $                            WORK( IWORK ), INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right singular vectors of L in WORK(IU) by
</span><span class="comment">*</span><span class="comment">                    Q in VT, storing result in A
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M*M)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL SGEMM( <span class="string">'N'</span>, <span class="string">'N'</span>, M, N, M, ONE, WORK( IU ),
     $                           LDWRKU, VT, LDVT, ZERO, A, LDA )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy right singular vectors of A from A to VT
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.3190"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'F'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span>                  ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Insufficient workspace for a fast algorithm
</span><span class="comment">*</span><span class="comment">
</span>                     ITAU = 1
                     IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Compute A=L*Q, copying result to VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGELQF.3202"></a><a href="sgelqf.f.html#SGELQF.1">SGELQF</a>( M, N, A, LDA, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     CALL <a name="SLACPY.3204"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate Q in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need M+N, prefer M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGLQ.3209"></a><a href="sorglq.f.html#SORGLQ.1">SORGLQ</a>( N, N, M, VT, LDVT, WORK( ITAU ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Copy L to U, zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SLACPY.3214"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
                     CALL <a name="SLASET.3215"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'U'</span>, M-1, M-1, ZERO, ZERO, U( 1, 2 ),
     $                            LDU )
                     IE = ITAU
                     ITAUQ = IE + M
                     ITAUP = ITAUQ + M
                     IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Bidiagonalize L in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SGEBRD.3225"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, M, U, LDU, S, WORK( IE ),
     $                            WORK( ITAUQ ), WORK( ITAUP ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Multiply right bidiagonalizing vectors in U by Q
</span><span class="comment">*</span><span class="comment">                    in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 3*M+N, prefer 3*M+N*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORMBR.3233"></a><a href="sormbr.f.html#SORMBR.1">SORMBR</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, <span class="string">'T'</span>, M, N, M, U, LDU,
     $                            WORK( ITAUP ), VT, LDVT,
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">                    (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SORGBR.3240"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, M, U, LDU, WORK( ITAUQ ),
     $                            WORK( IWORK ), LWORK-IWORK+1, IERR )
                     IWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                    Perform bidiagonal QR iteration, computing left
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in U and computing right
</span><span class="comment">*</span><span class="comment">                    singular vectors of A in VT
</span><span class="comment">*</span><span class="comment">                    (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>                     CALL <a name="SBDSQR.3249"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'U'</span>, M, N, M, 0, S, WORK( IE ), VT,
     $                            LDVT, U, LDU, DUM, 1, WORK( IWORK ),
     $                            INFO )
<span class="comment">*</span><span class="comment">
</span>                  END IF
<span class="comment">*</span><span class="comment">
</span>               END IF
<span class="comment">*</span><span class="comment">
</span>            END IF
<span class="comment">*</span><span class="comment">
</span>         ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           N .LT. MNTHR
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 10t(N greater than M, but not much larger)
</span><span class="comment">*</span><span class="comment">           Reduce to bidiagonal form without LQ decomposition
</span><span class="comment">*</span><span class="comment">
</span>            IE = 1
            ITAUQ = IE + M
            ITAUP = ITAUQ + M
            IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Bidiagonalize A
</span><span class="comment">*</span><span class="comment">           (Workspace: need 3*M+N, prefer 3*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="SGEBRD.3274"></a><a href="sgebrd.f.html#SGEBRD.1">SGEBRD</a>( M, N, A, LDA, S, WORK( IE ), WORK( ITAUQ ),
     $                   WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                   IERR )
            IF( WNTUAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in U, copy result to U
</span><span class="comment">*</span><span class="comment">              and generate left bidiagonalizing vectors in U
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.3283"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, U, LDU )
               CALL <a name="SORGBR.3284"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, N, U, LDU, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVAS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in VT, copy result to
</span><span class="comment">*</span><span class="comment">              VT and generate right bidiagonalizing vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need 3*M+NRVT, prefer 3*M+NRVT*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SLACPY.3293"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'U'</span>, M, N, A, LDA, VT, LDVT )
               IF( WNTVA )
     $            NRVT = N
               IF( WNTVS )
     $            NRVT = M
               CALL <a name="SORGBR.3298"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, NRVT, N, M, VT, LDVT, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTUO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If left singular vectors desired in A, generate left
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M-1, prefer 3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGBR.3307"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'Q'</span>, M, M, N, A, LDA, WORK( ITAUQ ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IF( WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              If right singular vectors desired in A, generate right
</span><span class="comment">*</span><span class="comment">              bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need 4*M, prefer 3*M+M*NB)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SORGBR.3316"></a><a href="sorgbr.f.html#SORGBR.1">SORGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                      WORK( IWORK ), LWORK-IWORK+1, IERR )
            END IF
            IWORK = IE + M
            IF( WNTUAS .OR. WNTUO )
     $         NRU = M
            IF( WNTUN )
     $         NRU = 0
            IF( WNTVAS .OR. WNTVO )
     $         NCVT = N
            IF( WNTVN )
     $         NCVT = 0
            IF( ( .NOT.WNTUO ) .AND. ( .NOT.WNTVO ) ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.3335"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE IF( ( .NOT.WNTUO ) .AND. WNTVO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in U and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in A
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.3344"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), A, LDA,
     $                      U, LDU, DUM, 1, WORK( IWORK ), INFO )
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Perform bidiagonal QR iteration, if desired, computing
</span><span class="comment">*</span><span class="comment">              left singular vectors in A and computing right singular
</span><span class="comment">*</span><span class="comment">              vectors in VT
</span><span class="comment">*</span><span class="comment">              (Workspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>               CALL <a name="SBDSQR.3353"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a>( <span class="string">'L'</span>, M, NCVT, NRU, 0, S, WORK( IE ), VT,
     $                      LDVT, A, LDA, DUM, 1, WORK( IWORK ), INFO )
            END IF
<span class="comment">*</span><span class="comment">
</span>         END IF
<span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     If <a name="SBDSQR.3361"></a><a href="sbdsqr.f.html#SBDSQR.1">SBDSQR</a> failed to converge, copy unconverged superdiagonals
</span><span class="comment">*</span><span class="comment">     to WORK( 2:MINMN )
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         IF( IE.GT.2 ) THEN
            DO 50 I = 1, MINMN - 1
               WORK( I+1 ) = WORK( I+IE-1 )
   50       CONTINUE
         END IF
         IF( IE.LT.2 ) THEN
            DO 60 I = MINMN - 1, 1, -1
               WORK( I+1 ) = WORK( I+IE-1 )
   60       CONTINUE
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ISCL.EQ.1 ) THEN
         IF( ANRM.GT.BIGNUM )
     $      CALL <a name="SLASCL.3381"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.GT.BIGNUM )
     $      CALL <a name="SLASCL.3384"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
         IF( ANRM.LT.SMLNUM )
     $      CALL <a name="SLASCL.3387"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                   IERR )
         IF( INFO.NE.0 .AND. ANRM.LT.SMLNUM )
     $      CALL <a name="SLASCL.3390"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN-1, 1, WORK( 2 ),
     $                   MINMN, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Return optimal workspace in WORK(1)
</span><span class="comment">*</span><span class="comment">
</span>      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="SGESVD.3400"></a><a href="sgesvd.f.html#SGESVD.1">SGESVD</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
