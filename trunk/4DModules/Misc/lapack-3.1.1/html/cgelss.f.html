<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>cgelss.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="CGELSS.1"></a><a href="cgelss.f.html#CGELSS.1">CGELSS</a>( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,
     $                   WORK, LWORK, RWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK
      REAL               RCOND
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               RWORK( * ), S( * )
      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="CGELSS.20"></a><a href="cgelss.f.html#CGELSS.1">CGELSS</a> computes the minimum norm solution to a complex linear
</span><span class="comment">*</span><span class="comment">  least squares problem:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Minimize 2-norm(| b - A*x |).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  using the singular value decomposition (SVD) of A. A is an M-by-N
</span><span class="comment">*</span><span class="comment">  matrix which may be rank-deficient.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Several right hand side vectors b and solution vectors x can be
</span><span class="comment">*</span><span class="comment">  handled in a single call; they are stored as the columns of the
</span><span class="comment">*</span><span class="comment">  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix
</span><span class="comment">*</span><span class="comment">  X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The effective rank of A is determined by treating as zero those
</span><span class="comment">*</span><span class="comment">  singular values which are less than RCOND times the largest singular
</span><span class="comment">*</span><span class="comment">  value.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of rows of the matrix A. M &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of columns of the matrix A. N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  NRHS    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of right hand sides, i.e., the number of columns
</span><span class="comment">*</span><span class="comment">          of the matrices B and X. NRHS &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-N matrix A.
</span><span class="comment">*</span><span class="comment">          On exit, the first min(m,n) rows of A are overwritten with
</span><span class="comment">*</span><span class="comment">          its right singular vectors, stored rowwise.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1,M).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) COMPLEX array, dimension (LDB,NRHS)
</span><span class="comment">*</span><span class="comment">          On entry, the M-by-NRHS right hand side matrix B.
</span><span class="comment">*</span><span class="comment">          On exit, B is overwritten by the N-by-NRHS solution matrix X.
</span><span class="comment">*</span><span class="comment">          If m &gt;= n and RANK = n, the residual sum-of-squares for
</span><span class="comment">*</span><span class="comment">          the solution in the i-th column is given by the sum of
</span><span class="comment">*</span><span class="comment">          squares of the modulus of elements n+1:m in that column.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B.  LDB &gt;= max(1,M,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) REAL array, dimension (min(M,N))
</span><span class="comment">*</span><span class="comment">          The singular values of A in decreasing order.
</span><span class="comment">*</span><span class="comment">          The condition number of A in the 2-norm = S(1)/S(min(m,n)).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCOND   (input) REAL
</span><span class="comment">*</span><span class="comment">          RCOND is used to determine the effective rank of A.
</span><span class="comment">*</span><span class="comment">          Singular values S(i) &lt;= RCOND*S(1) are treated as zero.
</span><span class="comment">*</span><span class="comment">          If RCOND &lt; 0, machine precision is used instead.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RANK    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The effective rank of A, i.e., the number of singular values
</span><span class="comment">*</span><span class="comment">          which are greater than RCOND*S(1).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= 1, and also:
</span><span class="comment">*</span><span class="comment">          LWORK &gt;=  2*min(M,N) + max(M,N,NRHS)
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK should generally be larger.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.92"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace) REAL array, dimension (5*min(M,N))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          &gt; 0:  the algorithm for computing the SVD failed to converge;
</span><span class="comment">*</span><span class="comment">                if INFO = i, i off-diagonal elements of an intermediate
</span><span class="comment">*</span><span class="comment">                bidiagonal form did not converge to zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
      COMPLEX            CZERO, CONE
      PARAMETER          ( CZERO = ( 0.0E+0, 0.0E+0 ),
     $                   CONE = ( 1.0E+0, 0.0E+0 ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY
      INTEGER            BL, CHUNK, I, IASCL, IBSCL, IE, IL, IRWORK,
     $                   ITAU, ITAUP, ITAUQ, IWORK, LDWORK, MAXMN,
     $                   MAXWRK, MINMN, MINWRK, MM, MNTHR
      REAL               ANRM, BIGNUM, BNRM, EPS, SFMIN, SMLNUM, THR
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      COMPLEX            VDUM( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="CBDSQR.123"></a><a href="cbdsqr.f.html#CBDSQR.1">CBDSQR</a>, CCOPY, <a name="CGEBRD.123"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>, <a name="CGELQF.123"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>, CGEMM, CGEMV,
     $                   <a name="CGEQRF.124"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CLACPY.124"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>, <a name="CLASCL.124"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>, <a name="CLASET.124"></a><a href="claset.f.html#CLASET.1">CLASET</a>, <a name="CSRSCL.124"></a><a href="csrscl.f.html#CSRSCL.1">CSRSCL</a>, <a name="CUNGBR.124"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>,
     $                   <a name="CUNMBR.125"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>, <a name="CUNMLQ.125"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>, <a name="CUNMQR.125"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, <a name="SLABAD.125"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>, <a name="SLASCL.125"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="SLASET.125"></a><a href="slaset.f.html#SLASET.1">SLASET</a>,
     $                   <a name="XERBLA.126"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      INTEGER            <a name="ILAENV.129"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="CLANGE.130"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.130"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      EXTERNAL           <a name="ILAENV.131"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="CLANGE.131"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.131"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      MINMN = MIN( M, N )
      MAXMN = MAX( M, N )
      LQUERY = ( LWORK.EQ.-1 )
      IF( M.LT.0 ) THEN
         INFO = -1
      ELSE IF( N.LT.0 ) THEN
         INFO = -2
      ELSE IF( NRHS.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, M ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, MAXMN ) ) THEN
         INFO = -7
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       CWorkspace refers to complex workspace, and RWorkspace refers
</span><span class="comment">*</span><span class="comment">       to real workspace. NB refers to the optimal block size for the
</span><span class="comment">*</span><span class="comment">       immediately following subroutine, as returned by <a name="ILAENV.162"></a><a href="hfy-index.html#ILAENV">ILAENV</a>.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         MINWRK = 1
         MAXWRK = 1
         IF( MINMN.GT.0 ) THEN
            MM = M
            MNTHR = <a name="ILAENV.169"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 6, <span class="string">'<a name="CGELSS.169"></a><a href="cgelss.f.html#CGELSS.1">CGELSS</a>'</span>, <span class="string">' '</span>, M, N, NRHS, -1 )
            IF( M.GE.N .AND. M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1a - overdetermined, with many more rows than
</span><span class="comment">*</span><span class="comment">                        columns
</span><span class="comment">*</span><span class="comment">
</span>               MM = N
               MAXWRK = MAX( MAXWRK, N + N*<a name="ILAENV.176"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEQRF.176"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>'</span>, <span class="string">' '</span>, M,
     $                       N, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, N + NRHS*<a name="ILAENV.178"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMQR.178"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>'</span>, <span class="string">'LC'</span>,
     $                       M, NRHS, N, -1 ) )
            END IF
            IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Path 1 - overdetermined or exactly determined
</span><span class="comment">*</span><span class="comment">
</span>               MAXWRK = MAX( MAXWRK, 2*N + ( MM + N )*<a name="ILAENV.185"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="CGEBRD.186"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, MM, N, -1, -1 ) )
               MAXWRK = MAX( MAXWRK, 2*N + NRHS*<a name="ILAENV.187"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMBR.187"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>,
     $                       <span class="string">'QLC'</span>, MM, NRHS, N, -1 ) )
               MAXWRK = MAX( MAXWRK, 2*N + ( N - 1 )*<a name="ILAENV.189"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                       <span class="string">'<a name="CUNGBR.190"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>'</span>, <span class="string">'P'</span>, N, N, N, -1 ) )
               MAXWRK = MAX( MAXWRK, N*NRHS )
               MINWRK = 2*N + MAX( NRHS, M )
            END IF
            IF( N.GT.M ) THEN
               MINWRK = 2*M + MAX( NRHS, N )
               IF( N.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2a - underdetermined, with many more columns
</span><span class="comment">*</span><span class="comment">                 than rows
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = M + M*<a name="ILAENV.201"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGELQF.201"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>'</span>, <span class="string">' '</span>, M, N, -1,
     $                     -1 )
                  MAXWRK = MAX( MAXWRK, 3*M + M*M + 2*M*<a name="ILAENV.203"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CGEBRD.204"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, M, M, -1, -1 ) )
                  MAXWRK = MAX( MAXWRK, 3*M + M*M + NRHS*<a name="ILAENV.205"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CUNMBR.206"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>, <span class="string">'QLC'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 3*M + M*M + ( M - 1 )*<a name="ILAENV.207"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1,
     $                          <span class="string">'<a name="CUNGBR.208"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>'</span>, <span class="string">'P'</span>, M, M, M, -1 ) )
                  IF( NRHS.GT.1 ) THEN
                     MAXWRK = MAX( MAXWRK, M*M + M + M*NRHS )
                  ELSE
                     MAXWRK = MAX( MAXWRK, M*M + 2*M )
                  END IF
                  MAXWRK = MAX( MAXWRK, M + NRHS*<a name="ILAENV.214"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMLQ.214"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>'</span>,
     $                          <span class="string">'LC'</span>, N, NRHS, M, -1 ) )
               ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                 Path 2 - underdetermined
</span><span class="comment">*</span><span class="comment">
</span>                  MAXWRK = 2*M + ( N + M )*<a name="ILAENV.220"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEBRD.220"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>'</span>, <span class="string">' '</span>, M,
     $                     N, -1, -1 )
                  MAXWRK = MAX( MAXWRK, 2*M + NRHS*<a name="ILAENV.222"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMBR.222"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>'</span>,
     $                          <span class="string">'QLC'</span>, M, NRHS, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, 2*M + M*<a name="ILAENV.224"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNGBR.224"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>'</span>,
     $                          <span class="string">'P'</span>, M, N, M, -1 ) )
                  MAXWRK = MAX( MAXWRK, N*NRHS )
               END IF
            END IF
            MAXWRK = MAX( MINWRK, MAXWRK )
         END IF
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY )
     $      INFO = -12
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.238"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="CGELSS.238"></a><a href="cgelss.f.html#CGELSS.1">CGELSS</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.EQ.0 .OR. N.EQ.0 ) THEN
         RANK = 0
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine parameters
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.253"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SFMIN = <a name="SLAMCH.254"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      SMLNUM = SFMIN / EPS
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.257"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="CLANGE.261"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, M, N, A, LDA, RWORK )
      IASCL = 0
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.267"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, M, N, A, LDA, INFO )
         IASCL = 1
      ELSE IF( ANRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.273"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, M, N, A, LDA, INFO )
         IASCL = 2
      ELSE IF( ANRM.EQ.ZERO ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Matrix all zero. Return zero solution.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASET.279"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, MAX( M, N ), NRHS, CZERO, CZERO, B, LDB )
         CALL <a name="SLASET.280"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'F'</span>, MINMN, 1, ZERO, ZERO, S, MINMN )
         RANK = 0
         GO TO 70
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="CLANGE.287"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, M, NRHS, B, LDB, RWORK )
      IBSCL = 0
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm up to SMLNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.293"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, SMLNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 1
      ELSE IF( BNRM.GT.BIGNUM ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Scale matrix norm down to BIGNUM
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASCL.299"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BIGNUM, M, NRHS, B, LDB, INFO )
         IBSCL = 2
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Overdetermined case
</span><span class="comment">*</span><span class="comment">
</span>      IF( M.GE.N ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 1 - overdetermined or exactly determined
</span><span class="comment">*</span><span class="comment">
</span>         MM = M
         IF( M.GE.MNTHR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Path 1a - overdetermined, with many more rows than columns
</span><span class="comment">*</span><span class="comment">
</span>            MM = N
            ITAU = 1
            IWORK = ITAU + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute A=Q*R
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need 2*N, prefer N+N*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="CGEQRF.322"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                   LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Multiply B by transpose(Q)
</span><span class="comment">*</span><span class="comment">           (CWorkspace: need N+NRHS, prefer N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">           (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="CUNMQR.329"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, N, A, LDA, WORK( ITAU ), B,
     $                   LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Zero out below R
</span><span class="comment">*</span><span class="comment">
</span>            IF( N.GT.1 )
     $         CALL <a name="CLASET.335"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'L'</span>, N-1, N-1, CZERO, CZERO, A( 2, 1 ),
     $                      LDA )
         END IF
<span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = 1
         ITAUP = ITAUQ + N
         IWORK = ITAUP + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize R in A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N+MM, prefer 2*N+(MM+N)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.348"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( MM, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of R
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*N+NRHS, prefer 2*N+NRHS*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.356"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, MM, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors of R in A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 3*N-1, prefer 2*N+(N-1)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNGBR.363"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>( <span class="string">'P'</span>, N, N, N, A, LDA, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IRWORK = IE + N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration
</span><span class="comment">*</span><span class="comment">          multiply B by transpose of left singular vectors
</span><span class="comment">*</span><span class="comment">          compute right singular vectors in A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: none)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CBDSQR.373"></a><a href="cbdsqr.f.html#CBDSQR.1">CBDSQR</a>( <span class="string">'U'</span>, N, N, 0, NRHS, S, RWORK( IE ), A, LDA, VDUM,
     $                1, B, LDB, RWORK( IRWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 10 I = 1, N
            IF( S( I ).GT.THR ) THEN
               CALL <a name="CSRSCL.386"></a><a href="csrscl.f.html#CSRSCL.1">CSRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="CLASET.389"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, 1, NRHS, CZERO, CZERO, B( I, 1 ), LDB )
            END IF
   10    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need N, prefer N*NRHS)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS .AND. NRHS.GT.1 ) THEN
            CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, N, NRHS, N, CONE, A, LDA, B, LDB,
     $                  CZERO, WORK, LDB )
            CALL <a name="CLACPY.400"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'G'</span>, N, NRHS, WORK, LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = LWORK / N
            DO 20 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, N, BL, N, CONE, A, LDA, B( 1, I ),
     $                     LDB, CZERO, WORK, N )
               CALL <a name="CLACPY.407"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'G'</span>, N, BL, WORK, N, B( 1, I ), LDB )
   20       CONTINUE
         ELSE
            CALL CGEMV( <span class="string">'C'</span>, N, N, CONE, A, LDA, B, 1, CZERO, WORK, 1 )
            CALL CCOPY( N, WORK, 1, B, 1 )
         END IF
<span class="comment">*</span><span class="comment">
</span>      ELSE IF( N.GE.MNTHR .AND. LWORK.GE.3*M+M*M+MAX( M, NRHS, N-2*M ) )
     $          THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Underdetermined case, M much less than N
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2a - underdetermined, with many more columns than rows
</span><span class="comment">*</span><span class="comment">        and sufficient workspace for an efficient algorithm
</span><span class="comment">*</span><span class="comment">
</span>         LDWORK = M
         IF( LWORK.GE.3*M+M*LDA+MAX( M, NRHS, N-2*M ) )
     $      LDWORK = LDA
         ITAU = 1
         IWORK = M + 1
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute A=L*Q
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*M, prefer M+M*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGELQF.432"></a><a href="cgelqf.f.html#CGELQF.1">CGELQF</a>( M, N, A, LDA, WORK( ITAU ), WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
         IL = IWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Copy L to WORK(IL), zeroing out above it
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLACPY.438"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, M, M, A, LDA, WORK( IL ), LDWORK )
         CALL <a name="CLASET.439"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'U'</span>, M-1, M-1, CZERO, CZERO, WORK( IL+LDWORK ),
     $                LDWORK )
         IE = 1
         ITAUQ = IL + LDWORK*M
         ITAUP = ITAUQ + M
         IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize L in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+4*M, prefer M*M+3*M+2*M*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need M)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.450"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( M, M, WORK( IL ), LDWORK, S, RWORK( IE ),
     $                WORK( ITAUQ ), WORK( ITAUP ), WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors of L
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+3*M+NRHS, prefer M*M+3*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.458"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, M, WORK( IL ), LDWORK,
     $                WORK( ITAUQ ), B, LDB, WORK( IWORK ),
     $                LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors of R in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+4*M-1, prefer M*M+3*M+(M-1)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNGBR.466"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>( <span class="string">'P'</span>, M, M, M, WORK( IL ), LDWORK, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration, computing right singular
</span><span class="comment">*</span><span class="comment">        vectors of L in WORK(IL) and multiplying B by transpose of
</span><span class="comment">*</span><span class="comment">        left singular vectors
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CBDSQR.476"></a><a href="cbdsqr.f.html#CBDSQR.1">CBDSQR</a>( <span class="string">'U'</span>, M, M, 0, NRHS, S, RWORK( IE ), WORK( IL ),
     $                LDWORK, A, LDA, B, LDB, RWORK( IRWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 30 I = 1, M
            IF( S( I ).GT.THR ) THEN
               CALL <a name="CSRSCL.489"></a><a href="csrscl.f.html#CSRSCL.1">CSRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="CLASET.492"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, 1, NRHS, CZERO, CZERO, B( I, 1 ), LDB )
            END IF
   30    CONTINUE
         IWORK = IL + M*LDWORK
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors of L in WORK(IL)
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M*M+2*M, prefer M*M+M+M*NRHS)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS+IWORK-1 .AND. NRHS.GT.1 ) THEN
            CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, M, NRHS, M, CONE, WORK( IL ), LDWORK,
     $                  B, LDB, CZERO, WORK( IWORK ), LDB )
            CALL <a name="CLACPY.504"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'G'</span>, M, NRHS, WORK( IWORK ), LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = ( LWORK-IWORK+1 ) / M
            DO 40 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, M, BL, M, CONE, WORK( IL ), LDWORK,
     $                     B( 1, I ), LDB, CZERO, WORK( IWORK ), M )
               CALL <a name="CLACPY.511"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'G'</span>, M, BL, WORK( IWORK ), M, B( 1, I ),
     $                      LDB )
   40       CONTINUE
         ELSE
            CALL CGEMV( <span class="string">'C'</span>, M, M, CONE, WORK( IL ), LDWORK, B( 1, 1 ),
     $                  1, CZERO, WORK( IWORK ), 1 )
            CALL CCOPY( M, WORK( IWORK ), 1, B( 1, 1 ), 1 )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Zero out below first M rows of B
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CLASET.522"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, N-M, NRHS, CZERO, CZERO, B( M+1, 1 ), LDB )
         IWORK = ITAU + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply transpose(Q) by B
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need M+NRHS, prefer M+NHRS*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMLQ.529"></a><a href="cunmlq.f.html#CUNMLQ.1">CUNMLQ</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, N, NRHS, M, A, LDA, WORK( ITAU ), B,
     $                LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span>      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Path 2 - remaining underdetermined cases
</span><span class="comment">*</span><span class="comment">
</span>         IE = 1
         ITAUQ = 1
         ITAUP = ITAUQ + M
         IWORK = ITAUP + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Bidiagonalize A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 3*M, prefer 2*M+(M+N)*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGEBRD.545"></a><a href="cgebrd.f.html#CGEBRD.1">CGEBRD</a>( M, N, A, LDA, S, RWORK( IE ), WORK( ITAUQ ),
     $                WORK( ITAUP ), WORK( IWORK ), LWORK-IWORK+1,
     $                INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by transpose of left bidiagonalizing vectors
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 2*M+NRHS, prefer 2*M+NRHS*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNMBR.553"></a><a href="cunmbr.f.html#CUNMBR.1">CUNMBR</a>( <span class="string">'Q'</span>, <span class="string">'L'</span>, <span class="string">'C'</span>, M, NRHS, N, A, LDA, WORK( ITAUQ ),
     $                B, LDB, WORK( IWORK ), LWORK-IWORK+1, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Generate right bidiagonalizing vectors in A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need 3*M, prefer 2*M+M*NB)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CUNGBR.560"></a><a href="cungbr.f.html#CUNGBR.1">CUNGBR</a>( <span class="string">'P'</span>, M, N, M, A, LDA, WORK( ITAUP ),
     $                WORK( IWORK ), LWORK-IWORK+1, INFO )
         IRWORK = IE + M
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Perform bidiagonal QR iteration,
</span><span class="comment">*</span><span class="comment">           computing right singular vectors of A in A and
</span><span class="comment">*</span><span class="comment">           multiplying B by transpose of left singular vectors
</span><span class="comment">*</span><span class="comment">        (CWorkspace: none)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: need BDSPAC)
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CBDSQR.570"></a><a href="cbdsqr.f.html#CBDSQR.1">CBDSQR</a>( <span class="string">'L'</span>, M, N, 0, NRHS, S, RWORK( IE ), A, LDA, VDUM,
     $                1, B, LDB, RWORK( IRWORK ), INFO )
         IF( INFO.NE.0 )
     $      GO TO 70
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by reciprocals of singular values
</span><span class="comment">*</span><span class="comment">
</span>         THR = MAX( RCOND*S( 1 ), SFMIN )
         IF( RCOND.LT.ZERO )
     $      THR = MAX( EPS*S( 1 ), SFMIN )
         RANK = 0
         DO 50 I = 1, M
            IF( S( I ).GT.THR ) THEN
               CALL <a name="CSRSCL.583"></a><a href="csrscl.f.html#CSRSCL.1">CSRSCL</a>( NRHS, S( I ), B( I, 1 ), LDB )
               RANK = RANK + 1
            ELSE
               CALL <a name="CLASET.586"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'F'</span>, 1, NRHS, CZERO, CZERO, B( I, 1 ), LDB )
            END IF
   50    CONTINUE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Multiply B by right singular vectors of A
</span><span class="comment">*</span><span class="comment">        (CWorkspace: need N, prefer N*NRHS)
</span><span class="comment">*</span><span class="comment">        (RWorkspace: none)
</span><span class="comment">*</span><span class="comment">
</span>         IF( LWORK.GE.LDB*NRHS .AND. NRHS.GT.1 ) THEN
            CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, N, NRHS, M, CONE, A, LDA, B, LDB,
     $                  CZERO, WORK, LDB )
            CALL <a name="CLACPY.597"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'G'</span>, N, NRHS, WORK, LDB, B, LDB )
         ELSE IF( NRHS.GT.1 ) THEN
            CHUNK = LWORK / N
            DO 60 I = 1, NRHS, CHUNK
               BL = MIN( NRHS-I+1, CHUNK )
               CALL CGEMM( <span class="string">'C'</span>, <span class="string">'N'</span>, N, BL, M, CONE, A, LDA, B( 1, I ),
     $                     LDB, CZERO, WORK, N )
               CALL <a name="CLACPY.604"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'F'</span>, N, BL, WORK, N, B( 1, I ), LDB )
   60       CONTINUE
         ELSE
            CALL CGEMV( <span class="string">'C'</span>, M, N, CONE, A, LDA, B, 1, CZERO, WORK, 1 )
            CALL CCOPY( N, WORK, 1, B, 1 )
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling
</span><span class="comment">*</span><span class="comment">
</span>      IF( IASCL.EQ.1 ) THEN
         CALL <a name="CLASCL.615"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, SMLNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.616"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      ELSE IF( IASCL.EQ.2 ) THEN
         CALL <a name="CLASCL.619"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, BIGNUM, N, NRHS, B, LDB, INFO )
         CALL <a name="SLASCL.620"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, ANRM, MINMN, 1, S, MINMN,
     $                INFO )
      END IF
      IF( IBSCL.EQ.1 ) THEN
         CALL <a name="CLASCL.624"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, SMLNUM, BNRM, N, NRHS, B, LDB, INFO )
      ELSE IF( IBSCL.EQ.2 ) THEN
         CALL <a name="CLASCL.626"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, 0, 0, BIGNUM, BNRM, N, NRHS, B, LDB, INFO )
      END IF
   70 CONTINUE
      WORK( 1 ) = MAXWRK
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="CGELSS.632"></a><a href="cgelss.f.html#CGELSS.1">CGELSS</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
