<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>cgegv.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="CGEGV.1"></a><a href="cgegv.f.html#CGEGV.1">CGEGV</a>( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHA, BETA,
     $                  VL, LDVL, VR, LDVR, WORK, LWORK, RWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          JOBVL, JOBVR
      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      REAL               RWORK( * )
      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),
     $                   BETA( * ), VL( LDVL, * ), VR( LDVR, * ),
     $                   WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This routine is deprecated and has been replaced by routine <a name="CGGEV.22"></a><a href="cggev.f.html#CGGEV.1">CGGEV</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="CGEGV.24"></a><a href="cgegv.f.html#CGEGV.1">CGEGV</a> computes the eigenvalues and, optionally, the left and/or right
</span><span class="comment">*</span><span class="comment">  eigenvectors of a complex matrix pair (A,B).
</span><span class="comment">*</span><span class="comment">  Given two square matrices A and B,
</span><span class="comment">*</span><span class="comment">  the generalized nonsymmetric eigenvalue problem (GNEP) is to find the
</span><span class="comment">*</span><span class="comment">  eigenvalues lambda and corresponding (non-zero) eigenvectors x such
</span><span class="comment">*</span><span class="comment">  that
</span><span class="comment">*</span><span class="comment">     A*x = lambda*B*x.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An alternate form is to find the eigenvalues mu and corresponding
</span><span class="comment">*</span><span class="comment">  eigenvectors y such that
</span><span class="comment">*</span><span class="comment">     mu*A*y = B*y.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  These two forms are equivalent with mu = 1/lambda and x = y if
</span><span class="comment">*</span><span class="comment">  neither lambda nor mu is zero.  In order to deal with the case that
</span><span class="comment">*</span><span class="comment">  lambda or mu is zero or small, two values alpha and beta are returned
</span><span class="comment">*</span><span class="comment">  for each eigenvalue, such that lambda = alpha/beta and
</span><span class="comment">*</span><span class="comment">  mu = beta/alpha.
</span><span class="comment">*</span><span class="comment">  
</span><span class="comment">*</span><span class="comment">  The vectors x and y in the above equations are right eigenvectors of
</span><span class="comment">*</span><span class="comment">  the matrix pair (A,B).  Vectors u and v satisfying
</span><span class="comment">*</span><span class="comment">     u**H*A = lambda*u**H*B  or  mu*v**H*A = v**H*B
</span><span class="comment">*</span><span class="comment">  are left eigenvectors of (A,B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Note: this routine performs &quot;full balancing&quot; on A and B -- see
</span><span class="comment">*</span><span class="comment">  &quot;Further Details&quot;, below.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVL   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the left generalized eigenvectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the left generalized eigenvectors (returned
</span><span class="comment">*</span><span class="comment">                  in VL).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVR   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the right generalized eigenvectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the right generalized eigenvectors (returned
</span><span class="comment">*</span><span class="comment">                  in VR).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices A, B, VL, and VR.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) COMPLEX array, dimension (LDA, N)
</span><span class="comment">*</span><span class="comment">          On entry, the matrix A.
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'V' or JOBVR = 'V', then on exit A
</span><span class="comment">*</span><span class="comment">          contains the Schur form of A from the generalized Schur
</span><span class="comment">*</span><span class="comment">          factorization of the pair (A,B) after balancing.  If no
</span><span class="comment">*</span><span class="comment">          eigenvectors were computed, then only the diagonal elements
</span><span class="comment">*</span><span class="comment">          of the Schur form will be correct.  See <a name="CGGHRD.72"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a> and <a name="CHGEQZ.72"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>
</span><span class="comment">*</span><span class="comment">          for details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of A.  LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) COMPLEX array, dimension (LDB, N)
</span><span class="comment">*</span><span class="comment">          On entry, the matrix B.
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'V' or JOBVR = 'V', then on exit B contains the
</span><span class="comment">*</span><span class="comment">          upper triangular matrix obtained from B in the generalized
</span><span class="comment">*</span><span class="comment">          Schur factorization of the pair (A,B) after balancing.
</span><span class="comment">*</span><span class="comment">          If no eigenvectors were computed, then only the diagonal
</span><span class="comment">*</span><span class="comment">          elements of B will be correct.  See <a name="CGGHRD.84"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a> and <a name="CHGEQZ.84"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a> for
</span><span class="comment">*</span><span class="comment">          details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of B.  LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHA   (output) COMPLEX array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The complex scalars alpha that define the eigenvalues of
</span><span class="comment">*</span><span class="comment">          GNEP.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BETA    (output) COMPLEX array, dimension (N)
</span><span class="comment">*</span><span class="comment">          The complex scalars beta that define the eigenvalues of GNEP.
</span><span class="comment">*</span><span class="comment">          
</span><span class="comment">*</span><span class="comment">          Together, the quantities alpha = ALPHA(j) and beta = BETA(j)
</span><span class="comment">*</span><span class="comment">          represent the j-th eigenvalue of the matrix pair (A,B), in
</span><span class="comment">*</span><span class="comment">          one of the forms lambda = alpha/beta or mu = beta/alpha.
</span><span class="comment">*</span><span class="comment">          Since either lambda or mu may overflow, they should not,
</span><span class="comment">*</span><span class="comment">          in general, be computed.
</span>
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VL      (output) COMPLEX array, dimension (LDVL,N)
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'V', the left eigenvectors u(j) are stored
</span><span class="comment">*</span><span class="comment">          in the columns of VL, in the same order as their eigenvalues.
</span><span class="comment">*</span><span class="comment">          Each eigenvector is scaled so that its largest component has
</span><span class="comment">*</span><span class="comment">          abs(real part) + abs(imag. part) = 1, except for eigenvectors
</span><span class="comment">*</span><span class="comment">          corresponding to an eigenvalue with alpha = beta = 0, which
</span><span class="comment">*</span><span class="comment">          are set to zero.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVL = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVL    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VL. LDVL &gt;= 1, and
</span><span class="comment">*</span><span class="comment">          if JOBVL = 'V', LDVL &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VR      (output) COMPLEX array, dimension (LDVR,N)
</span><span class="comment">*</span><span class="comment">          If JOBVR = 'V', the right eigenvectors x(j) are stored
</span><span class="comment">*</span><span class="comment">          in the columns of VR, in the same order as their eigenvalues.
</span><span class="comment">*</span><span class="comment">          Each eigenvector is scaled so that its largest component has
</span><span class="comment">*</span><span class="comment">          abs(real part) + abs(imag. part) = 1, except for eigenvectors
</span><span class="comment">*</span><span class="comment">          corresponding to an eigenvalue with alpha = beta = 0, which
</span><span class="comment">*</span><span class="comment">          are set to zero.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVR = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVR    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VR. LDVR &gt;= 1, and
</span><span class="comment">*</span><span class="comment">          if JOBVR = 'V', LDVR &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK.  LWORK &gt;= max(1,2*N).
</span><span class="comment">*</span><span class="comment">          For good performance, LWORK must generally be larger.
</span><span class="comment">*</span><span class="comment">          To compute the optimal value of LWORK, call <a name="ILAENV.136"></a><a href="hfy-index.html#ILAENV">ILAENV</a> to get
</span><span class="comment">*</span><span class="comment">          blocksizes (for <a name="CGEQRF.137"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CUNMQR.137"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, and <a name="CUNGQR.137"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>.)  Then compute:
</span><span class="comment">*</span><span class="comment">          NB  -- MAX of the blocksizes for <a name="CGEQRF.138"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CUNMQR.138"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, and <a name="CUNGQR.138"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>;
</span><span class="comment">*</span><span class="comment">          The optimal LWORK is  MAX( 2*N, N*(NB+1) ).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.144"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RWORK   (workspace/output) REAL array, dimension (8*N)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          =1,...,N:
</span><span class="comment">*</span><span class="comment">                The QZ iteration failed.  No eigenvectors have been
</span><span class="comment">*</span><span class="comment">                calculated, but ALPHA(j) and BETA(j) should be
</span><span class="comment">*</span><span class="comment">                correct for j=INFO+1,...,N.
</span><span class="comment">*</span><span class="comment">          &gt; N:  errors that usually indicate LAPACK problems:
</span><span class="comment">*</span><span class="comment">                =N+1: error return from <a name="CGGBAL.156"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a>
</span><span class="comment">*</span><span class="comment">                =N+2: error return from <a name="CGEQRF.157"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>
</span><span class="comment">*</span><span class="comment">                =N+3: error return from <a name="CUNMQR.158"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>
</span><span class="comment">*</span><span class="comment">                =N+4: error return from <a name="CUNGQR.159"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>
</span><span class="comment">*</span><span class="comment">                =N+5: error return from <a name="CGGHRD.160"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>
</span><span class="comment">*</span><span class="comment">                =N+6: error return from <a name="CHGEQZ.161"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a> (other than failed
</span><span class="comment">*</span><span class="comment">                                               iteration)
</span><span class="comment">*</span><span class="comment">                =N+7: error return from <a name="CTGEVC.163"></a><a href="ctgevc.f.html#CTGEVC.1">CTGEVC</a>
</span><span class="comment">*</span><span class="comment">                =N+8: error return from <a name="CGGBAK.164"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a> (computing VL)
</span><span class="comment">*</span><span class="comment">                =N+9: error return from <a name="CGGBAK.165"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a> (computing VR)
</span><span class="comment">*</span><span class="comment">                =N+10: error return from <a name="CLASCL.166"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a> (various calls)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Balancing
</span><span class="comment">*</span><span class="comment">  ---------
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  This driver calls <a name="CGGBAL.174"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a> to both permute and scale rows and columns
</span><span class="comment">*</span><span class="comment">  of A and B.  The permutations PL and PR are chosen so that PL*A*PR
</span><span class="comment">*</span><span class="comment">  and PL*B*R will be upper triangular except for the diagonal blocks
</span><span class="comment">*</span><span class="comment">  A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
</span><span class="comment">*</span><span class="comment">  possible.  The diagonal scaling matrices DL and DR are chosen so
</span><span class="comment">*</span><span class="comment">  that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
</span><span class="comment">*</span><span class="comment">  one (except for the elements that start out zero.)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  After the eigenvalues and eigenvectors of the balanced matrices
</span><span class="comment">*</span><span class="comment">  have been computed, <a name="CGGBAK.183"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a> transforms the eigenvectors back to what
</span><span class="comment">*</span><span class="comment">  they would have been (in perfect arithmetic) if they had not been
</span><span class="comment">*</span><span class="comment">  balanced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Contents of A and B on Exit
</span><span class="comment">*</span><span class="comment">  -------- -- - --- - -- ----
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
</span><span class="comment">*</span><span class="comment">  both), then on exit the arrays A and B will contain the complex Schur
</span><span class="comment">*</span><span class="comment">  form[*] of the &quot;balanced&quot; versions of A and B.  If no eigenvectors
</span><span class="comment">*</span><span class="comment">  are computed, then only the diagonal blocks will be correct.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [*] In other words, upper triangular form.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E0, ONE = 1.0E0 )
      COMPLEX            CZERO, CONE
      PARAMETER          ( CZERO = ( 0.0E0, 0.0E0 ),
     $                   CONE = ( 1.0E0, 0.0E0 ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            ILIMIT, ILV, ILVL, ILVR, LQUERY
      CHARACTER          CHTEMP
      INTEGER            ICOLS, IHI, IINFO, IJOBVL, IJOBVR, ILEFT, ILO,
     $                   IN, IRIGHT, IROWS, IRWORK, ITAU, IWORK, JC, JR,
     $                   LOPT, LWKMIN, LWKOPT, NB, NB1, NB2, NB3
      REAL               ABSAI, ABSAR, ABSB, ANRM, ANRM1, ANRM2, BNRM,
     $                   BNRM1, BNRM2, EPS, SAFMAX, SAFMIN, SALFAI,
     $                   SALFAR, SBETA, SCALE, TEMP
      COMPLEX            X
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      LOGICAL            LDUMMA( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="CGEQRF.221"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>, <a name="CGGBAK.221"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>, <a name="CGGBAL.221"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a>, <a name="CGGHRD.221"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>, <a name="CHGEQZ.221"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>, <a name="CLACPY.221"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>,
     $                   <a name="CLASCL.222"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>, <a name="CLASET.222"></a><a href="claset.f.html#CLASET.1">CLASET</a>, <a name="CTGEVC.222"></a><a href="ctgevc.f.html#CTGEVC.1">CTGEVC</a>, <a name="CUNGQR.222"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>, <a name="CUNMQR.222"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>, <a name="XERBLA.222"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.225"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.226"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="CLANGE.227"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.227"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
      EXTERNAL           <a name="ILAENV.228"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="LSAME.228"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="CLANGE.228"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>, <a name="SLAMCH.228"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, AIMAG, CMPLX, INT, MAX, REAL
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Statement Functions ..
</span>      REAL               ABS1
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Statement Function definitions ..
</span>      ABS1( X ) = ABS( REAL( X ) ) + ABS( AIMAG( X ) )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.243"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'N'</span> ) ) THEN
         IJOBVL = 1
         ILVL = .FALSE.
      ELSE IF( <a name="LSAME.246"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'V'</span> ) ) THEN
         IJOBVL = 2
         ILVL = .TRUE.
      ELSE
         IJOBVL = -1
         ILVL = .FALSE.
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.254"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'N'</span> ) ) THEN
         IJOBVR = 1
         ILVR = .FALSE.
      ELSE IF( <a name="LSAME.257"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'V'</span> ) ) THEN
         IJOBVR = 2
         ILVR = .TRUE.
      ELSE
         IJOBVR = -1
         ILVR = .FALSE.
      END IF
      ILV = ILVL .OR. ILVR
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      LWKMIN = MAX( 2*N, 1 )
      LWKOPT = LWKMIN
      WORK( 1 ) = LWKOPT
      LQUERY = ( LWORK.EQ.-1 )
      INFO = 0
      IF( IJOBVL.LE.0 ) THEN
         INFO = -1
      ELSE IF( IJOBVR.LE.0 ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -3
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -5
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDVL.LT.1 .OR. ( ILVL .AND. LDVL.LT.N ) ) THEN
         INFO = -11
      ELSE IF( LDVR.LT.1 .OR. ( ILVR .AND. LDVR.LT.N ) ) THEN
         INFO = -13
      ELSE IF( LWORK.LT.LWKMIN .AND. .NOT.LQUERY ) THEN
         INFO = -15
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         NB1 = <a name="ILAENV.292"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CGEQRF.292"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>'</span>, <span class="string">' '</span>, N, N, -1, -1 )
         NB2 = <a name="ILAENV.293"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNMQR.293"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>'</span>, <span class="string">' '</span>, N, N, N, -1 )
         NB3 = <a name="ILAENV.294"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="CUNGQR.294"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>'</span>, <span class="string">' '</span>, N, N, N, -1 )
         NB = MAX( NB1, NB2, NB3 )
         LOPT = MAX( 2*N, N*(NB+1) )
         WORK( 1 ) = LOPT
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.301"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="CGEGV.301"></a><a href="cgegv.f.html#CGEGV.1">CGEGV</a> '</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.314"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'E'</span> )*<a name="SLAMCH.314"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'B'</span> )
      SAFMIN = <a name="SLAMCH.315"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      SAFMIN = SAFMIN + SAFMIN
      SAFMAX = ONE / SAFMIN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="CLANGE.321"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, N, N, A, LDA, RWORK )
      ANRM1 = ANRM
      ANRM2 = ONE
      IF( ANRM.LT.ONE ) THEN
         IF( SAFMAX*ANRM.LT.ONE ) THEN
            ANRM1 = SAFMIN
            ANRM2 = SAFMAX*ANRM
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ANRM.GT.ZERO ) THEN
         CALL <a name="CLASCL.332"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, -1, -1, ANRM, ONE, N, N, A, LDA, IINFO )
         IF( IINFO.NE.0 ) THEN
            INFO = N + 10
            RETURN
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="CLANGE.341"></a><a href="clange.f.html#CLANGE.1">CLANGE</a>( <span class="string">'M'</span>, N, N, B, LDB, RWORK )
      BNRM1 = BNRM
      BNRM2 = ONE
      IF( BNRM.LT.ONE ) THEN
         IF( SAFMAX*BNRM.LT.ONE ) THEN
            BNRM1 = SAFMIN
            BNRM2 = SAFMAX*BNRM
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( BNRM.GT.ZERO ) THEN
         CALL <a name="CLASCL.352"></a><a href="clascl.f.html#CLASCL.1">CLASCL</a>( <span class="string">'G'</span>, -1, -1, BNRM, ONE, N, N, B, LDB, IINFO )
         IF( IINFO.NE.0 ) THEN
            INFO = N + 10
            RETURN
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Permute the matrix to make it more nearly triangular
</span><span class="comment">*</span><span class="comment">     Also &quot;balance&quot; the matrix.
</span><span class="comment">*</span><span class="comment">
</span>      ILEFT = 1
      IRIGHT = N + 1
      IRWORK = IRIGHT + N
      CALL <a name="CGGBAL.365"></a><a href="cggbal.f.html#CGGBAL.1">CGGBAL</a>( <span class="string">'P'</span>, N, A, LDA, B, LDB, ILO, IHI, RWORK( ILEFT ),
     $             RWORK( IRIGHT ), RWORK( IRWORK ), IINFO )
      IF( IINFO.NE.0 ) THEN
         INFO = N + 1
         GO TO 80
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce B to triangular form, and initialize VL and/or VR
</span><span class="comment">*</span><span class="comment">
</span>      IROWS = IHI + 1 - ILO
      IF( ILV ) THEN
         ICOLS = N + 1 - ILO
      ELSE
         ICOLS = IROWS
      END IF
      ITAU = 1
      IWORK = ITAU + IROWS
      CALL <a name="CGEQRF.382"></a><a href="cgeqrf.f.html#CGEQRF.1">CGEQRF</a>( IROWS, ICOLS, B( ILO, ILO ), LDB, WORK( ITAU ),
     $             WORK( IWORK ), LWORK+1-IWORK, IINFO )
      IF( IINFO.GE.0 )
     $   LWKOPT = MAX( LWKOPT, INT( WORK( IWORK ) )+IWORK-1 )
      IF( IINFO.NE.0 ) THEN
         INFO = N + 2
         GO TO 80
      END IF
<span class="comment">*</span><span class="comment">
</span>      CALL <a name="CUNMQR.391"></a><a href="cunmqr.f.html#CUNMQR.1">CUNMQR</a>( <span class="string">'L'</span>, <span class="string">'C'</span>, IROWS, ICOLS, IROWS, B( ILO, ILO ), LDB,
     $             WORK( ITAU ), A( ILO, ILO ), LDA, WORK( IWORK ),
     $             LWORK+1-IWORK, IINFO )
      IF( IINFO.GE.0 )
     $   LWKOPT = MAX( LWKOPT, INT( WORK( IWORK ) )+IWORK-1 )
      IF( IINFO.NE.0 ) THEN
         INFO = N + 3
         GO TO 80
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILVL ) THEN
         CALL <a name="CLASET.402"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'Full'</span>, N, N, CZERO, CONE, VL, LDVL )
         CALL <a name="CLACPY.403"></a><a href="clacpy.f.html#CLACPY.1">CLACPY</a>( <span class="string">'L'</span>, IROWS-1, IROWS-1, B( ILO+1, ILO ), LDB,
     $                VL( ILO+1, ILO ), LDVL )
         CALL <a name="CUNGQR.405"></a><a href="cungqr.f.html#CUNGQR.1">CUNGQR</a>( IROWS, IROWS, IROWS, VL( ILO, ILO ), LDVL,
     $                WORK( ITAU ), WORK( IWORK ), LWORK+1-IWORK,
     $                IINFO )
         IF( IINFO.GE.0 )
     $      LWKOPT = MAX( LWKOPT, INT( WORK( IWORK ) )+IWORK-1 )
         IF( IINFO.NE.0 ) THEN
            INFO = N + 4
            GO TO 80
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILVR )
     $   CALL <a name="CLASET.417"></a><a href="claset.f.html#CLASET.1">CLASET</a>( <span class="string">'Full'</span>, N, N, CZERO, CONE, VR, LDVR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce to generalized Hessenberg form
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILV ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Eigenvectors requested -- work on whole matrix.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="CGGHRD.425"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>( JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB, VL,
     $                LDVL, VR, LDVR, IINFO )
      ELSE
         CALL <a name="CGGHRD.428"></a><a href="cgghrd.f.html#CGGHRD.1">CGGHRD</a>( <span class="string">'N'</span>, <span class="string">'N'</span>, IROWS, 1, IROWS, A( ILO, ILO ), LDA,
     $                B( ILO, ILO ), LDB, VL, LDVL, VR, LDVR, IINFO )
      END IF
      IF( IINFO.NE.0 ) THEN
         INFO = N + 5
         GO TO 80
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Perform QZ algorithm
</span><span class="comment">*</span><span class="comment">
</span>      IWORK = ITAU
      IF( ILV ) THEN
         CHTEMP = <span class="string">'S'</span>
      ELSE
         CHTEMP = <span class="string">'E'</span>
      END IF
      CALL <a name="CHGEQZ.444"></a><a href="chgeqz.f.html#CHGEQZ.1">CHGEQZ</a>( CHTEMP, JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB,
     $             ALPHA, BETA, VL, LDVL, VR, LDVR, WORK( IWORK ),
     $             LWORK+1-IWORK, RWORK( IRWORK ), IINFO )
      IF( IINFO.GE.0 )
     $   LWKOPT = MAX( LWKOPT, INT( WORK( IWORK ) )+IWORK-1 )
      IF( IINFO.NE.0 ) THEN
         IF( IINFO.GT.0 .AND. IINFO.LE.N ) THEN
            INFO = IINFO
         ELSE IF( IINFO.GT.N .AND. IINFO.LE.2*N ) THEN
            INFO = IINFO - N
         ELSE
            INFO = N + 6
         END IF
         GO TO 80
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILV ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Compute Eigenvectors
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILVL ) THEN
            IF( ILVR ) THEN
               CHTEMP = <span class="string">'B'</span>
            ELSE
               CHTEMP = <span class="string">'L'</span>
            END IF
         ELSE
            CHTEMP = <span class="string">'R'</span>
         END IF
<span class="comment">*</span><span class="comment">
</span>         CALL <a name="CTGEVC.474"></a><a href="ctgevc.f.html#CTGEVC.1">CTGEVC</a>( CHTEMP, <span class="string">'B'</span>, LDUMMA, N, A, LDA, B, LDB, VL, LDVL,
     $                VR, LDVR, N, IN, WORK( IWORK ), RWORK( IRWORK ),
     $                IINFO )
         IF( IINFO.NE.0 ) THEN
            INFO = N + 7
            GO TO 80
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Undo balancing on VL and VR, rescale
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILVL ) THEN
            CALL <a name="CGGBAK.485"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>( <span class="string">'P'</span>, <span class="string">'L'</span>, N, ILO, IHI, RWORK( ILEFT ),
     $                   RWORK( IRIGHT ), N, VL, LDVL, IINFO )
            IF( IINFO.NE.0 ) THEN
               INFO = N + 8
               GO TO 80
            END IF
            DO 30 JC = 1, N
               TEMP = ZERO
               DO 10 JR = 1, N
                  TEMP = MAX( TEMP, ABS1( VL( JR, JC ) ) )
   10          CONTINUE
               IF( TEMP.LT.SAFMIN )
     $            GO TO 30
               TEMP = ONE / TEMP
               DO 20 JR = 1, N
                  VL( JR, JC ) = VL( JR, JC )*TEMP
   20          CONTINUE
   30       CONTINUE
         END IF
         IF( ILVR ) THEN
            CALL <a name="CGGBAK.505"></a><a href="cggbak.f.html#CGGBAK.1">CGGBAK</a>( <span class="string">'P'</span>, <span class="string">'R'</span>, N, ILO, IHI, RWORK( ILEFT ),
     $                   RWORK( IRIGHT ), N, VR, LDVR, IINFO )
            IF( IINFO.NE.0 ) THEN
               INFO = N + 9
               GO TO 80
            END IF
            DO 60 JC = 1, N
               TEMP = ZERO
               DO 40 JR = 1, N
                  TEMP = MAX( TEMP, ABS1( VR( JR, JC ) ) )
   40          CONTINUE
               IF( TEMP.LT.SAFMIN )
     $            GO TO 60
               TEMP = ONE / TEMP
               DO 50 JR = 1, N
                  VR( JR, JC ) = VR( JR, JC )*TEMP
   50          CONTINUE
   60       CONTINUE
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        End of eigenvector calculation
</span><span class="comment">*</span><span class="comment">
</span>      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling in alpha, beta
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Note: this does not give the alpha and beta for the unscaled
</span><span class="comment">*</span><span class="comment">     problem.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Un-scaling is limited to avoid underflow in alpha and beta
</span><span class="comment">*</span><span class="comment">     if they are significant.
</span><span class="comment">*</span><span class="comment">
</span>      DO 70 JC = 1, N
         ABSAR = ABS( REAL( ALPHA( JC ) ) )
         ABSAI = ABS( AIMAG( ALPHA( JC ) ) )
         ABSB = ABS( REAL( BETA( JC ) ) )
         SALFAR = ANRM*REAL( ALPHA( JC ) )
         SALFAI = ANRM*AIMAG( ALPHA( JC ) )
         SBETA = BNRM*REAL( BETA( JC ) )
         ILIMIT = .FALSE.
         SCALE = ONE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check for significant underflow in imaginary part of ALPHA
</span><span class="comment">*</span><span class="comment">
</span>         IF( ABS( SALFAI ).LT.SAFMIN .AND. ABSAI.GE.
     $       MAX( SAFMIN, EPS*ABSAR, EPS*ABSB ) ) THEN
            ILIMIT = .TRUE.
            SCALE = ( SAFMIN / ANRM1 ) / MAX( SAFMIN, ANRM2*ABSAI )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check for significant underflow in real part of ALPHA
</span><span class="comment">*</span><span class="comment">
</span>         IF( ABS( SALFAR ).LT.SAFMIN .AND. ABSAR.GE.
     $       MAX( SAFMIN, EPS*ABSAI, EPS*ABSB ) ) THEN
            ILIMIT = .TRUE.
            SCALE = MAX( SCALE, ( SAFMIN / ANRM1 ) /
     $              MAX( SAFMIN, ANRM2*ABSAR ) )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check for significant underflow in BETA
</span><span class="comment">*</span><span class="comment">
</span>         IF( ABS( SBETA ).LT.SAFMIN .AND. ABSB.GE.
     $       MAX( SAFMIN, EPS*ABSAR, EPS*ABSAI ) ) THEN
            ILIMIT = .TRUE.
            SCALE = MAX( SCALE, ( SAFMIN / BNRM1 ) /
     $              MAX( SAFMIN, BNRM2*ABSB ) )
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Check for possible overflow when limiting scaling
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILIMIT ) THEN
            TEMP = ( SCALE*SAFMIN )*MAX( ABS( SALFAR ), ABS( SALFAI ),
     $             ABS( SBETA ) )
            IF( TEMP.GT.ONE )
     $         SCALE = SCALE / TEMP
            IF( SCALE.LT.ONE )
     $         ILIMIT = .FALSE.
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Recompute un-scaled ALPHA, BETA if necessary.
</span><span class="comment">*</span><span class="comment">
</span>         IF( ILIMIT ) THEN
            SALFAR = ( SCALE*REAL( ALPHA( JC ) ) )*ANRM
            SALFAI = ( SCALE*AIMAG( ALPHA( JC ) ) )*ANRM
            SBETA = ( SCALE*BETA( JC ) )*BNRM
         END IF
         ALPHA( JC ) = CMPLX( SALFAR, SALFAI )
         BETA( JC ) = SBETA
   70 CONTINUE
<span class="comment">*</span><span class="comment">
</span>   80 CONTINUE
      WORK( 1 ) = LWKOPT
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="CGEGV.600"></a><a href="cgegv.f.html#CGEGV.1">CGEGV</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
