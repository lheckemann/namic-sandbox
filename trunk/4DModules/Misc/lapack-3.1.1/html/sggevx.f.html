<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>sggevx.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="SGGEVX.1"></a><a href="sggevx.f.html#SGGEVX.1">SGGEVX</a>( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB,
     $                   ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO,
     $                   IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE,
     $                   RCONDV, WORK, LWORK, IWORK, BWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK driver routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          BALANC, JOBVL, JOBVR, SENSE
      INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N
      REAL               ABNRM, BBNRM
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      LOGICAL            BWORK( * )
      INTEGER            IWORK( * )
      REAL               A( LDA, * ), ALPHAI( * ), ALPHAR( * ),
     $                   B( LDB, * ), BETA( * ), LSCALE( * ),
     $                   RCONDE( * ), RCONDV( * ), RSCALE( * ),
     $                   VL( LDVL, * ), VR( LDVR, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="SGGEVX.27"></a><a href="sggevx.f.html#SGGEVX.1">SGGEVX</a> computes for a pair of N-by-N real nonsymmetric matrices (A,B)
</span><span class="comment">*</span><span class="comment">  the generalized eigenvalues, and optionally, the left and/or right
</span><span class="comment">*</span><span class="comment">  generalized eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Optionally also, it computes a balancing transformation to improve
</span><span class="comment">*</span><span class="comment">  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
</span><span class="comment">*</span><span class="comment">  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
</span><span class="comment">*</span><span class="comment">  the eigenvalues (RCONDE), and reciprocal condition numbers for the
</span><span class="comment">*</span><span class="comment">  right eigenvectors (RCONDV).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A generalized eigenvalue for a pair of matrices (A,B) is a scalar
</span><span class="comment">*</span><span class="comment">  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
</span><span class="comment">*</span><span class="comment">  singular. It is usually represented as the pair (alpha,beta), as
</span><span class="comment">*</span><span class="comment">  there is a reasonable interpretation for beta=0, and even for both
</span><span class="comment">*</span><span class="comment">  being zero.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
</span><span class="comment">*</span><span class="comment">  of (A,B) satisfies
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                   A * v(j) = lambda(j) * B * v(j) .
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
</span><span class="comment">*</span><span class="comment">  of (A,B) satisfies
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                   u(j)**H * A  = lambda(j) * u(j)**H * B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where u(j)**H is the conjugate-transpose of u(j).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BALANC  (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies the balance option to be performed.
</span><span class="comment">*</span><span class="comment">          = 'N':  do not diagonally scale or permute;
</span><span class="comment">*</span><span class="comment">          = 'P':  permute only;
</span><span class="comment">*</span><span class="comment">          = 'S':  scale only;
</span><span class="comment">*</span><span class="comment">          = 'B':  both permute and scale.
</span><span class="comment">*</span><span class="comment">          Computed reciprocal condition numbers will be for the
</span><span class="comment">*</span><span class="comment">          matrices after permuting and/or balancing. Permuting does
</span><span class="comment">*</span><span class="comment">          not change condition numbers (in exact arithmetic), but
</span><span class="comment">*</span><span class="comment">          balancing does.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVL   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the left generalized eigenvectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the left generalized eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOBVR   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'N':  do not compute the right generalized eigenvectors;
</span><span class="comment">*</span><span class="comment">          = 'V':  compute the right generalized eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SENSE   (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Determines which reciprocal condition numbers are computed.
</span><span class="comment">*</span><span class="comment">          = 'N': none are computed;
</span><span class="comment">*</span><span class="comment">          = 'E': computed for eigenvalues only;
</span><span class="comment">*</span><span class="comment">          = 'V': computed for eigenvectors only;
</span><span class="comment">*</span><span class="comment">          = 'B': computed for eigenvalues and eigenvectors.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the matrices A, B, VL, and VR.  N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input/output) REAL array, dimension (LDA, N)
</span><span class="comment">*</span><span class="comment">          On entry, the matrix A in the pair (A,B).
</span><span class="comment">*</span><span class="comment">          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
</span><span class="comment">*</span><span class="comment">          or both, then A contains the first part of the real Schur
</span><span class="comment">*</span><span class="comment">          form of the &quot;balanced&quot; versions of the input A and B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of A.  LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input/output) REAL array, dimension (LDB, N)
</span><span class="comment">*</span><span class="comment">          On entry, the matrix B in the pair (A,B).
</span><span class="comment">*</span><span class="comment">          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
</span><span class="comment">*</span><span class="comment">          or both, then B contains the second part of the real Schur
</span><span class="comment">*</span><span class="comment">          form of the &quot;balanced&quot; versions of the input A and B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of B.  LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ALPHAR  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">  ALPHAI  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">  BETA    (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
</span><span class="comment">*</span><span class="comment">          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
</span><span class="comment">*</span><span class="comment">          the j-th eigenvalue is real; if positive, then the j-th and
</span><span class="comment">*</span><span class="comment">          (j+1)-st eigenvalues are a complex conjugate pair, with
</span><span class="comment">*</span><span class="comment">          ALPHAI(j+1) negative.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
</span><span class="comment">*</span><span class="comment">          may easily over- or underflow, and BETA(j) may even be zero.
</span><span class="comment">*</span><span class="comment">          Thus, the user should avoid naively computing the ratio
</span><span class="comment">*</span><span class="comment">          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
</span><span class="comment">*</span><span class="comment">          than and usually comparable with norm(A) in magnitude, and
</span><span class="comment">*</span><span class="comment">          BETA always less than and usually comparable with norm(B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VL      (output) REAL array, dimension (LDVL,N)
</span><span class="comment">*</span><span class="comment">          If JOBVL = 'V', the left eigenvectors u(j) are stored one
</span><span class="comment">*</span><span class="comment">          after another in the columns of VL, in the same order as
</span><span class="comment">*</span><span class="comment">          their eigenvalues. If the j-th eigenvalue is real, then
</span><span class="comment">*</span><span class="comment">          u(j) = VL(:,j), the j-th column of VL. If the j-th and
</span><span class="comment">*</span><span class="comment">          (j+1)-th eigenvalues form a complex conjugate pair, then
</span><span class="comment">*</span><span class="comment">          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
</span><span class="comment">*</span><span class="comment">          Each eigenvector will be scaled so the largest component have
</span><span class="comment">*</span><span class="comment">          abs(real part) + abs(imag. part) = 1.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVL = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVL    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VL. LDVL &gt;= 1, and
</span><span class="comment">*</span><span class="comment">          if JOBVL = 'V', LDVL &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VR      (output) REAL array, dimension (LDVR,N)
</span><span class="comment">*</span><span class="comment">          If JOBVR = 'V', the right eigenvectors v(j) are stored one
</span><span class="comment">*</span><span class="comment">          after another in the columns of VR, in the same order as
</span><span class="comment">*</span><span class="comment">          their eigenvalues. If the j-th eigenvalue is real, then
</span><span class="comment">*</span><span class="comment">          v(j) = VR(:,j), the j-th column of VR. If the j-th and
</span><span class="comment">*</span><span class="comment">          (j+1)-th eigenvalues form a complex conjugate pair, then
</span><span class="comment">*</span><span class="comment">          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
</span><span class="comment">*</span><span class="comment">          Each eigenvector will be scaled so the largest component have
</span><span class="comment">*</span><span class="comment">          abs(real part) + abs(imag. part) = 1.
</span><span class="comment">*</span><span class="comment">          Not referenced if JOBVR = 'N'.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVR    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the matrix VR. LDVR &gt;= 1, and
</span><span class="comment">*</span><span class="comment">          if JOBVR = 'V', LDVR &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ILO     (output) INTEGER
</span><span class="comment">*</span><span class="comment">  IHI     (output) INTEGER
</span><span class="comment">*</span><span class="comment">          ILO and IHI are integer values such that on exit
</span><span class="comment">*</span><span class="comment">          A(i,j) = 0 and B(i,j) = 0 if i &gt; j and
</span><span class="comment">*</span><span class="comment">          j = 1,...,ILO-1 or i = IHI+1,...,N.
</span><span class="comment">*</span><span class="comment">          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LSCALE  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          Details of the permutations and scaling factors applied
</span><span class="comment">*</span><span class="comment">          to the left side of A and B.  If PL(j) is the index of the
</span><span class="comment">*</span><span class="comment">          row interchanged with row j, and DL(j) is the scaling
</span><span class="comment">*</span><span class="comment">          factor applied to row j, then
</span><span class="comment">*</span><span class="comment">            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
</span><span class="comment">*</span><span class="comment">                      = DL(j)  for j = ILO,...,IHI
</span><span class="comment">*</span><span class="comment">                      = PL(j)  for j = IHI+1,...,N.
</span><span class="comment">*</span><span class="comment">          The order in which the interchanges are made is N to IHI+1,
</span><span class="comment">*</span><span class="comment">          then 1 to ILO-1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RSCALE  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          Details of the permutations and scaling factors applied
</span><span class="comment">*</span><span class="comment">          to the right side of A and B.  If PR(j) is the index of the
</span><span class="comment">*</span><span class="comment">          column interchanged with column j, and DR(j) is the scaling
</span><span class="comment">*</span><span class="comment">          factor applied to column j, then
</span><span class="comment">*</span><span class="comment">            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
</span><span class="comment">*</span><span class="comment">                      = DR(j)  for j = ILO,...,IHI
</span><span class="comment">*</span><span class="comment">                      = PR(j)  for j = IHI+1,...,N
</span><span class="comment">*</span><span class="comment">          The order in which the interchanges are made is N to IHI+1,
</span><span class="comment">*</span><span class="comment">          then 1 to ILO-1.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  ABNRM   (output) REAL
</span><span class="comment">*</span><span class="comment">          The one-norm of the balanced matrix A.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BBNRM   (output) REAL
</span><span class="comment">*</span><span class="comment">          The one-norm of the balanced matrix B.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDE  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E' or 'B', the reciprocal condition numbers of
</span><span class="comment">*</span><span class="comment">          the eigenvalues, stored in consecutive elements of the array.
</span><span class="comment">*</span><span class="comment">          For a complex conjugate pair of eigenvalues two consecutive
</span><span class="comment">*</span><span class="comment">          elements of RCONDE are set to the same value. Thus RCONDE(j),
</span><span class="comment">*</span><span class="comment">          RCONDV(j), and the j-th columns of VL and VR all correspond
</span><span class="comment">*</span><span class="comment">          to the j-th eigenpair.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'N' or 'V', RCONDE is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  RCONDV  (output) REAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          If SENSE = 'V' or 'B', the estimated reciprocal condition
</span><span class="comment">*</span><span class="comment">          numbers of the eigenvectors, stored in consecutive elements
</span><span class="comment">*</span><span class="comment">          of the array. For a complex eigenvector two consecutive
</span><span class="comment">*</span><span class="comment">          elements of RCONDV are set to the same value. If the
</span><span class="comment">*</span><span class="comment">          eigenvalues cannot be reordered to compute RCONDV(j),
</span><span class="comment">*</span><span class="comment">          RCONDV(j) is set to 0; this can only occur when the true
</span><span class="comment">*</span><span class="comment">          value would be very small anyway.
</span><span class="comment">*</span><span class="comment">          If SENSE = 'N' or 'E', RCONDV is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= max(1,2*N).
</span><span class="comment">*</span><span class="comment">          If BALANC = 'S' or 'B', or JOBVL = 'V', or JOBVR = 'V',
</span><span class="comment">*</span><span class="comment">          LWORK &gt;= max(1,6*N).
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E', LWORK &gt;= max(1,10*N).
</span><span class="comment">*</span><span class="comment">          If SENSE = 'V' or 'B', LWORK &gt;= 2*N*N+8*N+16.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.219"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (N+6)
</span><span class="comment">*</span><span class="comment">          If SENSE = 'E', IWORK is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  BWORK   (workspace) LOGICAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          If SENSE = 'N', BWORK is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          = 0:  successful exit
</span><span class="comment">*</span><span class="comment">          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
</span><span class="comment">*</span><span class="comment">          = 1,...,N:
</span><span class="comment">*</span><span class="comment">                The QZ iteration failed.  No eigenvectors have been
</span><span class="comment">*</span><span class="comment">                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
</span><span class="comment">*</span><span class="comment">                should be correct for j=INFO+1,...,N.
</span><span class="comment">*</span><span class="comment">          &gt; N:  =N+1: other than QZ iteration failed in <a name="SHGEQZ.234"></a><a href="shgeqz.f.html#SHGEQZ.1">SHGEQZ</a>.
</span><span class="comment">*</span><span class="comment">                =N+2: error return from <a name="STGEVC.235"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Balancing a matrix pair (A,B) includes, first, permuting rows and
</span><span class="comment">*</span><span class="comment">  columns to isolate eigenvalues, second, applying diagonal similarity
</span><span class="comment">*</span><span class="comment">  transformation to the rows and columns to make the rows and columns
</span><span class="comment">*</span><span class="comment">  as close in norm as possible. The computed reciprocal condition
</span><span class="comment">*</span><span class="comment">  numbers correspond to the balanced matrix. Permuting rows and columns
</span><span class="comment">*</span><span class="comment">  will not change the condition numbers (in exact arithmetic) but
</span><span class="comment">*</span><span class="comment">  diagonal scaling will.  For further explanation of balancing, see
</span><span class="comment">*</span><span class="comment">  section 4.11.1.2 of LAPACK Users' Guide.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An approximate error bound on the chordal distance between the i-th
</span><span class="comment">*</span><span class="comment">  computed generalized eigenvalue w and the corresponding exact
</span><span class="comment">*</span><span class="comment">  eigenvalue lambda is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An approximate error bound for the angle between the i-th computed
</span><span class="comment">*</span><span class="comment">  eigenvector VL(i) or VR(i) is given by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       EPS * norm(ABNRM, BBNRM) / DIF(i).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  For further explanation of the reciprocal condition numbers RCONDE
</span><span class="comment">*</span><span class="comment">  and RCONDV, see section 4.11 of LAPACK User's Guide.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      REAL               ZERO, ONE
      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            ILASCL, ILBSCL, ILV, ILVL, ILVR, LQUERY, NOSCL,
     $                   PAIR, WANTSB, WANTSE, WANTSN, WANTSV
      CHARACTER          CHTEMP
      INTEGER            I, ICOLS, IERR, IJOBVL, IJOBVR, IN, IROWS,
     $                   ITAU, IWRK, IWRK1, J, JC, JR, M, MAXWRK,
     $                   MINWRK, MM
      REAL               ANRM, ANRMTO, BIGNUM, BNRM, BNRMTO, EPS,
     $                   SMLNUM, TEMP
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      LOGICAL            LDUMMA( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           <a name="SGEQRF.283"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>, <a name="SGGBAK.283"></a><a href="sggbak.f.html#SGGBAK.1">SGGBAK</a>, <a name="SGGBAL.283"></a><a href="sggbal.f.html#SGGBAL.1">SGGBAL</a>, <a name="SGGHRD.283"></a><a href="sgghrd.f.html#SGGHRD.1">SGGHRD</a>, <a name="SHGEQZ.283"></a><a href="shgeqz.f.html#SHGEQZ.1">SHGEQZ</a>, <a name="SLABAD.283"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>,
     $                   <a name="SLACPY.284"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>, <a name="SLASCL.284"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>, <a name="SLASET.284"></a><a href="slaset.f.html#SLASET.1">SLASET</a>, <a name="SORGQR.284"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>, <a name="SORMQR.284"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>, <a name="STGEVC.284"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>,
     $                   <a name="STGSNA.285"></a><a href="stgsna.f.html#STGSNA.1">STGSNA</a>, <a name="XERBLA.285"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.288"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      INTEGER            <a name="ILAENV.289"></a><a href="hfy-index.html#ILAENV">ILAENV</a>
      REAL               <a name="SLAMCH.290"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.290"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
      EXTERNAL           <a name="LSAME.291"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, <a name="ILAENV.291"></a><a href="hfy-index.html#ILAENV">ILAENV</a>, <a name="SLAMCH.291"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>, <a name="SLANGE.291"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          ABS, MAX, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.300"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'N'</span> ) ) THEN
         IJOBVL = 1
         ILVL = .FALSE.
      ELSE IF( <a name="LSAME.303"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVL, <span class="string">'V'</span> ) ) THEN
         IJOBVL = 2
         ILVL = .TRUE.
      ELSE
         IJOBVL = -1
         ILVL = .FALSE.
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( <a name="LSAME.311"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'N'</span> ) ) THEN
         IJOBVR = 1
         ILVR = .FALSE.
      ELSE IF( <a name="LSAME.314"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOBVR, <span class="string">'V'</span> ) ) THEN
         IJOBVR = 2
         ILVR = .TRUE.
      ELSE
         IJOBVR = -1
         ILVR = .FALSE.
      END IF
      ILV = ILVL .OR. ILVR
<span class="comment">*</span><span class="comment">
</span>      NOSCL  = <a name="LSAME.323"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'N'</span> ) .OR. <a name="LSAME.323"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'P'</span> )
      WANTSN = <a name="LSAME.324"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'N'</span> )
      WANTSE = <a name="LSAME.325"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'E'</span> )
      WANTSV = <a name="LSAME.326"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'V'</span> )
      WANTSB = <a name="LSAME.327"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( SENSE, <span class="string">'B'</span> )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Test the input arguments
</span><span class="comment">*</span><span class="comment">
</span>      INFO = 0
      LQUERY = ( LWORK.EQ.-1 )
      IF( .NOT.( NOSCL .OR. <a name="LSAME.333"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'S'</span> ) .OR.
     $    <a name="LSAME.334"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( BALANC, <span class="string">'B'</span> ) ) ) THEN
         INFO = -1
      ELSE IF( IJOBVL.LE.0 ) THEN
         INFO = -2
      ELSE IF( IJOBVR.LE.0 ) THEN
         INFO = -3
      ELSE IF( .NOT.( WANTSN .OR. WANTSE .OR. WANTSB .OR. WANTSV ) )
     $          THEN
         INFO = -4
      ELSE IF( N.LT.0 ) THEN
         INFO = -5
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -7
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -9
      ELSE IF( LDVL.LT.1 .OR. ( ILVL .AND. LDVL.LT.N ) ) THEN
         INFO = -14
      ELSE IF( LDVR.LT.1 .OR. ( ILVR .AND. LDVR.LT.N ) ) THEN
         INFO = -16
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute workspace
</span><span class="comment">*</span><span class="comment">      (Note: Comments in the code beginning &quot;Workspace:&quot; describe the
</span><span class="comment">*</span><span class="comment">       minimal amount of workspace needed at that point in the code,
</span><span class="comment">*</span><span class="comment">       as well as the preferred amount for good performance.
</span><span class="comment">*</span><span class="comment">       NB refers to the optimal block size for the immediately
</span><span class="comment">*</span><span class="comment">       following subroutine, as returned by <a name="ILAENV.360"></a><a href="hfy-index.html#ILAENV">ILAENV</a>. The workspace is
</span><span class="comment">*</span><span class="comment">       computed assuming ILO = 1 and IHI = N, the worst case.)
</span><span class="comment">*</span><span class="comment">
</span>      IF( INFO.EQ.0 ) THEN
         IF( N.EQ.0 ) THEN
            MINWRK = 1
            MAXWRK = 1
         ELSE
            IF( NOSCL .AND. .NOT.ILV ) THEN
               MINWRK = 2*N
            ELSE
               MINWRK = 6*N
            END IF
            IF( WANTSE ) THEN
               MINWRK = 10*N
            ELSE IF( WANTSV .OR. WANTSB ) THEN
               MINWRK = 2*N*( N + 4 ) + 16
            END IF
            MAXWRK = MINWRK
            MAXWRK = MAX( MAXWRK,
     $                    N + N*<a name="ILAENV.380"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SGEQRF.380"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 ) )
            MAXWRK = MAX( MAXWRK,
     $                    N + N*<a name="ILAENV.382"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORMQR.382"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 ) )
            IF( ILVL ) THEN
               MAXWRK = MAX( MAXWRK, N +
     $                       N*<a name="ILAENV.385"></a><a href="hfy-index.html#ILAENV">ILAENV</a>( 1, <span class="string">'<a name="SORGQR.385"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>'</span>, <span class="string">' '</span>, N, 1, N, 0 ) )
            END IF
         END IF
         WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN
            INFO = -26
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.396"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="SGGEVX.396"></a><a href="sggevx.f.html#SGGEVX.1">SGGEVX</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="SLAMCH.410"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="SLAMCH.411"></a><a href="slamch.f.html#SLAMCH.1">SLAMCH</a>( <span class="string">'S'</span> )
      BIGNUM = ONE / SMLNUM
      CALL <a name="SLABAD.413"></a><a href="slabad.f.html#SLABAD.1">SLABAD</a>( SMLNUM, BIGNUM )
      SMLNUM = SQRT( SMLNUM ) / EPS
      BIGNUM = ONE / SMLNUM
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale A if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      ANRM = <a name="SLANGE.419"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, N, N, A, LDA, WORK )
      ILASCL = .FALSE.
      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN
         ANRMTO = SMLNUM
         ILASCL = .TRUE.
      ELSE IF( ANRM.GT.BIGNUM ) THEN
         ANRMTO = BIGNUM
         ILASCL = .TRUE.
      END IF
      IF( ILASCL )
     $   CALL <a name="SLASCL.429"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRM, ANRMTO, N, N, A, LDA, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Scale B if max element outside range [SMLNUM,BIGNUM]
</span><span class="comment">*</span><span class="comment">
</span>      BNRM = <a name="SLANGE.433"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'M'</span>, N, N, B, LDB, WORK )
      ILBSCL = .FALSE.
      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN
         BNRMTO = SMLNUM
         ILBSCL = .TRUE.
      ELSE IF( BNRM.GT.BIGNUM ) THEN
         BNRMTO = BIGNUM
         ILBSCL = .TRUE.
      END IF
      IF( ILBSCL )
     $   CALL <a name="SLASCL.443"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRM, BNRMTO, N, N, B, LDB, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Permute and/or balance the matrix pair (A,B)
</span><span class="comment">*</span><span class="comment">     (Workspace: need 6*N if BALANC = 'S' or 'B', 1 otherwise)
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="SGGBAL.448"></a><a href="sggbal.f.html#SGGBAL.1">SGGBAL</a>( BALANC, N, A, LDA, B, LDB, ILO, IHI, LSCALE, RSCALE,
     $             WORK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute ABNRM and BBNRM
</span><span class="comment">*</span><span class="comment">
</span>      ABNRM = <a name="SLANGE.453"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'1'</span>, N, N, A, LDA, WORK( 1 ) )
      IF( ILASCL ) THEN
         WORK( 1 ) = ABNRM
         CALL <a name="SLASCL.456"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRMTO, ANRM, 1, 1, WORK( 1 ), 1,
     $                IERR )
         ABNRM = WORK( 1 )
      END IF
<span class="comment">*</span><span class="comment">
</span>      BBNRM = <a name="SLANGE.461"></a><a href="slange.f.html#SLANGE.1">SLANGE</a>( <span class="string">'1'</span>, N, N, B, LDB, WORK( 1 ) )
      IF( ILBSCL ) THEN
         WORK( 1 ) = BBNRM
         CALL <a name="SLASCL.464"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRMTO, BNRM, 1, 1, WORK( 1 ), 1,
     $                IERR )
         BBNRM = WORK( 1 )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce B to triangular form (QR decomposition of B)
</span><span class="comment">*</span><span class="comment">     (Workspace: need N, prefer N*NB )
</span><span class="comment">*</span><span class="comment">
</span>      IROWS = IHI + 1 - ILO
      IF( ILV .OR. .NOT.WANTSN ) THEN
         ICOLS = N + 1 - ILO
      ELSE
         ICOLS = IROWS
      END IF
      ITAU = 1
      IWRK = ITAU + IROWS
      CALL <a name="SGEQRF.480"></a><a href="sgeqrf.f.html#SGEQRF.1">SGEQRF</a>( IROWS, ICOLS, B( ILO, ILO ), LDB, WORK( ITAU ),
     $             WORK( IWRK ), LWORK+1-IWRK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Apply the orthogonal transformation to A
</span><span class="comment">*</span><span class="comment">     (Workspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      CALL <a name="SORMQR.486"></a><a href="sormqr.f.html#SORMQR.1">SORMQR</a>( <span class="string">'L'</span>, <span class="string">'T'</span>, IROWS, ICOLS, IROWS, B( ILO, ILO ), LDB,
     $             WORK( ITAU ), A( ILO, ILO ), LDA, WORK( IWRK ),
     $             LWORK+1-IWRK, IERR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Initialize VL and/or VR
</span><span class="comment">*</span><span class="comment">     (Workspace: need N, prefer N*NB)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILVL ) THEN
         CALL <a name="SLASET.494"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'Full'</span>, N, N, ZERO, ONE, VL, LDVL )
         IF( IROWS.GT.1 ) THEN
            CALL <a name="SLACPY.496"></a><a href="slacpy.f.html#SLACPY.1">SLACPY</a>( <span class="string">'L'</span>, IROWS-1, IROWS-1, B( ILO+1, ILO ), LDB,
     $                   VL( ILO+1, ILO ), LDVL )
         END IF
         CALL <a name="SORGQR.499"></a><a href="sorgqr.f.html#SORGQR.1">SORGQR</a>( IROWS, IROWS, IROWS, VL( ILO, ILO ), LDVL,
     $                WORK( ITAU ), WORK( IWRK ), LWORK+1-IWRK, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILVR )
     $   CALL <a name="SLASET.504"></a><a href="slaset.f.html#SLASET.1">SLASET</a>( <span class="string">'Full'</span>, N, N, ZERO, ONE, VR, LDVR )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Reduce to generalized Hessenberg form
</span><span class="comment">*</span><span class="comment">     (Workspace: none needed)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILV .OR. .NOT.WANTSN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Eigenvectors requested -- work on whole matrix.
</span><span class="comment">*</span><span class="comment">
</span>         CALL <a name="SGGHRD.513"></a><a href="sgghrd.f.html#SGGHRD.1">SGGHRD</a>( JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB, VL,
     $                LDVL, VR, LDVR, IERR )
      ELSE
         CALL <a name="SGGHRD.516"></a><a href="sgghrd.f.html#SGGHRD.1">SGGHRD</a>( <span class="string">'N'</span>, <span class="string">'N'</span>, IROWS, 1, IROWS, A( ILO, ILO ), LDA,
     $                B( ILO, ILO ), LDB, VL, LDVL, VR, LDVR, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Perform QZ algorithm (Compute eigenvalues, and optionally, the
</span><span class="comment">*</span><span class="comment">     Schur forms and Schur vectors)
</span><span class="comment">*</span><span class="comment">     (Workspace: need N)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILV .OR. .NOT.WANTSN ) THEN
         CHTEMP = <span class="string">'S'</span>
      ELSE
         CHTEMP = <span class="string">'E'</span>
      END IF
<span class="comment">*</span><span class="comment">
</span>      CALL <a name="SHGEQZ.530"></a><a href="shgeqz.f.html#SHGEQZ.1">SHGEQZ</a>( CHTEMP, JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB,
     $             ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, WORK,
     $             LWORK, IERR )
      IF( IERR.NE.0 ) THEN
         IF( IERR.GT.0 .AND. IERR.LE.N ) THEN
            INFO = IERR
         ELSE IF( IERR.GT.N .AND. IERR.LE.2*N ) THEN
            INFO = IERR - N
         ELSE
            INFO = N + 1
         END IF
         GO TO 130
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Compute Eigenvectors and estimate condition numbers if desired
</span><span class="comment">*</span><span class="comment">     (Workspace: <a name="STGEVC.545"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>: need 6*N
</span><span class="comment">*</span><span class="comment">                 <a name="STGSNA.546"></a><a href="stgsna.f.html#STGSNA.1">STGSNA</a>: need 2*N*(N+2)+16 if SENSE = 'V' or 'B',
</span><span class="comment">*</span><span class="comment">                         need N otherwise )
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILV .OR. .NOT.WANTSN ) THEN
         IF( ILV ) THEN
            IF( ILVL ) THEN
               IF( ILVR ) THEN
                  CHTEMP = <span class="string">'B'</span>
               ELSE
                  CHTEMP = <span class="string">'L'</span>
               END IF
            ELSE
               CHTEMP = <span class="string">'R'</span>
            END IF
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="STGEVC.561"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>( CHTEMP, <span class="string">'B'</span>, LDUMMA, N, A, LDA, B, LDB, VL,
     $                   LDVL, VR, LDVR, N, IN, WORK, IERR )
            IF( IERR.NE.0 ) THEN
               INFO = N + 2
               GO TO 130
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         IF( .NOT.WANTSN ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           compute eigenvectors (<a name="STGEVC.571"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>) and estimate condition
</span><span class="comment">*</span><span class="comment">           numbers (<a name="STGSNA.572"></a><a href="stgsna.f.html#STGSNA.1">STGSNA</a>). Note that the definition of the condition
</span><span class="comment">*</span><span class="comment">           number is not invariant under transformation (u,v) to
</span><span class="comment">*</span><span class="comment">           (Q*u, Z*v), where (u,v) are eigenvectors of the generalized
</span><span class="comment">*</span><span class="comment">           Schur form (S,T), Q and Z are orthogonal matrices. In order
</span><span class="comment">*</span><span class="comment">           to avoid using extra 2*N*N workspace, we have to recalculate
</span><span class="comment">*</span><span class="comment">           eigenvectors and estimate one condition numbers at a time.
</span><span class="comment">*</span><span class="comment">
</span>            PAIR = .FALSE.
            DO 20 I = 1, N
<span class="comment">*</span><span class="comment">
</span>               IF( PAIR ) THEN
                  PAIR = .FALSE.
                  GO TO 20
               END IF
               MM = 1
               IF( I.LT.N ) THEN
                  IF( A( I+1, I ).NE.ZERO ) THEN
                     PAIR = .TRUE.
                     MM = 2
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               DO 10 J = 1, N
                  BWORK( J ) = .FALSE.
   10          CONTINUE
               IF( MM.EQ.1 ) THEN
                  BWORK( I ) = .TRUE.
               ELSE IF( MM.EQ.2 ) THEN
                  BWORK( I ) = .TRUE.
                  BWORK( I+1 ) = .TRUE.
               END IF
<span class="comment">*</span><span class="comment">
</span>               IWRK = MM*N + 1
               IWRK1 = IWRK + MM*N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Compute a pair of left and right eigenvectors.
</span><span class="comment">*</span><span class="comment">              (compute workspace: need up to 4*N + 6*N)
</span><span class="comment">*</span><span class="comment">
</span>               IF( WANTSE .OR. WANTSB ) THEN
                  CALL <a name="STGEVC.611"></a><a href="stgevc.f.html#STGEVC.1">STGEVC</a>( <span class="string">'B'</span>, <span class="string">'S'</span>, BWORK, N, A, LDA, B, LDB,
     $                         WORK( 1 ), N, WORK( IWRK ), N, MM, M,
     $                         WORK( IWRK1 ), IERR )
                  IF( IERR.NE.0 ) THEN
                     INFO = N + 2
                     GO TO 130
                  END IF
               END IF
<span class="comment">*</span><span class="comment">
</span>               CALL <a name="STGSNA.620"></a><a href="stgsna.f.html#STGSNA.1">STGSNA</a>( SENSE, <span class="string">'S'</span>, BWORK, N, A, LDA, B, LDB,
     $                      WORK( 1 ), N, WORK( IWRK ), N, RCONDE( I ),
     $                      RCONDV( I ), MM, M, WORK( IWRK1 ),
     $                      LWORK-IWRK1+1, IWORK, IERR )
<span class="comment">*</span><span class="comment">
</span>   20       CONTINUE
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo balancing on VL and VR and normalization
</span><span class="comment">*</span><span class="comment">     (Workspace: none needed)
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILVL ) THEN
         CALL <a name="SGGBAK.633"></a><a href="sggbak.f.html#SGGBAK.1">SGGBAK</a>( BALANC, <span class="string">'L'</span>, N, ILO, IHI, LSCALE, RSCALE, N, VL,
     $                LDVL, IERR )
<span class="comment">*</span><span class="comment">
</span>         DO 70 JC = 1, N
            IF( ALPHAI( JC ).LT.ZERO )
     $         GO TO 70
            TEMP = ZERO
            IF( ALPHAI( JC ).EQ.ZERO ) THEN
               DO 30 JR = 1, N
                  TEMP = MAX( TEMP, ABS( VL( JR, JC ) ) )
   30          CONTINUE
            ELSE
               DO 40 JR = 1, N
                  TEMP = MAX( TEMP, ABS( VL( JR, JC ) )+
     $                   ABS( VL( JR, JC+1 ) ) )
   40          CONTINUE
            END IF
            IF( TEMP.LT.SMLNUM )
     $         GO TO 70
            TEMP = ONE / TEMP
            IF( ALPHAI( JC ).EQ.ZERO ) THEN
               DO 50 JR = 1, N
                  VL( JR, JC ) = VL( JR, JC )*TEMP
   50          CONTINUE
            ELSE
               DO 60 JR = 1, N
                  VL( JR, JC ) = VL( JR, JC )*TEMP
                  VL( JR, JC+1 ) = VL( JR, JC+1 )*TEMP
   60          CONTINUE
            END IF
   70    CONTINUE
      END IF
      IF( ILVR ) THEN
         CALL <a name="SGGBAK.666"></a><a href="sggbak.f.html#SGGBAK.1">SGGBAK</a>( BALANC, <span class="string">'R'</span>, N, ILO, IHI, LSCALE, RSCALE, N, VR,
     $                LDVR, IERR )
         DO 120 JC = 1, N
            IF( ALPHAI( JC ).LT.ZERO )
     $         GO TO 120
            TEMP = ZERO
            IF( ALPHAI( JC ).EQ.ZERO ) THEN
               DO 80 JR = 1, N
                  TEMP = MAX( TEMP, ABS( VR( JR, JC ) ) )
   80          CONTINUE
            ELSE
               DO 90 JR = 1, N
                  TEMP = MAX( TEMP, ABS( VR( JR, JC ) )+
     $                   ABS( VR( JR, JC+1 ) ) )
   90          CONTINUE
            END IF
            IF( TEMP.LT.SMLNUM )
     $         GO TO 120
            TEMP = ONE / TEMP
            IF( ALPHAI( JC ).EQ.ZERO ) THEN
               DO 100 JR = 1, N
                  VR( JR, JC ) = VR( JR, JC )*TEMP
  100          CONTINUE
            ELSE
               DO 110 JR = 1, N
                  VR( JR, JC ) = VR( JR, JC )*TEMP
                  VR( JR, JC+1 ) = VR( JR, JC+1 )*TEMP
  110          CONTINUE
            END IF
  120    CONTINUE
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Undo scaling if necessary
</span><span class="comment">*</span><span class="comment">
</span>      IF( ILASCL ) THEN
         CALL <a name="SLASCL.701"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRMTO, ANRM, N, 1, ALPHAR, N, IERR )
         CALL <a name="SLASCL.702"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, ANRMTO, ANRM, N, 1, ALPHAI, N, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( ILBSCL ) THEN
         CALL <a name="SLASCL.706"></a><a href="slascl.f.html#SLASCL.1">SLASCL</a>( <span class="string">'G'</span>, 0, 0, BNRMTO, BNRM, N, 1, BETA, N, IERR )
      END IF
<span class="comment">*</span><span class="comment">
</span>  130 CONTINUE
      WORK( 1 ) = MAXWRK
<span class="comment">*</span><span class="comment">
</span>      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="SGGEVX.714"></a><a href="sggevx.f.html#SGGEVX.1">SGGEVX</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
