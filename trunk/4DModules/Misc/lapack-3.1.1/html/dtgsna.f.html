<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>dtgsna.f</title>
 <meta name="generator" content="emacs 21.3.1; htmlfontify 0.20">
<style type="text/css"><!-- 
body { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default   { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.default a { background: rgb(255, 255, 255);  color: rgb(0, 0, 0);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.string   { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.string a { color: rgb(188, 143, 143);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
span.comment   { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: none; }
span.comment a { color: rgb(178, 34, 34);  background: rgb(255, 255, 255);  font-style: normal;  font-weight: 500;  font-stretch: normal;  font-family: adobe-courier;  font-size: 11pt;  text-decoration: underline; }
 --></style>

 </head>
  <body>

<pre>
      SUBROUTINE <a name="DTGSNA.1"></a><a href="dtgsna.f.html#DTGSNA.1">DTGSNA</a>( JOB, HOWMNY, SELECT, N, A, LDA, B, LDB, VL,
     $                   LDVL, VR, LDVR, S, DIF, MM, M, WORK, LWORK,
     $                   IWORK, INFO )
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  -- LAPACK routine (version 3.1) --
</span><span class="comment">*</span><span class="comment">     Univ. of Tennessee, Univ. of California Berkeley and NAG Ltd..
</span><span class="comment">*</span><span class="comment">     November 2006
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Scalar Arguments ..
</span>      CHARACTER          HOWMNY, JOB
      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, M, MM, N
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Array Arguments ..
</span>      LOGICAL            SELECT( * )
      INTEGER            IWORK( * )
      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), DIF( * ), S( * ),
     $                   VL( LDVL, * ), VR( LDVR, * ), WORK( * )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Purpose
</span><span class="comment">*</span><span class="comment">  =======
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  <a name="DTGSNA.23"></a><a href="dtgsna.f.html#DTGSNA.1">DTGSNA</a> estimates reciprocal condition numbers for specified
</span><span class="comment">*</span><span class="comment">  eigenvalues and/or eigenvectors of a matrix pair (A, B) in
</span><span class="comment">*</span><span class="comment">  generalized real Schur canonical form (or of any matrix pair
</span><span class="comment">*</span><span class="comment">  (Q*A*Z', Q*B*Z') with orthogonal matrices Q and Z, where
</span><span class="comment">*</span><span class="comment">  Z' denotes the transpose of Z.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  (A, B) must be in generalized real Schur form (as returned by <a name="DGGES.29"></a><a href="dgges.f.html#DGGES.1">DGGES</a>),
</span><span class="comment">*</span><span class="comment">  i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
</span><span class="comment">*</span><span class="comment">  blocks. B is upper triangular.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Arguments
</span><span class="comment">*</span><span class="comment">  =========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  JOB     (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          Specifies whether condition numbers are required for
</span><span class="comment">*</span><span class="comment">          eigenvalues (S) or eigenvectors (DIF):
</span><span class="comment">*</span><span class="comment">          = 'E': for eigenvalues only (S);
</span><span class="comment">*</span><span class="comment">          = 'V': for eigenvectors only (DIF);
</span><span class="comment">*</span><span class="comment">          = 'B': for both eigenvalues and eigenvectors (S and DIF).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  HOWMNY  (input) CHARACTER*1
</span><span class="comment">*</span><span class="comment">          = 'A': compute condition numbers for all eigenpairs;
</span><span class="comment">*</span><span class="comment">          = 'S': compute condition numbers for selected eigenpairs
</span><span class="comment">*</span><span class="comment">                 specified by the array SELECT.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  SELECT  (input) LOGICAL array, dimension (N)
</span><span class="comment">*</span><span class="comment">          If HOWMNY = 'S', SELECT specifies the eigenpairs for which
</span><span class="comment">*</span><span class="comment">          condition numbers are required. To select condition numbers
</span><span class="comment">*</span><span class="comment">          for the eigenpair corresponding to a real eigenvalue w(j),
</span><span class="comment">*</span><span class="comment">          SELECT(j) must be set to .TRUE.. To select condition numbers
</span><span class="comment">*</span><span class="comment">          corresponding to a complex conjugate pair of eigenvalues w(j)
</span><span class="comment">*</span><span class="comment">          and w(j+1), either SELECT(j) or SELECT(j+1) or both, must be
</span><span class="comment">*</span><span class="comment">          set to .TRUE..
</span><span class="comment">*</span><span class="comment">          If HOWMNY = 'A', SELECT is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  N       (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The order of the square matrix pair (A, B). N &gt;= 0.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  A       (input) DOUBLE PRECISION array, dimension (LDA,N)
</span><span class="comment">*</span><span class="comment">          The upper quasi-triangular matrix A in the pair (A,B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDA     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array A. LDA &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  B       (input) DOUBLE PRECISION array, dimension (LDB,N)
</span><span class="comment">*</span><span class="comment">          The upper triangular matrix B in the pair (A,B).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDB     (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array B. LDB &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VL      (input) DOUBLE PRECISION array, dimension (LDVL,M)
</span><span class="comment">*</span><span class="comment">          If JOB = 'E' or 'B', VL must contain left eigenvectors of
</span><span class="comment">*</span><span class="comment">          (A, B), corresponding to the eigenpairs specified by HOWMNY
</span><span class="comment">*</span><span class="comment">          and SELECT. The eigenvectors must be stored in consecutive
</span><span class="comment">*</span><span class="comment">          columns of VL, as returned by <a name="DTGEVC.78"></a><a href="dtgevc.f.html#DTGEVC.1">DTGEVC</a>.
</span><span class="comment">*</span><span class="comment">          If JOB = 'V', VL is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVL    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VL. LDVL &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If JOB = 'E' or 'B', LDVL &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  VR      (input) DOUBLE PRECISION array, dimension (LDVR,M)
</span><span class="comment">*</span><span class="comment">          If JOB = 'E' or 'B', VR must contain right eigenvectors of
</span><span class="comment">*</span><span class="comment">          (A, B), corresponding to the eigenpairs specified by HOWMNY
</span><span class="comment">*</span><span class="comment">          and SELECT. The eigenvectors must be stored in consecutive
</span><span class="comment">*</span><span class="comment">          columns ov VR, as returned by <a name="DTGEVC.89"></a><a href="dtgevc.f.html#DTGEVC.1">DTGEVC</a>.
</span><span class="comment">*</span><span class="comment">          If JOB = 'V', VR is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LDVR    (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The leading dimension of the array VR. LDVR &gt;= 1.
</span><span class="comment">*</span><span class="comment">          If JOB = 'E' or 'B', LDVR &gt;= N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  S       (output) DOUBLE PRECISION array, dimension (MM)
</span><span class="comment">*</span><span class="comment">          If JOB = 'E' or 'B', the reciprocal condition numbers of the
</span><span class="comment">*</span><span class="comment">          selected eigenvalues, stored in consecutive elements of the
</span><span class="comment">*</span><span class="comment">          array. For a complex conjugate pair of eigenvalues two
</span><span class="comment">*</span><span class="comment">          consecutive elements of S are set to the same value. Thus
</span><span class="comment">*</span><span class="comment">          S(j), DIF(j), and the j-th columns of VL and VR all
</span><span class="comment">*</span><span class="comment">          correspond to the same eigenpair (but not in general the
</span><span class="comment">*</span><span class="comment">          j-th eigenpair, unless all eigenpairs are selected).
</span><span class="comment">*</span><span class="comment">          If JOB = 'V', S is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  DIF     (output) DOUBLE PRECISION array, dimension (MM)
</span><span class="comment">*</span><span class="comment">          If JOB = 'V' or 'B', the estimated reciprocal condition
</span><span class="comment">*</span><span class="comment">          numbers of the selected eigenvectors, stored in consecutive
</span><span class="comment">*</span><span class="comment">          elements of the array. For a complex eigenvector two
</span><span class="comment">*</span><span class="comment">          consecutive elements of DIF are set to the same value. If
</span><span class="comment">*</span><span class="comment">          the eigenvalues cannot be reordered to compute DIF(j), DIF(j)
</span><span class="comment">*</span><span class="comment">          is set to 0; this can only occur when the true value would be
</span><span class="comment">*</span><span class="comment">          very small anyway.
</span><span class="comment">*</span><span class="comment">          If JOB = 'E', DIF is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  MM      (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of elements in the arrays S and DIF. MM &gt;= M.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  M       (output) INTEGER
</span><span class="comment">*</span><span class="comment">          The number of elements of the arrays S and DIF used to store
</span><span class="comment">*</span><span class="comment">          the specified condition numbers; for each selected real
</span><span class="comment">*</span><span class="comment">          eigenvalue one element is used, and for each selected complex
</span><span class="comment">*</span><span class="comment">          conjugate pair of eigenvalues, two elements are used.
</span><span class="comment">*</span><span class="comment">          If HOWMNY = 'A', M is set to N.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
</span><span class="comment">*</span><span class="comment">          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  LWORK   (input) INTEGER
</span><span class="comment">*</span><span class="comment">          The dimension of the array WORK. LWORK &gt;= max(1,N).
</span><span class="comment">*</span><span class="comment">          If JOB = 'V' or 'B' LWORK &gt;= 2*N*(N+2)+16.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">          If LWORK = -1, then a workspace query is assumed; the routine
</span><span class="comment">*</span><span class="comment">          only calculates the optimal size of the WORK array, returns
</span><span class="comment">*</span><span class="comment">          this value as the first entry of the WORK array, and no error
</span><span class="comment">*</span><span class="comment">          message related to LWORK is issued by <a name="XERBLA.136"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  IWORK   (workspace) INTEGER array, dimension (N + 6)
</span><span class="comment">*</span><span class="comment">          If JOB = 'E', IWORK is not referenced.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  INFO    (output) INTEGER
</span><span class="comment">*</span><span class="comment">          =0: Successful exit
</span><span class="comment">*</span><span class="comment">          &lt;0: If INFO = -i, the i-th argument had an illegal value
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Further Details
</span><span class="comment">*</span><span class="comment">  ===============
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The reciprocal of the condition number of a generalized eigenvalue
</span><span class="comment">*</span><span class="comment">  w = (a, b) is defined as
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       S(w) = (|u'Av|**2 + |u'Bv|**2)**(1/2) / (norm(u)*norm(v))
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where u and v are the left and right eigenvectors of (A, B)
</span><span class="comment">*</span><span class="comment">  corresponding to w; |z| denotes the absolute value of the complex
</span><span class="comment">*</span><span class="comment">  number, and norm(u) denotes the 2-norm of the vector u.
</span><span class="comment">*</span><span class="comment">  The pair (a, b) corresponds to an eigenvalue w = a/b (= u'Av/u'Bv)
</span><span class="comment">*</span><span class="comment">  of the matrix pair (A, B). If both a and b equal zero, then (A B) is
</span><span class="comment">*</span><span class="comment">  singular and S(I) = -1 is returned.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An approximate error bound on the chordal distance between the i-th
</span><span class="comment">*</span><span class="comment">  computed generalized eigenvalue w and the corresponding exact
</span><span class="comment">*</span><span class="comment">  eigenvalue lambda is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">       chord(w, lambda) &lt;= EPS * norm(A, B) / S(I)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  where EPS is the machine precision.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  The reciprocal of the condition number DIF(i) of right eigenvector u
</span><span class="comment">*</span><span class="comment">  and left eigenvector v corresponding to the generalized eigenvalue w
</span><span class="comment">*</span><span class="comment">  is defined as follows:
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  a) If the i-th eigenvalue w = (a,b) is real
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Suppose U and V are orthogonal transformations such that
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                U'*(A, B)*V  = (S, T) = ( a   *  ) ( b  *  )  1
</span><span class="comment">*</span><span class="comment">                                        ( 0  S22 ),( 0 T22 )  n-1
</span><span class="comment">*</span><span class="comment">                                          1  n-1     1 n-1
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Then the reciprocal condition number DIF(i) is
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                Difl((a, b), (S22, T22)) = sigma-min( Zl ),
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     where sigma-min(Zl) denotes the smallest singular value of the
</span><span class="comment">*</span><span class="comment">     2(n-1)-by-2(n-1) matrix
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         Zl = [ kron(a, In-1)  -kron(1, S22) ]
</span><span class="comment">*</span><span class="comment">              [ kron(b, In-1)  -kron(1, T22) ] .
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Here In-1 is the identity matrix of size n-1. kron(X, Y) is the
</span><span class="comment">*</span><span class="comment">     Kronecker product between the matrices X and Y.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Note that if the default method for computing DIF(i) is wanted
</span><span class="comment">*</span><span class="comment">     (see <a name="DLATDF.195"></a><a href="dlatdf.f.html#DLATDF.1">DLATDF</a>), then the parameter DIFDRI (see below) should be
</span><span class="comment">*</span><span class="comment">     changed from 3 to 4 (routine <a name="DLATDF.196"></a><a href="dlatdf.f.html#DLATDF.1">DLATDF</a>(IJOB = 2 will be used)).
</span><span class="comment">*</span><span class="comment">     See <a name="DTGSYL.197"></a><a href="dtgsyl.f.html#DTGSYL.1">DTGSYL</a> for more details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  b) If the i-th and (i+1)-th eigenvalues are complex conjugate pair,
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Suppose U and V are orthogonal transformations such that
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">                U'*(A, B)*V = (S, T) = ( S11  *   ) ( T11  *  )  2
</span><span class="comment">*</span><span class="comment">                                       ( 0    S22 ),( 0    T22) n-2
</span><span class="comment">*</span><span class="comment">                                         2    n-2     2    n-2
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     and (S11, T11) corresponds to the complex conjugate eigenvalue
</span><span class="comment">*</span><span class="comment">     pair (w, conjg(w)). There exist unitary matrices U1 and V1 such
</span><span class="comment">*</span><span class="comment">     that
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         U1'*S11*V1 = ( s11 s12 )   and U1'*T11*V1 = ( t11 t12 )
</span><span class="comment">*</span><span class="comment">                      (  0  s22 )                    (  0  t22 )
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     where the generalized eigenvalues w = s11/t11 and
</span><span class="comment">*</span><span class="comment">     conjg(w) = s22/t22.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Then the reciprocal condition number DIF(i) is bounded by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">         min( d1, max( 1, |real(s11)/real(s22)| )*d2 )
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     where, d1 = Difl((s11, t11), (s22, t22)) = sigma-min(Z1), where
</span><span class="comment">*</span><span class="comment">     Z1 is the complex 2-by-2 matrix
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Z1 =  [ s11  -s22 ]
</span><span class="comment">*</span><span class="comment">                    [ t11  -t22 ],
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     This is done by computing (using real arithmetic) the
</span><span class="comment">*</span><span class="comment">     roots of the characteristical polynomial det(Z1' * Z1 - lambda I),
</span><span class="comment">*</span><span class="comment">     where Z1' denotes the conjugate transpose of Z1 and det(X) denotes
</span><span class="comment">*</span><span class="comment">     the determinant of X.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     and d2 is an upper bound on Difl((S11, T11), (S22, T22)), i.e. an
</span><span class="comment">*</span><span class="comment">     upper bound on sigma-min(Z2), where Z2 is (2n-2)-by-(2n-2)
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Z2 = [ kron(S11', In-2)  -kron(I2, S22) ]
</span><span class="comment">*</span><span class="comment">                   [ kron(T11', In-2)  -kron(I2, T22) ]
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Note that if the default method for computing DIF is wanted (see
</span><span class="comment">*</span><span class="comment">     <a name="DLATDF.239"></a><a href="dlatdf.f.html#DLATDF.1">DLATDF</a>), then the parameter DIFDRI (see below) should be changed
</span><span class="comment">*</span><span class="comment">     from 3 to 4 (routine <a name="DLATDF.240"></a><a href="dlatdf.f.html#DLATDF.1">DLATDF</a>(IJOB = 2 will be used)). See <a name="DTGSYL.240"></a><a href="dtgsyl.f.html#DTGSYL.1">DTGSYL</a>
</span><span class="comment">*</span><span class="comment">     for more details.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  For each eigenvalue/vector specified by SELECT, DIF stores a
</span><span class="comment">*</span><span class="comment">  Frobenius norm-based estimate of Difl.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  An approximate error bound for the i-th computed eigenvector VL(i) or
</span><span class="comment">*</span><span class="comment">  VR(i) is given by
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">             EPS * norm(A, B) / DIF(i).
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  See ref. [2-3] for more details and further references.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  Based on contributions by
</span><span class="comment">*</span><span class="comment">     Bo Kagstrom and Peter Poromaa, Department of Computing Science,
</span><span class="comment">*</span><span class="comment">     Umea University, S-901 87 Umea, Sweden.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  References
</span><span class="comment">*</span><span class="comment">  ==========
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [1] B. Kagstrom; A Direct Method for Reordering Eigenvalues in the
</span><span class="comment">*</span><span class="comment">      Generalized Real Schur Form of a Regular Matrix Pair (A, B), in
</span><span class="comment">*</span><span class="comment">      M.S. Moonen et al (eds), Linear Algebra for Large Scale and
</span><span class="comment">*</span><span class="comment">      Real-Time Applications, Kluwer Academic Publ. 1993, pp 195-218.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [2] B. Kagstrom and P. Poromaa; Computing Eigenspaces with Specified
</span><span class="comment">*</span><span class="comment">      Eigenvalues of a Regular Matrix Pair (A, B) and Condition
</span><span class="comment">*</span><span class="comment">      Estimation: Theory, Algorithms and Software,
</span><span class="comment">*</span><span class="comment">      Report UMINF - 94.04, Department of Computing Science, Umea
</span><span class="comment">*</span><span class="comment">      University, S-901 87 Umea, Sweden, 1994. Also as LAPACK Working
</span><span class="comment">*</span><span class="comment">      Note 87. To appear in Numerical Algorithms, 1996.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  [3] B. Kagstrom and P. Poromaa, LAPACK-Style Algorithms and Software
</span><span class="comment">*</span><span class="comment">      for Solving the Generalized Sylvester Equation and Estimating the
</span><span class="comment">*</span><span class="comment">      Separation between Regular Matrix Pairs, Report UMINF - 93.23,
</span><span class="comment">*</span><span class="comment">      Department of Computing Science, Umea University, S-901 87 Umea,
</span><span class="comment">*</span><span class="comment">      Sweden, December 1993, Revised April 1994, Also as LAPACK Working
</span><span class="comment">*</span><span class="comment">      Note 75.  To appear in ACM Trans. on Math. Software, Vol 22,
</span><span class="comment">*</span><span class="comment">      No 1, 1996.
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">  =====================================================================
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     .. Parameters ..
</span>      INTEGER            DIFDRI
      PARAMETER          ( DIFDRI = 3 )
      DOUBLE PRECISION   ZERO, ONE, TWO, FOUR
      PARAMETER          ( ZERO = 0.0D+0, ONE = 1.0D+0, TWO = 2.0D+0,
     $                   FOUR = 4.0D+0 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Scalars ..
</span>      LOGICAL            LQUERY, PAIR, SOMCON, WANTBH, WANTDF, WANTS
      INTEGER            I, IERR, IFST, ILST, IZ, K, KS, LWMIN, N1, N2
      DOUBLE PRECISION   ALPHAI, ALPHAR, ALPRQT, BETA, C1, C2, COND,
     $                   EPS, LNRM, RNRM, ROOT1, ROOT2, SCALE, SMLNUM,
     $                   TMPII, TMPIR, TMPRI, TMPRR, UHAV, UHAVI, UHBV,
     $                   UHBVI
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Local Arrays ..
</span>      DOUBLE PRECISION   DUMMY( 1 ), DUMMY1( 1 )
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Functions ..
</span>      LOGICAL            <a name="LSAME.301"></a><a href="lsame.f.html#LSAME.1">LSAME</a>
      DOUBLE PRECISION   DDOT, <a name="DLAMCH.302"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLAPY2.302"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>, DNRM2
      EXTERNAL           <a name="LSAME.303"></a><a href="lsame.f.html#LSAME.1">LSAME</a>, DDOT, <a name="DLAMCH.303"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>, <a name="DLAPY2.303"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>, DNRM2
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. External Subroutines ..
</span>      EXTERNAL           DGEMV, <a name="DLACPY.306"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>, <a name="DLAG2.306"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a>, <a name="DTGEXC.306"></a><a href="dtgexc.f.html#DTGEXC.1">DTGEXC</a>, <a name="DTGSYL.306"></a><a href="dtgsyl.f.html#DTGSYL.1">DTGSYL</a>, <a name="XERBLA.306"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Intrinsic Functions ..
</span>      INTRINSIC          MAX, MIN, SQRT
<span class="comment">*</span><span class="comment">     ..
</span><span class="comment">*</span><span class="comment">     .. Executable Statements ..
</span><span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Decode and test the input parameters
</span><span class="comment">*</span><span class="comment">
</span>      WANTBH = <a name="LSAME.315"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'B'</span> )
      WANTS = <a name="LSAME.316"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'E'</span> ) .OR. WANTBH
      WANTDF = <a name="LSAME.317"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'V'</span> ) .OR. WANTBH
<span class="comment">*</span><span class="comment">
</span>      SOMCON = <a name="LSAME.319"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( HOWMNY, <span class="string">'S'</span> )
<span class="comment">*</span><span class="comment">
</span>      INFO = 0
      LQUERY = ( LWORK.EQ.-1 )
<span class="comment">*</span><span class="comment">
</span>      IF( .NOT.WANTS .AND. .NOT.WANTDF ) THEN
         INFO = -1
      ELSE IF( .NOT.<a name="LSAME.326"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( HOWMNY, <span class="string">'A'</span> ) .AND. .NOT.SOMCON ) THEN
         INFO = -2
      ELSE IF( N.LT.0 ) THEN
         INFO = -4
      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN
         INFO = -6
      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN
         INFO = -8
      ELSE IF( WANTS .AND. LDVL.LT.N ) THEN
         INFO = -10
      ELSE IF( WANTS .AND. LDVR.LT.N ) THEN
         INFO = -12
      ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Set M to the number of eigenpairs for which condition numbers
</span><span class="comment">*</span><span class="comment">        are required, and test MM.
</span><span class="comment">*</span><span class="comment">
</span>         IF( SOMCON ) THEN
            M = 0
            PAIR = .FALSE.
            DO 10 K = 1, N
               IF( PAIR ) THEN
                  PAIR = .FALSE.
               ELSE
                  IF( K.LT.N ) THEN
                     IF( A( K+1, K ).EQ.ZERO ) THEN
                        IF( SELECT( K ) )
     $                     M = M + 1
                     ELSE
                        PAIR = .TRUE.
                        IF( SELECT( K ) .OR. SELECT( K+1 ) )
     $                     M = M + 2
                     END IF
                  ELSE
                     IF( SELECT( N ) )
     $                  M = M + 1
                  END IF
               END IF
   10       CONTINUE
         ELSE
            M = N
         END IF
<span class="comment">*</span><span class="comment">
</span>         IF( N.EQ.0 ) THEN
            LWMIN = 1
         ELSE IF( <a name="LSAME.371"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'V'</span> ) .OR. <a name="LSAME.371"></a><a href="lsame.f.html#LSAME.1">LSAME</a>( JOB, <span class="string">'B'</span> ) ) THEN
            LWMIN = 2*N*( N + 2 ) + 16
         ELSE
            LWMIN = N
         END IF
         WORK( 1 ) = LWMIN
<span class="comment">*</span><span class="comment">
</span>         IF( MM.LT.M ) THEN
            INFO = -15
         ELSE IF( LWORK.LT.LWMIN .AND. .NOT.LQUERY ) THEN
            INFO = -18
         END IF
      END IF
<span class="comment">*</span><span class="comment">
</span>      IF( INFO.NE.0 ) THEN
         CALL <a name="XERBLA.386"></a><a href="xerbla.f.html#XERBLA.1">XERBLA</a>( <span class="string">'<a name="DTGSNA.386"></a><a href="dtgsna.f.html#DTGSNA.1">DTGSNA</a>'</span>, -INFO )
         RETURN
      ELSE IF( LQUERY ) THEN
         RETURN
      END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Quick return if possible
</span><span class="comment">*</span><span class="comment">
</span>      IF( N.EQ.0 )
     $   RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     Get machine constants
</span><span class="comment">*</span><span class="comment">
</span>      EPS = <a name="DLAMCH.399"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'P'</span> )
      SMLNUM = <a name="DLAMCH.400"></a><a href="dlamch.f.html#DLAMCH.1">DLAMCH</a>( <span class="string">'S'</span> ) / EPS
      KS = 0
      PAIR = .FALSE.
<span class="comment">*</span><span class="comment">
</span>      DO 20 K = 1, N
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Determine whether A(k,k) begins a 1-by-1 or 2-by-2 block.
</span><span class="comment">*</span><span class="comment">
</span>         IF( PAIR ) THEN
            PAIR = .FALSE.
            GO TO 20
         ELSE
            IF( K.LT.N )
     $         PAIR = A( K+1, K ).NE.ZERO
         END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">        Determine whether condition numbers are required for the k-th
</span><span class="comment">*</span><span class="comment">        eigenpair.
</span><span class="comment">*</span><span class="comment">
</span>         IF( SOMCON ) THEN
            IF( PAIR ) THEN
               IF( .NOT.SELECT( K ) .AND. .NOT.SELECT( K+1 ) )
     $            GO TO 20
            ELSE
               IF( .NOT.SELECT( K ) )
     $            GO TO 20
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         KS = KS + 1
<span class="comment">*</span><span class="comment">
</span>         IF( WANTS ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Compute the reciprocal condition number of the k-th
</span><span class="comment">*</span><span class="comment">           eigenvalue.
</span><span class="comment">*</span><span class="comment">
</span>            IF( PAIR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Complex eigenvalue pair.
</span><span class="comment">*</span><span class="comment">
</span>               RNRM = <a name="DLAPY2.440"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( DNRM2( N, VR( 1, KS ), 1 ),
     $                DNRM2( N, VR( 1, KS+1 ), 1 ) )
               LNRM = <a name="DLAPY2.442"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( DNRM2( N, VL( 1, KS ), 1 ),
     $                DNRM2( N, VL( 1, KS+1 ), 1 ) )
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, A, LDA, VR( 1, KS ), 1, ZERO,
     $                     WORK, 1 )
               TMPRR = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               TMPRI = DDOT( N, WORK, 1, VL( 1, KS+1 ), 1 )
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, A, LDA, VR( 1, KS+1 ), 1,
     $                     ZERO, WORK, 1 )
               TMPII = DDOT( N, WORK, 1, VL( 1, KS+1 ), 1 )
               TMPIR = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               UHAV = TMPRR + TMPII
               UHAVI = TMPIR - TMPRI
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, B, LDB, VR( 1, KS ), 1, ZERO,
     $                     WORK, 1 )
               TMPRR = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               TMPRI = DDOT( N, WORK, 1, VL( 1, KS+1 ), 1 )
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, B, LDB, VR( 1, KS+1 ), 1,
     $                     ZERO, WORK, 1 )
               TMPII = DDOT( N, WORK, 1, VL( 1, KS+1 ), 1 )
               TMPIR = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               UHBV = TMPRR + TMPII
               UHBVI = TMPIR - TMPRI
               UHAV = <a name="DLAPY2.464"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( UHAV, UHAVI )
               UHBV = <a name="DLAPY2.465"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( UHBV, UHBVI )
               COND = <a name="DLAPY2.466"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( UHAV, UHBV )
               S( KS ) = COND / ( RNRM*LNRM )
               S( KS+1 ) = S( KS )
<span class="comment">*</span><span class="comment">
</span>            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Real eigenvalue.
</span><span class="comment">*</span><span class="comment">
</span>               RNRM = DNRM2( N, VR( 1, KS ), 1 )
               LNRM = DNRM2( N, VL( 1, KS ), 1 )
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, A, LDA, VR( 1, KS ), 1, ZERO,
     $                     WORK, 1 )
               UHAV = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               CALL DGEMV( <span class="string">'N'</span>, N, N, ONE, B, LDB, VR( 1, KS ), 1, ZERO,
     $                     WORK, 1 )
               UHBV = DDOT( N, WORK, 1, VL( 1, KS ), 1 )
               COND = <a name="DLAPY2.482"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( UHAV, UHBV )
               IF( COND.EQ.ZERO ) THEN
                  S( KS ) = -ONE
               ELSE
                  S( KS ) = COND / ( RNRM*LNRM )
               END IF
            END IF
         END IF
<span class="comment">*</span><span class="comment">
</span>         IF( WANTDF ) THEN
            IF( N.EQ.1 ) THEN
               DIF( KS ) = <a name="DLAPY2.493"></a><a href="dlapy2.f.html#DLAPY2.1">DLAPY2</a>( A( 1, 1 ), B( 1, 1 ) )
               GO TO 20
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Estimate the reciprocal condition number of the k-th
</span><span class="comment">*</span><span class="comment">           eigenvectors.
</span>            IF( PAIR ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Copy the  2-by 2 pencil beginning at (A(k,k), B(k, k)).
</span><span class="comment">*</span><span class="comment">              Compute the eigenvalue(s) at position K.
</span><span class="comment">*</span><span class="comment">
</span>               WORK( 1 ) = A( K, K )
               WORK( 2 ) = A( K+1, K )
               WORK( 3 ) = A( K, K+1 )
               WORK( 4 ) = A( K+1, K+1 )
               WORK( 5 ) = B( K, K )
               WORK( 6 ) = B( K+1, K )
               WORK( 7 ) = B( K, K+1 )
               WORK( 8 ) = B( K+1, K+1 )
               CALL <a name="DLAG2.512"></a><a href="dlag2.f.html#DLAG2.1">DLAG2</a>( WORK, 2, WORK( 5 ), 2, SMLNUM*EPS, BETA,
     $                     DUMMY1( 1 ), ALPHAR, DUMMY( 1 ), ALPHAI )
               ALPRQT = ONE
               C1 = TWO*( ALPHAR*ALPHAR+ALPHAI*ALPHAI+BETA*BETA )
               C2 = FOUR*BETA*BETA*ALPHAI*ALPHAI
               ROOT1 = C1 + SQRT( C1*C1-4.0D0*C2 )
               ROOT2 = C2 / ROOT1
               ROOT1 = ROOT1 / TWO
               COND = MIN( SQRT( ROOT1 ), SQRT( ROOT2 ) )
            END IF
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">           Copy the matrix (A, B) to the array WORK and swap the
</span><span class="comment">*</span><span class="comment">           diagonal block beginning at A(k,k) to the (1,1) position.
</span><span class="comment">*</span><span class="comment">
</span>            CALL <a name="DLACPY.526"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'Full'</span>, N, N, A, LDA, WORK, N )
            CALL <a name="DLACPY.527"></a><a href="dlacpy.f.html#DLACPY.1">DLACPY</a>( <span class="string">'Full'</span>, N, N, B, LDB, WORK( N*N+1 ), N )
            IFST = K
            ILST = 1
<span class="comment">*</span><span class="comment">
</span>            CALL <a name="DTGEXC.531"></a><a href="dtgexc.f.html#DTGEXC.1">DTGEXC</a>( .FALSE., .FALSE., N, WORK, N, WORK( N*N+1 ), N,
     $                   DUMMY, 1, DUMMY1, 1, IFST, ILST,
     $                   WORK( N*N*2+1 ), LWORK-2*N*N, IERR )
<span class="comment">*</span><span class="comment">
</span>            IF( IERR.GT.0 ) THEN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Ill-conditioned problem - swap rejected.
</span><span class="comment">*</span><span class="comment">
</span>               DIF( KS ) = ZERO
            ELSE
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">              Reordering successful, solve generalized Sylvester
</span><span class="comment">*</span><span class="comment">              equation for R and L,
</span><span class="comment">*</span><span class="comment">                         A22 * R - L * A11 = A12
</span><span class="comment">*</span><span class="comment">                         B22 * R - L * B11 = B12,
</span><span class="comment">*</span><span class="comment">              and compute estimate of Difl((A11,B11), (A22, B22)).
</span><span class="comment">*</span><span class="comment">
</span>               N1 = 1
               IF( WORK( 2 ).NE.ZERO )
     $            N1 = 2
               N2 = N - N1
               IF( N2.EQ.0 ) THEN
                  DIF( KS ) = COND
               ELSE
                  I = N*N + 1
                  IZ = 2*N*N + 1
                  CALL <a name="DTGSYL.557"></a><a href="dtgsyl.f.html#DTGSYL.1">DTGSYL</a>( <span class="string">'N'</span>, DIFDRI, N2, N1, WORK( N*N1+N1+1 ),
     $                         N, WORK, N, WORK( N1+1 ), N,
     $                         WORK( N*N1+N1+I ), N, WORK( I ), N,
     $                         WORK( N1+I ), N, SCALE, DIF( KS ),
     $                         WORK( IZ+1 ), LWORK-2*N*N, IWORK, IERR )
<span class="comment">*</span><span class="comment">
</span>                  IF( PAIR )
     $               DIF( KS ) = MIN( MAX( ONE, ALPRQT )*DIF( KS ),
     $                           COND )
               END IF
            END IF
            IF( PAIR )
     $         DIF( KS+1 ) = DIF( KS )
         END IF
         IF( PAIR )
     $      KS = KS + 1
<span class="comment">*</span><span class="comment">
</span>   20 CONTINUE
      WORK( 1 ) = LWMIN
      RETURN
<span class="comment">*</span><span class="comment">
</span><span class="comment">*</span><span class="comment">     End of <a name="DTGSNA.578"></a><a href="dtgsna.f.html#DTGSNA.1">DTGSNA</a>
</span><span class="comment">*</span><span class="comment">
</span>      END

</pre>

 </body>
</html>
