// This file was automatically generated by:
//  /Users/nhageman/Desktop/NAMIC_Summer2010/Slicer3/Slicer3-build/bin/GenerateCLP --InputXML /Users/nhageman/Desktop/NAMIC_Summer2010/FMTractography_Final/FMTractography.xml --OutputCxx /Users/nhageman/Desktop/NAMIC_Summer2010/FMTractography_Final/FMTractographyCLP.h
//
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <string.h>
#include <vector>
#include <map>

#include <itksys/ios/sstream>

#include "tclap/CmdLine.h"
#include "ModuleProcessInformation.h"

#ifdef WIN32
#define Module_EXPORT __declspec(dllexport)
#else
#define Module_EXPORT 
#endif

#if defined(main) && !defined(REGISTER_TEST)
// If main defined as a preprocessor symbol, redefine it to the expected entry point.
#undef main
#define main ModuleEntryPoint

extern "C" {
  Module_EXPORT char *GetXMLModuleDescription();
  Module_EXPORT int ModuleEntryPoint(int, char*[]);
}
#endif

extern "C" {
Module_EXPORT char XMLModuleDescription[] = 
"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"
"<executable>\n"
"  <category>\n"
"            Diffusion.Tractography</category>\n"
"  <title>\n"
"         Fluid Mechanics Tractography</title>\n"
"  <description>\n"
"               Tractography algorithm based on a fluid mechanics model, created by Nathan Hageman</description>\n"
"  <version>\n"
"           1.0</version>\n"
"  <documentation-url></documentation-url>\n"
"  <license></license>\n"
"  <contributor>\n"
"               Nathan Hageman, Arthur W. Toga, Ph.D </contributor>\n"
"  <acknowledgements>\n"
"                    This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149. </acknowledgements>\n"
" <parameters>\n"
"    <label>Input Volumes</label>\n"
"    <description>Input volumes</description>\n"
"    <image>\n"
"   <name>tensorfname</name>\n"
"   <longflag>ieigenvolfname</longflag>    \n"
"      <label>Input Tensor Volume</label>\n"
"      <channel>input</channel>\n"
"      <default>None</default>\n"
"      <description>Tensor volume</description>\n"
"    </image>\n"
" <image>\n"
"  <name>seedroi</name>\n"
"  <longflag>seedroi</longflag>\n"
"  <label>Fluid Source ROIs</label>\n"
"  <channel>input</channel>\n"
"  <default>None</default>\n"
"  <description>Mask volumes that define the regions of fluid source</description>\n"
" </image>\n"
" <image>\n"
"  <name>stoproi</name>\n"
"  <longflag>stoproi</longflag>\n"
"  <label>Tract Select ROIs</label>\n"
"  <channel>input</channel>\n"
"  <default>None</default>\n"
"  <description>Masks volumes that define regions to select tracts</description>\n"
" </image>\n"
"   <string>\n\n"
"   <name>idtype</name>\n\n"
"      <longflag>idtype</longflag>    \n\n"
"      <label>Seed ROI Volume Datatype</label>\n\n"
"      <channel>input</channel>\n\n"
"      <default>UINT16</default>\n\n"
"      <description>Datatype of Mask ROI volumes (valid values = UINT8, SINT8, UINT16, SINT16, UINT32, SINT32, FLOAT</description>\n\n"
"    </string>\n\n"
"</parameters>\n"
"<parameters>\n"
" <label>Output</label>\n"
" <description>Parameters for output</description> \n"
"    <string>\n"
"   <name>ofprefix</name>\n"
"      <longflag>ofprefix</longflag>    \n"
"      <label>Output Prefix</label>\n"
"      <channel>input</channel>\n"
"      <default>output</default>\n"
"      <description>Output prefix for tracts</description>\n"
"    </string>\n"
" <directory>\n"
"  <name>odir</name>\n"
"  <longflag>ofpath</longflag>\n"
"  <label>Output Directory</label>\n"
"  <channel>input</channel>\n"
"  <default>None</default>\n"
"  <description>Directory to output tracts</description>\n"
" </directory>\n"
"</parameters>\n"
"<parameters>\n"
" <label>Fluid Parameters</label>\n"
"    <description>Model Parameters for the Fluid Mechanics Method</description>\n"
" <double>\n\n"
"      <name>viscosityconstant</name>\n\n"
"      <longflag>VISCOSITYCONSTANT</longflag>\n\n"
"      <description>Constant which determines the magnitude of the viscous force (0 to 1)</description>\n\n"
"      <label>Viscosity Constant</label>\n\n"
"      <default>0.3</default>\n\n"
" </double>\n\n"
"</parameters>\n"
"<parameters>\n"
" <label>Tractography Parameters</label>\n"
"    <description>Model Parameters for the tractography method</description>\n"
" <double>\n\"\n"
"      <name>maxturnangle</name>\n\n"
"      <longflag>MAXTURNANGLE</longflag>\n\n"
"      <description>Max turn angle criteria for tract (in degrees)</description>\n\n"
"      <label>Max Turn Angle</label>\n\"\n"
"      <default>45.0</default>\n\n"
" </double>\n \n"
" <double>\n"
"      <name>mintractlength</name>\n"
"      <longflag>MINTRACTLENGTH</longflag>\n"
"      <description>Minimum tract length (in mm) </description>\n"
"      <label>Min Tract Length</label>\n"
"      <default>0.0</default>\n"
" </double>\n"
" <double>\n"
"      <name>maxtractlength</name>\n"
"      <longflag>MAXTRACTLENGTH</longflag>\n"
"      <description>Maximum tract length (in mm) </description>\n"
"      <label>Max Tract Length</label>\n"
"      <default>0.0</default>\n"
" </double>\n"
" <integer>\n"
"      <name>totaltrys</name>\n"
"      <longflag>totaltrys</longflag>\n"
"      <description>Number of seed points</description>\n"
"      <label>Seed Density</label>\n"
"      <default>1</default>\n"
" </integer>\n"
"</parameters>\n"
"</executable>\n"
;

}

void
splitString (const std::string &text,
             const std::string &separators,
             std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  std::string::size_type start = text.find_first_not_of(separators);
  while (start < n)
    {
    std::string::size_type stop = text.find_first_of(separators, start);
    if (stop > n) stop = n;
    words.push_back(text.substr(start, stop - start));
    start = text.find_first_not_of(separators, stop+1);
    }
}

void
splitFilenames (const std::string &text,
                std::vector<std::string> &words)
{
  const std::string::size_type n = text.length();
  bool quoted;
  std::string comma(",");
  std::string quote("\"");
  std::string::size_type start = text.find_first_not_of(comma);
  while (start < n)
    {
    quoted = false;
    std::string::size_type startq = text.find_first_of(quote, start);
    std::string::size_type stopq = text.find_first_of(quote, startq+1);
    std::string::size_type stop = text.find_first_of(comma, start);
    if (stop > n) stop = n;
    if (startq != std::string::npos && stopq != std::string::npos)
      {
      while (startq < stop && stop < stopq && stop != n)
         {
         quoted = true;
         stop = text.find_first_of(comma, stop+1);
         if (stop > n) stop = n;
         }
      }
    if (!quoted)
      {
      words.push_back(text.substr(start, stop - start));
      }
    else
      {
      words.push_back(text.substr(start+1, stop - start-2));
      }
    start = text.find_first_not_of(comma, stop+1);
    }
}

char *GetXMLModuleDescription()
{
   return XMLModuleDescription;
}

#define GENERATE_LOGO
#define GENERATE_XML \
  if (argc >= 2 && (strcmp(argv[1],"--xml") == 0)) \
    { \
    std::cout << GetXMLModuleDescription(); \
    return EXIT_SUCCESS; \
    }
#define GENERATE_TCLAP \
    std::string tensorfname = "None"; \
    std::string seedroi = "None"; \
    std::string stoproi = "None"; \
    std::string idtype = "UINT16"; \
    std::string ofprefix = "output"; \
    std::string odir = "None"; \
    double viscosityconstant = 0.3; \
    double maxturnangle = 45.0; \
    double mintractlength = 0.0; \
    double maxtractlength = 0.0; \
    int totaltrys = 1; \
    bool echoSwitch = false; \
    bool xmlSwitch = false; \
    std::string processInformationAddressString = "0"; \
    std::string returnParameterFile; \
    std::string fullDescription("Description: "); \
    fullDescription += "Tractography algorithm based on a fluid mechanics model, created by Nathan Hageman"; \
    if (!std::string("Nathan Hageman, Arthur W. Toga, Ph.D").empty()) \
      { \
      fullDescription += "\nAuthor(s): Nathan Hageman, Arthur W. Toga, Ph.D"; \
      } \
    if (!std::string("This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149.").empty()) \
      { \
      fullDescription += "\nAcknowledgements: This work is part of the National Alliance for Medical Image Computing (NAMIC), funded by the National Institutes of Health through the NIH Roadmap for Medical Research, Grant U54 EB005149."; \
      } \
    TCLAP::CmdLine commandLine (fullDescription, \
       ' ', \
      "1.0" ); \
 \
      itksys_ios::ostringstream msg; \
    msg.str("");msg << "Tensor volume (default: " << tensorfname << ")"; \
    TCLAP::ValueArg<std::string > tensorfnameArg("", "ieigenvolfname", msg.str(), 0, tensorfname, "std::string", commandLine); \
 \
    msg.str("");msg << "Mask volumes that define the regions of fluid source (default: " << seedroi << ")"; \
    TCLAP::ValueArg<std::string > seedroiArg("", "seedroi", msg.str(), 0, seedroi, "std::string", commandLine); \
 \
    msg.str("");msg << "Masks volumes that define regions to select tracts (default: " << stoproi << ")"; \
    TCLAP::ValueArg<std::string > stoproiArg("", "stoproi", msg.str(), 0, stoproi, "std::string", commandLine); \
 \
    msg.str("");msg << "Datatype of Mask ROI volumes (valid values = UINT8, SINT8, UINT16, SINT16, UINT32, SINT32, FLOAT (default: " << idtype << ")"; \
    TCLAP::ValueArg<std::string > idtypeArg("", "idtype", msg.str(), 0, idtype, "std::string", commandLine); \
 \
    msg.str("");msg << "Output prefix for tracts (default: " << ofprefix << ")"; \
    TCLAP::ValueArg<std::string > ofprefixArg("", "ofprefix", msg.str(), 0, ofprefix, "std::string", commandLine); \
 \
    msg.str("");msg << "Directory to output tracts (default: " << odir << ")"; \
    TCLAP::ValueArg<std::string > odirArg("", "ofpath", msg.str(), 0, odir, "std::string", commandLine); \
 \
    msg.str("");msg << "Constant which determines the magnitude of the viscous force (0 to 1) (default: " << viscosityconstant << ")"; \
    TCLAP::ValueArg<double > viscosityconstantArg("", "VISCOSITYCONSTANT", msg.str(), 0, viscosityconstant, "double", commandLine); \
 \
    msg.str("");msg << "Max turn angle criteria for tract (in degrees) (default: " << maxturnangle << ")"; \
    TCLAP::ValueArg<double > maxturnangleArg("", "MAXTURNANGLE", msg.str(), 0, maxturnangle, "double", commandLine); \
 \
    msg.str("");msg << "Minimum tract length (in mm) (default: " << mintractlength << ")"; \
    TCLAP::ValueArg<double > mintractlengthArg("", "MINTRACTLENGTH", msg.str(), 0, mintractlength, "double", commandLine); \
 \
    msg.str("");msg << "Maximum tract length (in mm) (default: " << maxtractlength << ")"; \
    TCLAP::ValueArg<double > maxtractlengthArg("", "MAXTRACTLENGTH", msg.str(), 0, maxtractlength, "double", commandLine); \
 \
    msg.str("");msg << "Number of seed points (default: " << totaltrys << ")"; \
    TCLAP::ValueArg<int > totaltrysArg("", "totaltrys", msg.str(), 0, totaltrys, "int", commandLine); \
 \
    msg.str("");msg << "Echo the command line arguments (default: " << echoSwitch << ")"; \
    TCLAP::SwitchArg echoSwitchArg("", "echo", msg.str(), commandLine, echoSwitch); \
 \
    msg.str("");msg << "Produce xml description of command line arguments (default: " << xmlSwitch << ")"; \
    TCLAP::SwitchArg xmlSwitchArg("", "xml", msg.str(), commandLine, xmlSwitch); \
 \
    msg.str("");msg << "Address of a structure to store process information (progress, abort, etc.). (default: " << processInformationAddressString << ")"; \
    TCLAP::ValueArg<std::string > processInformationAddressStringArg("", "processinformationaddress", msg.str(), 0, processInformationAddressString, "std::string", commandLine); \
 \
    msg.str("");msg << "Filename in which to write simple return parameters (int, float, int-vector, etc.) as opposed to bulk return parameters (image, geometry, transform, measurement, table).";    TCLAP::ValueArg<std::string > returnParameterFileArg("", "returnparameterfile", msg.str(), 0, returnParameterFile, "std::string", commandLine); \
 \
try \
  { \
    /* Build a map of flag aliases to the true flag */ \
    std::map<std::string,std::string> flagAliasMap; \
    std::map<std::string,std::string> deprecatedFlagAliasMap; \
    std::map<std::string,std::string> longFlagAliasMap; \
    std::map<std::string,std::string> deprecatedLongFlagAliasMap; \
    /* Remap flag aliases to the true flag */ \
    std::vector<std::string> targs; \
    std::map<std::string,std::string>::iterator ait; \
    std::map<std::string,std::string>::iterator dait; \
    size_t ac; \
    for (ac=0; ac < static_cast<size_t>(argc); ++ac)  \
       {  \
       if (strlen(argv[ac]) == 2 && argv[ac][0]=='-') \
         { \
         /* short flag case */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         ait = flagAliasMap.find(tflag); \
         dait = deprecatedFlagAliasMap.find(tflag); \
         if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
           { \
           if (ait != flagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("-" + (*ait).second); \
             } \
           else if (dait != deprecatedFlagAliasMap.end()) \
             { \
             std::cout << "Flag \"" << argv[ac] << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("-" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]=='-') \
         { \
         /* long flag case */ \
         std::string tflag(argv[ac], 2, strlen(argv[ac])-2); \
         ait = longFlagAliasMap.find(tflag); \
         dait = deprecatedLongFlagAliasMap.find(tflag); \
         if (ait != longFlagAliasMap.end() || dait != deprecatedLongFlagAliasMap.end()) \
           { \
           if (ait != longFlagAliasMap.end()) \
             { \
             /* remap the flag */ \
             targs.push_back("--" + (*ait).second); \
             } \
           else if (dait != deprecatedLongFlagAliasMap.end()) \
             { \
             std::cout << "Long flag \"" << argv[ac] << "\" is deprecated. Please use long flag \"--" << (*dait).second << "\" instead. " << std::endl; \
             /* remap the flag */ \
             targs.push_back("--" + (*dait).second); \
             } \
           } \
         else \
           { \
           targs.push_back(argv[ac]); \
           } \
         } \
       else if (strlen(argv[ac]) > 2 && argv[ac][0]=='-' && argv[ac][1]!='-') \
         { \
         /* short flag case where multiple flags are given at once ala */ \
         /* "ls -ltr" */ \
         std::string tflag(argv[ac], 1, strlen(argv[ac])-1); \
         std::string rflag("-"); \
         for (std::string::size_type fi=0; fi < tflag.size(); ++fi) \
           { \
           std::string tf(tflag, fi, 1); \
           ait = flagAliasMap.find(tf); \
           dait = deprecatedFlagAliasMap.find(tf); \
           if (ait != flagAliasMap.end() || dait != deprecatedFlagAliasMap.end()) \
             { \
             if (ait != flagAliasMap.end()) \
               { \
               /* remap the flag */ \
               rflag += (*ait).second; \
               } \
             else if (dait != deprecatedFlagAliasMap.end()) \
               { \
               std::cout << "Flag \"-" << tf << "\" is deprecated. Please use flag \"-" << (*dait).second << "\" instead. " << std::endl; \
               /* remap the flag */ \
               rflag += (*dait).second; \
               } \
             } \
           else \
             { \
             rflag += tf; \
             } \
           } \
         targs.push_back(rflag); \
         } \
       else \
         { \
         /* skip the argument without remapping (this is the case for any */ \
         /* arguments for flags */ \
         targs.push_back(argv[ac]); \
         } \
       } \
 \
   /* Remap args to a structure that CmdLine::parse() can understand*/ \
   std::vector<char*> vargs; \
   for (ac = 0; ac < targs.size(); ++ac) \
     {  \
     vargs.push_back(const_cast<char *>(targs[ac].c_str())); \
     } \
    commandLine.parse ( vargs.size(), (char**) &(vargs[0]) ); \
    tensorfname = tensorfnameArg.getValue(); \
    seedroi = seedroiArg.getValue(); \
    stoproi = stoproiArg.getValue(); \
    idtype = idtypeArg.getValue(); \
    ofprefix = ofprefixArg.getValue(); \
    odir = odirArg.getValue(); \
    viscosityconstant = viscosityconstantArg.getValue(); \
    maxturnangle = maxturnangleArg.getValue(); \
    mintractlength = mintractlengthArg.getValue(); \
    maxtractlength = maxtractlengthArg.getValue(); \
    totaltrys = totaltrysArg.getValue(); \
    echoSwitch = echoSwitchArg.getValue(); \
    xmlSwitch = xmlSwitchArg.getValue(); \
    processInformationAddressString = processInformationAddressStringArg.getValue(); \
    returnParameterFile = returnParameterFileArg.getValue(); \
  } \
catch ( TCLAP::ArgException e ) \
  { \
  std::cerr << "error: " << e.error() << " for arg " << e.argId() << std::endl; \
  return ( EXIT_FAILURE ); \
  }
#define GENERATE_ECHOARGS \
if (echoSwitch) \
{ \
std::cout << "Command Line Arguments" << std::endl; \
std::cout << "    tensorfname: " << tensorfname << std::endl; \
std::cout << "    seedroi: " << seedroi << std::endl; \
std::cout << "    stoproi: " << stoproi << std::endl; \
std::cout << "    idtype: " << idtype << std::endl; \
std::cout << "    ofprefix: " << ofprefix << std::endl; \
std::cout << "    odir: " << odir << std::endl; \
std::cout << "    viscosityconstant: " << viscosityconstant << std::endl; \
std::cout << "    maxturnangle: " << maxturnangle << std::endl; \
std::cout << "    mintractlength: " << mintractlength << std::endl; \
std::cout << "    maxtractlength: " << maxtractlength << std::endl; \
std::cout << "    totaltrys: " << totaltrys << std::endl; \
std::cout << "    echoSwitch: " << echoSwitch << std::endl; \
std::cout << "    xmlSwitch: " << xmlSwitch << std::endl; \
std::cout << "    processInformationAddressString: " << processInformationAddressString << std::endl; \
std::cout << "    returnParameterFile: " << returnParameterFile << std::endl; \
}
#define GENERATE_ProcessInformationAddressDecoding \
ModuleProcessInformation *CLPProcessInformation = 0; \
if (processInformationAddressString != "") \
{ \
sscanf(processInformationAddressString.c_str(), "%p", &CLPProcessInformation); \
}
#define PARSE_ARGS GENERATE_LOGO;GENERATE_XML;GENERATE_TCLAP;GENERATE_ECHOARGS;GENERATE_ProcessInformationAddressDecoding;
