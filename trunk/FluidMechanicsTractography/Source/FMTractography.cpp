
#include "FMTractography.h"
#include "FMTractographyCLP.h"

//#include "randomc.h"
//#include "stocc.h"     // class definition


namespace hageman{


/***************************** ERFRES.CPP **************************************
Table of residues of a certain expansion of the error function.  
These tables are used in the Laplace method for calculating Wallenius noncentral
hypergeometric distribution. Used in CWalleniusNCHypergeometric::laplace() and
CMultiWalleniusNCHypergeometric::laplace().

This file is generated by ERFRESMK.CPP. Please see the file ERFRESMK.CPP for a
detailed description. You must re-run ERFRESMK.CPP if the constants in STOCC.H
are changed.

The following constants have been used for making the tables below:
ERFRES_B =   16    (-log2 of lowest precision)
ERFRES_E =   40    (-log2 of highest precision)
ERFRES_S =    2    (step size from begin to end)
ERFRES_N =   13    (number of tables)
ERFRES_L =   48    (length of each table)

*******************************************************************************/

//number of standard deviations to integrate
extern "C" double NumSDev[ERFRES_N] = {
  4.324919041, 4.621231001, 4.900964208, 5.16657812, 5.419983175, 5.662697617, 5.895951217, 6.120756286, 6.337957755, 6.548269368, 6.752300431, 6.950575948, 7.143552034};

//tables of error function residues
extern "C" double ErfRes[ERFRES_N][ERFRES_L] = {
  // 0: precision 1.53E-05
  {1.77242680540608204400E+00, 4.42974050453076994800E-01, 5.52683719287987914000E-02, 4.57346771067359261300E-03, 
   2.80459064155823224600E-04, 1.34636065677244878500E-05, 5.21352785817798300800E-07, 1.65832271688171705300E-08, 
   4.38865717471213472100E-10, 9.76518286165874680600E-12, 1.84433013221606645200E-13, 2.98319658966723379900E-15, 
   4.16751049288581722800E-17, 5.06844293411881381200E-19, 5.40629927341885830200E-21, 5.09268600245963099700E-23, 
   4.26365286677037947600E-25, 3.19120961809492396300E-27, 2.14691825888024309100E-29, 1.30473994083903636000E-31, 
   7.19567933922698314600E-34, 3.61655672748362805300E-36, 1.66299275803871018000E-38, 7.02143932105206679000E-41, 
   2.73122271211734530800E-43, 9.81824938600123102500E-46, 3.27125155121613401700E-48, 1.01290491600297417870E-50, 
   2.92208589554240568800E-53, 7.87247562929246970200E-56, 1.98510836143160618600E-58, 4.69476368999432417500E-61, 
   1.04339442450396263710E-63, 2.18317315734482557700E-66, 4.30811606197931495800E-69, 8.03081062303437395000E-72, 
   1.41637813978528824300E-74, 2.36693694351427741600E-77, 3.75309000199992425400E-80, 5.65409397708564003600E-83, 
   8.10322084538751956300E-86, 1.10610328893385430400E-88, 1.43971150303803736000E-91, 1.78884532267880002700E-94, 
   2.12393968173898899400E-97, 2.41222807417272408400E-100, 2.62311608532487946600E-103, 2.73362126618952541200E-106},
  // 1: precision 3.81E-06
  {1.77244708953065753100E+00, 4.43074113723358004800E-01, 5.53507546366094128100E-02, 4.60063583541917741200E-03, 
   2.85265530531727983900E-04, 1.39934570721569428400E-05, 5.61234181715130108200E-07, 1.87635216633109792000E-08, 
   5.29386567604284238200E-10, 1.27170893476994027400E-11, 2.62062404027629145800E-13, 4.66479837413316034000E-15, 
   7.22069968938298529400E-17, 9.78297384753513147400E-19, 1.16744590415498861200E-20, 1.23448081765041655900E-22, 
   1.16327347874717650400E-24, 9.82084801488552519700E-27, 7.46543820883360082800E-29, 5.13361419796185362400E-31, 
   3.20726459674397306300E-33, 1.82784782995019591600E-35, 9.53819678596992509200E-38, 4.57327699736894183000E-40, 
   2.02131302843758583500E-42, 8.26035836048709995200E-45, 3.13004443753993537100E-47, 1.10264466279388735400E-49, 
   3.62016356599029098800E-52, 1.11028768672354227000E-54, 3.18789098809699663200E-57, 8.58660896411902915800E-60, 
   2.17384332055877431800E-62, 5.18219413865915035000E-65, 1.16526530012222654600E-67, 2.47552943408735877700E-70, 
   4.97637013794934320200E-73, 9.47966949394160838200E-76, 1.71361124212171341900E-78, 2.94335699587741039100E-81, 
   4.80983789654609513600E-84, 7.48676877660738410200E-87, 1.11129798477201315100E-89, 1.57475145101473103400E-92, 
   2.13251069867015016100E-95, 2.76249093386952224300E-98, 3.42653604413897348900E-101, 4.07334940102519697800E-104},
  // 2: precision 9.54E-07
  {1.77245216056180140300E+00, 4.43102496776356791100E-01, 5.53772601883593673800E-02, 4.61054749828262358400E-03, 
   2.87253302758514987700E-04, 1.42417784632842086400E-05, 5.82408831964509309600E-07, 2.00745450404117050700E-08, 
   5.91011604093749423400E-10, 1.49916022838813094600E-11, 3.29741365965300606900E-13, 6.32307780683001018100E-15, 
   1.06252674842175897800E-16, 1.57257431560311360800E-18, 2.06034642322747725700E-20, 2.40159615347654528000E-22, 
   2.50271435589313449400E-24, 2.34271631492982176000E-26, 1.97869636045309031700E-28, 1.51440731538936707000E-30, 
   1.05452976534458622500E-32, 6.70612854853490875900E-35, 3.90863249061728208500E-37, 2.09490406980039604000E-39, 
   1.03572639732910843160E-41, 4.73737271771599553200E-44, 2.01016799853191990700E-46, 7.93316727009805559200E-49, 
   2.91896910080597410900E-51, 1.00361556207253403120E-53, 3.23138481735358914000E-56, 9.76266225260763484100E-59, 
   2.77288342251948021500E-61, 7.41751660051554639600E-64, 1.87191699537047863600E-66, 4.46389809367038823800E-69, 
   1.00740435367143552990E-71, 2.15468537440631290200E-74, 4.37372804933525238000E-77, 8.43676369508201162800E-80, 
   1.54845094802349484100E-82, 2.70727577941653793200E-85, 4.51412388960109772800E-88, 7.18605932463221426200E-91, 
   1.09328719452457957600E-93, 1.59123500193816486400E-96, 2.21770259794482485600E-99, 2.96235081914900644200E-102},
  // 3: precision 2.38E-07
  {1.77245342831958737100E+00, 4.43110438095780200600E-01, 5.53855581791170228000E-02, 4.61401880234106439000E-03, 
   2.88031928895194049600E-04, 1.43505456256023050800E-05, 5.92777558091362167400E-07, 2.07920891418090254000E-08, 
   6.28701715960960909000E-10, 1.65457546101845217200E-11, 3.81394501062348919800E-13, 7.73640169798996619200E-15, 
   1.38648618664047143200E-16, 2.20377376795474051600E-18, 3.11871105901085320300E-20, 3.94509797765438339700E-22, 
   4.47871054279593642800E-24, 4.58134444141001287500E-26, 4.23915369932833545200E-28, 3.56174643985755223000E-30, 
   2.72729562179570597400E-32, 1.90986605998546816600E-34, 1.22720072734085613700E-36, 7.25829034260272865500E-39, 
   3.96321699645874596800E-41, 2.00342049456074966200E-43, 9.40055798441764717800E-46, 4.10462275003981738400E-48, 
   1.67166813346582579800E-50, 6.36422340874443565900E-53, 2.26969100679582421400E-55, 7.59750937838053600600E-58, 
   2.39149482673471882600E-60, 7.09134153544718378800E-63, 1.98415128824311335000E-65, 5.24683837588056156800E-68, 
   1.31326161465641387500E-70, 3.11571024962460536800E-73, 7.01627137211411880000E-76, 1.50162731270605666400E-78, 
   3.05816530510335364700E-81, 5.93355048535012188600E-84, 1.09802441010335521600E-86, 1.94008240128183308800E-89, 
   3.27631821921541675800E-92, 5.29343480369738200400E-95, 8.19001419434114020600E-98, 1.21456436757992622700E-100},
  // 4: precision 5.96E-08
  {1.77245374525903386300E+00, 4.43112635580628681700E-01, 5.53880993417431935600E-02, 4.61519508177347361400E-03, 
   2.88323830371235781500E-04, 1.43956506488931199600E-05, 5.97533121516696046900E-07, 2.11560073234896927000E-08, 
   6.49836113541376862800E-10, 1.75091216044688314800E-11, 4.16782737060155846600E-13, 8.80643257335436424800E-15, 
   1.65748420791207225100E-16, 2.78707349086274968000E-18, 4.19899868515935354900E-20, 5.68498078698629510200E-22, 
   6.93816222596422139400E-24, 7.65747618996655475200E-26, 7.66779861336649418200E-28, 6.98905143723583695400E-30, 
   5.81737537190421990800E-32, 4.43568540037466870600E-34, 3.10768227888207447300E-36, 2.00640852664381818400E-38, 
   1.19706367104711013300E-40, 6.61729939738396217600E-43, 3.39784063694262711800E-45, 1.62450416252839296200E-47, 
   7.24798161653719932800E-50, 3.02428684730111423300E-52, 1.18255348374176440700E-54, 4.34156802253088795200E-57, 
   1.49931575039307549400E-59, 4.87879082698754128200E-62, 1.49836511723882777600E-64, 4.34998243416684050900E-67, 
   1.19554618884894856000E-69, 3.11506828608539767000E-72, 7.70504604851319512900E-75, 1.81153231245726529100E-77, 
   4.05332288179748454100E-80, 8.64127160751002389800E-83, 1.75723563299790750600E-85, 3.41217779987510142000E-88, 
   6.33324341504830543600E-91, 1.12470466360665277900E-93, 1.91282818505057981800E-96, 3.11838272111119088500E-99},
  // 5: precision 1.49E-08
  {1.77245382449389548700E+00, 4.43113238150016054000E-01, 5.53888635367372804600E-02, 4.61558298326459057200E-03, 
   2.88429374592283566800E-04, 1.44135302457832808700E-05, 5.99599530816354110000E-07, 2.13293263207088596800E-08, 
   6.60866899904610148200E-10, 1.80600922150303605400E-11, 4.38957621672449876700E-13, 9.54096365498724593600E-15, 
   1.86125270560486321400E-16, 3.26743200260750243300E-18, 5.17322947745786073000E-20, 7.40303709577309752000E-22, 
   9.59703297362487960100E-24, 1.12979041959758568400E-25, 1.21090586780714120800E-27, 1.18477600671972569200E-29, 
   1.06110784945102789800E-31, 8.72301430014194580800E-34, 6.59978694597213862400E-36, 4.60782503988683505400E-38, 
   2.97629996764696360400E-40, 1.78296967476668997800E-42, 9.92947813649120231300E-45, 5.15238281451496107200E-47, 
   2.49648080941516617600E-49, 1.13183145876711695200E-51, 4.81083885812771760200E-54, 1.92068525483444959800E-56, 
   7.21538203720691761200E-59, 2.55484244329461795400E-61, 8.54021947322263940200E-64, 2.69922457940407460300E-66, 
   8.07806757099831088400E-69, 2.29233505413233278200E-71, 6.17627451352383776600E-74, 1.58198519435517862400E-76, 
   3.85682833066898009900E-79, 8.96007783937447061800E-82, 1.98575880907873828900E-84, 4.20275001914011054200E-87, 
   8.50301055680340658200E-90, 1.64613519849643900900E-92, 3.05222294684008316300E-95, 5.42516704506242119200E-98},
  // 6: precision 3.73E-09
  {1.77245384430261089200E+00, 4.43113402125597019200E-01, 5.53890898808651020700E-02, 4.61570802060252211600E-03, 
   2.88466397094702578100E-04, 1.44203545983349722400E-05, 6.00457657669759309400E-07, 2.14076280553580130200E-08, 
   6.66287908992827087900E-10, 1.83546080772263722600E-11, 4.51849203153760888400E-13, 1.00053478654150626250E-14, 
   2.00133542358651377800E-16, 3.62647881190865840300E-18, 5.96489800325831839200E-20, 8.92069144951359438200E-22, 
   1.21499978844978062400E-23, 1.50969159775091919100E-25, 1.71458470816131592700E-27, 1.78354149193378771000E-29, 
   1.70298947555869630200E-31, 1.49600537831395400600E-33, 1.21186208172570666700E-35, 9.07362642179266008600E-38, 
   6.29382543478586469600E-40, 4.05352760000606626000E-42, 2.42933889358226154400E-44, 1.35768914148821438100E-46, 
   7.09017160688256911600E-49, 3.46664168532600651800E-51, 1.58991153690202909500E-53, 6.85218984466549798200E-56, 
   2.77986852228382907500E-58, 1.06333492956411188200E-60, 3.84102521375678317000E-63, 1.31221496031384552800E-65, 
   4.24584095965170648000E-68, 1.30291378525223696900E-70, 3.79687911940099574200E-73, 1.05205378465263412500E-75, 
   2.77502269989758744900E-78, 6.97601832816401403200E-81, 1.67315109709482392200E-83, 3.83268665565667928900E-86, 
   8.39358376033290752000E-89, 1.75907817494562062400E-91, 3.53115954806899335200E-94, 6.79562013989671425000E-97},
  // 7: precision 9.31E-10
  {1.77245384925478974400E+00, 4.43113446460012284000E-01, 5.53891560601252504200E-02, 4.61574755288994634700E-03, 
   2.88479053368568788400E-04, 1.44228769021976818600E-05, 6.00800544645992949800E-07, 2.14414502554089331400E-08, 
   6.68819005926294320800E-10, 1.85032367193584636900E-11, 4.58880445172944815400E-13, 1.02790650461108873560E-14, 
   2.09055796622121955200E-16, 3.87357904265687446300E-18, 6.55355746022352119400E-20, 1.01398465283490267200E-21, 
   1.43654532753298842400E-23, 1.86580454392148962200E-25, 2.22454554378132065200E-27, 2.43828788210971585600E-29, 
   2.46099438567553070000E-31, 2.29136593939231572900E-33, 1.97178483051357608300E-35, 1.57129911859150760300E-37, 
   1.16187715309016251400E-39, 7.98791034830625946600E-42, 5.11610271388176540200E-44, 3.05861085454619325800E-46, 
   1.71006575230074253400E-48, 8.95787473757552059200E-51, 4.40426750636187741200E-53, 2.03593329808165663200E-55, 
   8.86319619094250260800E-58, 3.63949556302483252000E-60, 1.41180525527432472100E-62, 5.18110448656726197600E-65, 
   1.80130976146235507900E-67, 5.94089489436009998000E-70, 1.86108901096460881000E-72, 5.54453617603266634800E-75, 
   1.57273231131712670500E-77, 4.25229555550383344000E-80, 1.09708064410784368000E-82, 2.70363777400980301400E-85, 
   6.37064773173804957600E-88, 1.43666982549400138800E-90, 3.10359876850474266200E-93, 6.42822304267944541900E-96},
  // 8: precision 2.33E-10
  {1.77245385049283445600E+00, 4.43113458380306853400E-01, 5.53891751960330686200E-02, 4.61575984524613369300E-03, 
   2.88483285115404915700E-04, 1.44237837119469849000E-05, 6.00933085215778545800E-07, 2.14555059613473259000E-08, 
   6.69949807134525424700E-10, 1.85746173246056176400E-11, 4.62510251141501895600E-13, 1.04309449728125451550E-14, 
   2.14376794695367282400E-16, 4.03195345507914206800E-18, 6.95901230873262760600E-20, 1.10422005968960415700E-21, 
   1.61274044622451622200E-23, 2.17010646570190394600E-25, 2.69272585719737993500E-27, 3.08406442023150341400E-29, 
   3.26412756902204044100E-31, 3.19659762892894327800E-33, 2.90079234489442113000E-35, 2.44307440922101839900E-37, 
   1.91280099578638699700E-39, 1.39463784147443818800E-41, 9.48568383329895892700E-44, 6.02906080392955580400E-46, 
   3.58720420688290561300E-48, 2.00136767763554841800E-50, 1.04877885428425423540E-52, 5.17045929753308956200E-55, 
   2.40183088534749939500E-57, 1.05288434613857573000E-59, 4.36191374659545444200E-62, 1.71017740178796946700E-64, 
   6.35417287308090154000E-67, 2.24023617204667066100E-69, 7.50388817892399787300E-72, 2.39087016939309798700E-74, 
   7.25439736654156264700E-77, 2.09846227207024494800E-79, 5.79315651373498761100E-82, 1.52786617607871741100E-84, 
   3.85332605389629328300E-87, 9.30196261538477647000E-90, 2.15126632809118648300E-92, 4.77058936290696223500E-95},
  // 9: precision 5.82E-11
  {1.77245385080234563500E+00, 4.43113461569894215700E-01, 5.53891806760746538300E-02, 4.61576361260268991600E-03, 
   2.88484673044866409200E-04, 1.44241019771415521500E-05, 6.00982861902849871600E-07, 2.14611541966231908200E-08, 
   6.70435999307504633400E-10, 1.86074527008731886600E-11, 4.64296589104966284700E-13, 1.05109058078120195880E-14, 
   2.17373506425627932200E-16, 4.12736258800510237200E-18, 7.22027572389545573000E-20, 1.16641031427122158000E-21, 
   1.74261574594878846800E-23, 2.40999131874158664000E-25, 3.08741471404781296800E-27, 3.66622899027160893300E-29, 
   4.03832398444680182100E-31, 4.12964092806000764200E-33, 3.92459969957984993300E-35, 3.47023698321199047400E-37, 
   2.85870037656881575800E-39, 2.19701222983622897200E-41, 1.57757442199878062800E-43, 1.05998290283581317870E-45, 
   6.67461794578944750100E-48, 3.94493775265477963400E-50, 2.19180590286711897200E-52, 1.14647284342367091100E-54, 
   5.65409064942635909000E-57, 2.63281413190197920300E-59, 1.15914855705146421000E-61, 4.83173813806023163900E-64, 
   1.90931412007029721900E-66, 7.16152712238209948300E-69, 2.55277823724126351900E-71, 8.65775632882397637500E-74, 
   2.79685049229469435800E-76, 8.61535752145576873700E-79, 2.53319381071928112300E-81, 7.11686161831786026200E-84, 
   1.91227899461300469000E-86, 4.91879425560043181900E-89, 1.21226578717106016000E-91, 2.86511260628508142200E-94},
  // 10: precision 1.46E-11
  {1.77245385087972342800E+00, 4.43113462419744630200E-01, 5.53891822321947835700E-02, 4.61576475266972634100E-03, 
   2.88485120632836570100E-04, 1.44242113476668549100E-05, 6.01001089101483108200E-07, 2.14633579957941871400E-08, 
   6.70638121912630560800E-10, 1.86219965341716152100E-11, 4.65139560168398521100E-13, 1.05511053035457485150E-14, 
   2.18978467579008781700E-16, 4.18179627467181890600E-18, 7.37905600609363562400E-20, 1.20666925770415139000E-21, 
   1.83216676939141016100E-23, 2.58616160243870388400E-25, 3.39612594393133643000E-27, 4.15117456105401982300E-29, 
   4.72512355800254106200E-31, 5.01108411105699264300E-33, 4.95452692086540934200E-35, 4.57052259669118191500E-37, 
   3.93757613394119041600E-39, 3.17143225730425447800E-41, 2.39087136989889684400E-43, 1.68918677399352864600E-45, 
   1.11992962513487784300E-47, 6.97720003652956407000E-50, 4.09017183052803247800E-52, 2.25925194899934230000E-54, 
   1.17743902383784437300E-56, 5.79751618317805258800E-59, 2.70049127204827368400E-61, 1.19150157862632851000E-63, 
   4.98581510751975724600E-66, 1.98102566456273457700E-68, 7.48277410614888503600E-71, 2.68994458637406843000E-73, 
   9.21308680313745922900E-76, 3.00957175301701607000E-78, 9.38604174484261857600E-81, 2.79745691952436047200E-83, 
   7.97548757616816228000E-86, 2.17700350714256603000E-88, 5.69442820814374326200E-91, 1.42855756885812751800E-93},
  // 11: precision 3.64E-12
  {1.77245385089906787700E+00, 4.43113462645337308000E-01, 5.53891826707801996000E-02, 4.61576509382801447000E-03, 
   2.88485262834342722100E-04, 1.44242482379506758200E-05, 6.01007615943023924400E-07, 2.14641957411498484200E-08, 
   6.70719685646245707700E-10, 1.86282265411023575000E-11, 4.65522856702499667400E-13, 1.05705070352080171380E-14, 
   2.19800647930093079100E-16, 4.21139261151871749000E-18, 7.47068213693802656400E-20, 1.23132525686457329000E-21, 
   1.89037080673535316000E-23, 2.70767450402634975900E-25, 3.62208731605653583200E-27, 4.52783644780645903400E-29, 
   5.29116794891083221600E-31, 5.78191926529856774600E-33, 5.91019131357709915300E-35, 5.65375339320520942200E-37, 
   5.06448494950527399600E-39, 4.25125004489814020300E-41, 3.34702040997479327500E-43, 2.47392597585772167100E-45, 
   1.71856809642179370600E-47, 1.12329116466680264100E-49, 6.91635006957699099400E-52, 4.01648185933072044700E-54, 
   2.20256743728563483200E-56, 1.14197705850825122000E-58, 5.60474946818590333800E-61, 2.60701847612354797700E-63, 
   1.15061401831998511400E-65, 4.82402847794291118400E-68, 1.92339714685666953300E-70, 7.30092195189691915600E-73, 
   2.64114863236683700200E-75, 9.11500639536260716600E-78, 3.00399043312000082200E-80, 9.46306767642663343000E-83, 
   2.85205432245625504600E-85, 8.23120145271503093200E-88, 2.27678649791096140000E-90, 6.04082678746563674000E-93},
  // 12: precision 9.09E-13
  {1.77245385090390399000E+00, 4.43113462705021723200E-01, 5.53891827935733966800E-02, 4.61576519490408572200E-03, 
   2.88485307416075940900E-04, 1.44242604760223605000E-05, 6.01009907022372119900E-07, 2.14645068933581115800E-08, 
   6.70751738699247757000E-10, 1.86308168994678478700E-11, 4.65691470353760117700E-13, 1.05795367138350319200E-14, 
   2.20205466324054638500E-16, 4.22680889851439179400E-18, 7.52117118137557251000E-20, 1.24569747014608843200E-21, 
   1.92626007811754286900E-23, 2.78693040917777943300E-25, 3.77798094465194860200E-27, 4.80270052176922369800E-29, 
   5.72806202403284098500E-31, 6.41118455649104110000E-33, 6.73530071235990996000E-35, 6.64287180769401900600E-37, 
   6.15272463485746774200E-39, 5.35401292372264035500E-41, 4.37964050507321407500E-43, 3.37013878900376065400E-45, 
   2.44151902553507999600E-47, 1.66674472552984171500E-49, 1.07324838386391679300E-51, 6.52532932562465070600E-54, 
   3.75007759408864456600E-56, 2.03933010598440151000E-58, 1.05056269424470639500E-60, 5.13240427502016103000E-63, 
   2.38044205354512290600E-65, 1.04929890842558070320E-67, 4.40052237815903136000E-70, 1.75760526644875492000E-72, 
   6.69249991110777975200E-75, 2.43182093294000139800E-77, 8.44044451319186471300E-80, 2.80086205952805676200E-82, 
   8.89407469263960473600E-85, 2.70501913533005623200E-87, 7.88617413146613817400E-90, 2.20568290007963387700E-92}};


// This template class combines two different random number generators
// for improved randomness. R1 and R2 are any two different random number
// generator classes.
template <class RG1, class RG2>
class TRandomCombined : private RG1, private RG2 {
  public:
  TRandomCombined(int32 seed = 19) : RG1(seed), RG2(seed+1) {};

  void RandomInit(int32 seed) {        // re-seed
    RG1::RandomInit(seed);
    RG2::RandomInit(seed+1);}

  double Random() {
    long double r = RG1::Random() + RG2::Random();
    if (r >= 1.) r -= 1.;
    return r;}
    
  long IRandom(long min, long max){       // output random integer
    // get integer random number in desired interval
    int iinterval = max - min + 1;
    if (iinterval <= 0) return -1; // error
    int i = int(iinterval * Random()); // truncate
    if (i >= iinterval) i = iinterval-1;
    return min + i;}};



#if (defined (__BORLANDC__) || defined (_MSC_VER)) && ! defined(_WINDOWS_)
  #include <conio.h>                   // define getch() function
  #define _GETCH_DEFINED_
#endif


/***********************************************************************
                     End of program
***********************************************************************/

void EndOfProgram() {
  // This function takes care of whatever is necessary to do when the 
  // program is finished

  // It may be necessary to wait for the user to press a key
  // in order to prevent the output window from disappearing.
  // Remove the #ifdef and #endif lines to unconditionally wait for a key press;
  // Remove all three lines to not wait:
  #ifdef _GETCH_DEFINED_
  getch();                             // wait for user to press a key
  #endif

  // It may be necessary to end the program with a linefeed:
  #if defined (__unix__) || defined (_MSC_VER)
  printf("\n");                        // end program with a linefeed
  #endif

  }


/***********************************************************************
                     Error message function
***********************************************************************/

void FatalError(char * ErrorText) {
  // This function outputs an error message and aborts the program.

  // Important: There is no universally portable way of outputting an 
  // error message. You may have to modify this function to output
  // the error message in a way that is appropriate for your system.


  // Check if FatalAppExit exists (this macro is defined in winbase.h)
  #ifdef FatalAppExit  

  // in Windows, use FatalAppExit:
  FatalAppExit(0, ErrorText);

  #else

  // in console mode, print error message  
  printf ("\n%s\n", ErrorText);
  EndOfProgram();

  #endif

  // Terminate program with error code
  exit(1);}


void CRandomMersenne::Init0(uint32 seed) {
   // Detect computer architecture
   union {double f; uint32 i[2];} convert;
   convert.f = 1.0;
   if (convert.i[1] == 0x3FF00000) Architecture = LITTLE_ENDIAN1;
   else if (convert.i[0] == 0x3FF00000) Architecture = BIG_ENDIAN1;
   else Architecture = NONIEEE;

   // Seed generator
   mt[0]= seed;
   for (mti=1; mti < MERS_N; mti++) {
      mt[mti] = (1812433253UL * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);
   }
}

void CRandomMersenne::RandomInit(uint32 seed) {
   // Initialize and seed
   Init0(seed);

   // Randomize some more
   for (int i = 0; i < 37; i++) BRandom();
}


void CRandomMersenne::RandomInitByArray(uint32 seeds[], int length) {
   // Seed by more than 32 bits
   int i, j, k;

   // Initialize
   Init0(19650218);

   if (length <= 0) return;

   // Randomize mt[] using whole seeds[] array
   i = 1;  j = 0;
   k = (MERS_N > length ? MERS_N : length);
   for (; k; k--) {
      mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525UL)) + seeds[j] + j;
      i++; j++;
      if (i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}
      if (j >= length) j=0;}
   for (k = MERS_N-1; k; k--) {
      mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941UL)) - i;
      if (++i >= MERS_N) {mt[0] = mt[MERS_N-1]; i=1;}}
   mt[0] = 0x80000000UL;  // MSB is 1; assuring non-zero initial array

   // Randomize some more
   mti = 0;
   for (int i = 0; i <= MERS_N; i++) BRandom();
}


uint32 CRandomMersenne::BRandom() {
   // Generate 32 random bits
   uint32 y;

   if (mti >= MERS_N) {
      // Generate MERS_N words at one time
      const uint32 LOWER_MASK = (1LU << MERS_R) - 1;       // Lower MERS_R bits
      const uint32 UPPER_MASK = 0xFFFFFFFF << MERS_R;      // Upper (32 - MERS_R) bits
      static const uint32 mag01[2] = {0, MERS_A};

      int kk;
      for (kk=0; kk < MERS_N-MERS_M; kk++) {    
         y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);
         mt[kk] = mt[kk+MERS_M] ^ (y >> 1) ^ mag01[y & 1];}

      for (; kk < MERS_N-1; kk++) {    
         y = (mt[kk] & UPPER_MASK) | (mt[kk+1] & LOWER_MASK);
         mt[kk] = mt[kk+(MERS_M-MERS_N)] ^ (y >> 1) ^ mag01[y & 1];}      

      y = (mt[MERS_N-1] & UPPER_MASK) | (mt[0] & LOWER_MASK);
      mt[MERS_N-1] = mt[MERS_M-1] ^ (y >> 1) ^ mag01[y & 1];
      mti = 0;
   }

   y = mt[mti++];

#if 1
   // Tempering (May be omitted):
   y ^=  y >> MERS_U;
   y ^= (y << MERS_S) & MERS_B;
   y ^= (y << MERS_T) & MERS_C;
   y ^=  y >> MERS_L;
#endif

   return y;
}


double CRandomMersenne::Random() {
   // Output random float number in the interval 0 <= x < 1
   union {double f; uint32 i[2];} convert;
   uint32 r = BRandom();               // Get 32 random bits
   // The fastest way to convert random bits to floating point is as follows:
   // Set the binary exponent of a floating point number to 1+bias and set
   // the mantissa to random bits. This will give a random number in the 
   // interval [1,2). Then subtract 1.0 to get a random number in the interval
   // [0,1). This procedure requires that we know how floating point numbers
   // are stored. The storing method is tested in function RandomInit and saved 
   // in the variable Architecture.

   // This shortcut allows the compiler to optimize away the following switch
   // statement for the most common architectures:
#if defined(_M_IX86) || defined(_M_X64) || defined(__LITTLE_ENDIAN__)
   Architecture = LITTLE_ENDIAN1;
#elif defined(__BIG_ENDIAN__)
   Architecture = BIG_ENDIAN1;
#endif

   switch (Architecture) {
   case LITTLE_ENDIAN1:
      convert.i[0] =  r << 20;
      convert.i[1] = (r >> 12) | 0x3FF00000;
      return convert.f - 1.0;
   case BIG_ENDIAN1:
      convert.i[1] =  r << 20;
      convert.i[0] = (r >> 12) | 0x3FF00000;
      return convert.f - 1.0;
   case NONIEEE: default: ;
   } 
   // This somewhat slower method works for all architectures, including 
   // non-IEEE floating point representation:
   return (double)r * (1./((double)(uint32)(-1L)+1.));
}


int CRandomMersenne::IRandom(int min, int max) {
   // Output random integer in the interval min <= x <= max
   // Relative error on frequencies < 2^-32
   if (max <= min) {
      if (max == min) return min; else return 0x80000000;
   }
   // Multiply interval with random and truncate
   int r = int((max - min + 1) * Random()) + min; 
   if (r > max) r = max;
   return r;
}


int CRandomMersenne::IRandomX(int min, int max) {
   // Output random integer in the interval min <= x <= max
   // Each output value has exactly the same probability.
   // This is obtained by rejecting certain bit values so that the number
   // of possible bit values is divisible by the interval length
   if (max <= min) {
      if (max == min) return min; else return 0x80000000;
   }
#ifdef  INT64_DEFINED
   // 64 bit integers available. Use multiply and shift method
   uint32 interval;                    // Length of interval
   uint64 longran;                     // Random bits * interval
   uint32 iran;                        // Longran / 2^32
   uint32 remainder;                   // Longran % 2^32

   interval = uint32(max - min + 1);
   if (interval != LastInterval) {
      // Interval length has changed. Must calculate rejection limit
      // Reject when remainder = 2^32 / interval * interval
      // RLimit will be 0 if interval is a power of 2. No rejection then
      RLimit = uint32(((uint64)1 << 32) / interval) * interval - 1;
      LastInterval = interval;
   }
   do { // Rejection loop
      longran  = (uint64)BRandom() * interval;
      iran = (uint32)(longran >> 32);
      remainder = (uint32)longran;
   } while (remainder > RLimit);
   // Convert back to signed and return result
   return (int32)iran + min;

#else
   // 64 bit integers not available. Use modulo method
   uint32 interval;                    // Length of interval
   uint32 bran;                        // Random bits
   uint32 iran;                        // bran / interval
   uint32 remainder;                   // bran % interval

   interval = uint32(max - min + 1);
   if (interval != LastInterval) {
      // Interval length has changed. Must calculate rejection limit
      // Reject when iran = 2^32 / interval
      // We can't make 2^32 so we use 2^32-1 and correct afterwards
      RLimit = (uint32)0xFFFFFFFF / interval;
      if ((uint32)0xFFFFFFFF % interval == interval - 1) RLimit++;
   }
   do { // Rejection loop
      bran = BRandom();
      iran = bran / interval;
      remainder = bran % interval;
   } while (iran >= RLimit);
   // Convert back to signed and return result
   return (int32)remainder + min;

#endif
}



/***********************************************************************
constants
***********************************************************************/
const double SHAT1 = 2.943035529371538573;    // 8/e
const double SHAT2 = 0.8989161620588987408;   // 3-sqrt(12/e)


/***********************************************************************
Log factorial function
***********************************************************************/
double LnFac(int32 n) {
   // log factorial function. gives natural logarithm of n!

   // define constants
   static const double                 // coefficients in Stirling approximation     
      C0 =  0.918938533204672722,      // ln(sqrt(2*pi))
      C1 =  1./12., 
      C3 = -1./360.;
   // C5 =  1./1260.,                  // use r^5 term if FAK_LEN < 50
   // C7 = -1./1680.;                  // use r^7 term if FAK_LEN < 20
   // static variables
   static double fac_table[FAK_LEN];   // table of ln(n!):
   static int initialized = 0;         // remember if fac_table has been initialized

   if (n < FAK_LEN) {
      if (n <= 1) {
         if (n < 0) FatalError("Parameter negative in LnFac function");  
         return 0;
      }
      if (!initialized) {              // first time. Must initialize table
         // make table of ln(n!)
         double sum = fac_table[0] = 0.;
         for (int i=1; i<FAK_LEN; i++) {
            sum += log(double(i));
            fac_table[i] = sum;
         }
         initialized = 1;
      }
      return fac_table[n];
   }
   // not found in table. use Stirling approximation
   double  n1, r;
   n1 = n;  r  = 1. / n1;
   return (n1 + 0.5)*log(n1) - n1 + C0 + r*(C1 + r*r*C3);
}


/***********************************************************************
Constructor
***********************************************************************/
StochasticLib1::StochasticLib1 (int seed)
: STOC_BASE(seed) {
   // Initialize variables for various distributions
   normal_x2_valid = 0;
   hyp_n_last = hyp_m_last = hyp_N_last = -1; // Last values of hypergeometric parameters
   pois_L_last = -1.;                         // Last values of Poisson parameters
   bino_n_last = -1;  bino_p_last = -1.;      // Last values of binomial parameters
}


/***********************************************************************
Hypergeometric distribution
***********************************************************************/
int32 StochasticLib1::Hypergeometric (int32 n, int32 m, int32 N) {
   /*
   This function generates a random variate with the hypergeometric
   distribution. This is the distribution you get when drawing balls without 
   replacement from an urn with two colors. n is the number of balls you take,
   m is the number of red balls in the urn, N is the total number of balls in 
   the urn, and the return value is the number of red balls you get.

   This function uses inversion by chop-down search from the mode when
   parameters are small, and the ratio-of-uniforms method when the former
   method would be too slow or would give overflow.
   */   

   int32 fak, addd;                    // used for undoing transformations
   int32 x;                            // result

   // check if parameters are valid
   if (n > N || m > N || n < 0 || m < 0) {
      FatalError("Parameter out of range in hypergeometric function");}

   // symmetry transformations
   fak = 1;  addd = 0;
   if (m > N/2) {
      // invert m
      m = N - m;
      fak = -1;  addd = n;
   }    
   if (n > N/2) {
      // invert n
      n = N - n;
      addd += fak * m;  fak = - fak;
   }    
   if (n > m) {
      // swap n and m
      x = n;  n = m;  m = x;
   }    
   // cases with only one possible result end here
   if (n == 0)  return addd;

   //------------------------------------------------------------------
   //                 choose method
   //------------------------------------------------------------------
   if (N > 680 || n > 70) {
      // use ratio-of-uniforms method
      x = HypRatioOfUnifoms (n, m, N);
   }
   else {
      // inversion method, using chop-down search from mode
      x = HypInversionMod (n, m, N);
   }
   // undo symmetry transformations  
   return x * fak + addd;
}


/***********************************************************************
Subfunctions used by hypergeometric
***********************************************************************/

int32 StochasticLib1::HypInversionMod (int32 n, int32 m, int32 N) {
   /* 
   Subfunction for Hypergeometric distribution. Assumes 0 <= n <= m <= N/2.
   Overflow protection is needed when N > 680 or n > 75.

   Hypergeometric distribution by inversion method, using down-up 
   search starting at the mode using the chop-down technique.

   This method is faster than the rejection method when the variance is low.
   */

   // Sampling 
   int32         I;                    // Loop counter
   int32         L = N - m - n;        // Parameter
   double        modef;                // mode, float
   double        Mp, np;               // m + 1, n + 1
   double        p;                    // temporary
   double        U;                    // uniform random
   double        c, d;                 // factors in iteration
   double        divisor;              // divisor, eliminated by scaling
   double        k1, k2;               // float version of loop counter
   double        L1 = L;               // float version of L

   Mp = (double)(m + 1);
   np = (double)(n + 1);

   if (N != hyp_N_last || m != hyp_m_last || n != hyp_n_last) {
      // set-up when parameters have changed
      hyp_N_last = N;  hyp_m_last = m;  hyp_n_last = n;

      p  = Mp / (N + 2.);
      modef = np * p;                       // mode, real
      hyp_mode = (int32)modef;                // mode, integer
      if (hyp_mode == modef && p == 0.5) {   
         hyp_mp = hyp_mode--;
      }
      else {
         hyp_mp = hyp_mode + 1;
      }
      // mode probability, using log factorial function
      // (may read directly from fac_table if N < FAK_LEN)
      hyp_fm = exp(LnFac(N-m) - LnFac(L+hyp_mode) - LnFac(n-hyp_mode)
         + LnFac(m)   - LnFac(m-hyp_mode) - LnFac(hyp_mode)
         - LnFac(N)   + LnFac(N-n)      + LnFac(n)        );

      // safety bound - guarantees at least 17 significant decimal digits
      // bound = min(n, (int32)(modef + k*c'))
      hyp_bound = (int32)(modef + 11. * sqrt(modef * (1.-p) * (1.-n/(double)N)+1.));
      if (hyp_bound > n) hyp_bound = n;
   }

   // loop until accepted
   while(1) {
      U = Random();                    // uniform random number to be converted

      // start chop-down search at mode
      if ((U -= hyp_fm) <= 0.) return(hyp_mode);
      c = d = hyp_fm;

      // alternating down- and upward search from the mode
      k1 = hyp_mp - 1;  k2 = hyp_mode + 1;
      for (I = 1; I <= hyp_mode; I++, k1--, k2++) {
         // Downward search from k1 = hyp_mp - 1
         divisor = (np - k1)*(Mp - k1);
         // Instead of dividing c with divisor, we multiply U and d because 
         // multiplication is faster. This will give overflow if N > 800
         U *= divisor;  d *= divisor;
         c *= k1 * (L1 + k1);
         if ((U -= c) <= 0.)  return(hyp_mp - I - 1); // = k1 - 1

         // Upward search from k2 = hyp_mode + 1
         divisor = k2 * (L1 + k2);
         // re-scale parameters to avoid time-consuming division
         U *= divisor;  c *= divisor; 
         d *= (np - k2) * (Mp - k2);
         if ((U -= d) <= 0.)  return(hyp_mode + I);  // = k2
         // Values of n > 75 or N > 680 may give overflow if you leave out this..
         // overflow protection
         // if (U > 1.E100) {U *= 1.E-100; c *= 1.E-100; d *= 1.E-100;}
      }

      // Upward search from k2 = 2*mode + 1 to bound
      for (k2 = I = hyp_mp + hyp_mode; I <= hyp_bound; I++, k2++) {
         divisor = k2 * (L1 + k2);
         U *= divisor;
         d *= (np - k2) * (Mp - k2);
         if ((U -= d) <= 0.)  return(I);
         // more overflow protection
         // if (U > 1.E100) {U *= 1.E-100; d *= 1.E-100;}
      }
   }
}


int32 StochasticLib1::HypRatioOfUnifoms (int32 n, int32 m, int32 N) {
   /*
   Subfunction for Hypergeometric distribution using the ratio-of-uniforms
   rejection method.

   This code is valid for 0 < n <= m <= N/2.

   The computation time hardly depends on the parameters, except that it matters
   a lot whether parameters are within the range where the LnFac function is
   tabulated.

   Reference: E. Stadlober: "The ratio of uniforms approach for generating
   discrete random variates". Journal of Computational and Applied Mathematics,
   vol. 31, no. 1, 1990, pp. 181-189.
   */
   int32 L;                            // N-m-n
   int32 mode;                         // mode
   int32 k;                            // integer sample
   double x;                           // real sample
   double rNN;                         // 1/(N*(N+2))
   double my;                          // mean
   double var;                         // variance
   double u;                           // uniform random
   double lf;                          // ln(f(x))

   L = N - m - n;
   if (hyp_N_last != N || hyp_m_last != m || hyp_n_last != n) {
      hyp_N_last = N;  hyp_m_last = m;  hyp_n_last = n;            // Set-up
      rNN = 1. / ((double)N*(N+2));                          // make two divisions in one
      my = (double)n * m * rNN * (N+2);                      // mean = n*m/N
      mode = (int32)(double(n+1) * double(m+1) * rNN * N);   // mode = floor((n+1)*(m+1)/(N+2))
      var = (double)n * m * (N-m) * (N-n) / ((double)N*N*(N-1)); // variance
      hyp_h = sqrt(SHAT1 * (var+0.5)) + SHAT2;                 // hat width
      hyp_a = my + 0.5;                                        // hat center
      hyp_fm = fc_lnpk(mode, L, m, n);                          // maximum
      hyp_bound = (int32)(hyp_a + 4.0 * hyp_h);                    // safety-bound
      if (hyp_bound > n) hyp_bound = n;
   }    
   while(1) {
      u = Random();                                          // uniform random number
      if (u == 0) continue;                                  // avoid division by 0
      x = hyp_a + hyp_h * (Random()-0.5) / u;                    // generate hat distribution
      if (x < 0. || x > 2E9) continue;                       // reject, avoid overflow
      k = (int32)x;
      if (k > hyp_bound) continue;                             // reject if outside range
      lf = hyp_fm - fc_lnpk(k,L,m,n);                           // ln(f(k))
      if (u * (4.0 - u) - 3.0 <= lf) break;                  // lower squeeze accept
      if (u * (u-lf) > 1.0) continue;                        // upper squeeze reject
      if (2.0 * log(u) <= lf) break;                         // final acceptance
   }
   return k;
}


double StochasticLib1::fc_lnpk(int32 k, int32 L, int32 m, int32 n) {
   // subfunction used by hypergeometric and Fisher's noncentral hypergeometric distribution
   return(LnFac(k) + LnFac(m - k) + LnFac(n - k) + LnFac(L + k));
}


#ifndef R_BUILD          // Not needed if making R interface

/***********************************************************************
Multivariate hypergeometric distribution
***********************************************************************/
void StochasticLib1::MultiHypergeometric (int32 * destination, int32 * source, int32 n, int colors) {
   /*
   This function generates a vector of random variates, each with the
   hypergeometric distribution.

   The multivariate hypergeometric distribution is the distribution you 
   get when drawing balls from an urn with more than two colors, without
   replacement.

   Parameters:
   destination:    An output array to receive the number of balls of each 
   color. Must have space for at least 'colors' elements.
   source:         An input array containing the number of balls of each 
   color in the urn. Must have 'colors' elements.
   All elements must be non-negative.
   n:              The number of balls drawn from the urn.
   Can't exceed the total number of balls in the urn.
   colors:         The number of possible colors. 
   */
   int32 sum, x, y;
   int i;
   if (n < 0 || colors < 0) FatalError("Parameter negative in multihypergeo function");
   if (colors == 0) return;

   // compute total number of balls
   for (i=0, sum=0; i<colors; i++) { 
      y = source[i];
      if (y < 0) FatalError("Parameter negative in multihypergeo function");
      sum += y;
   }
   if (n > sum) FatalError("n > sum in multihypergeo function");

   for (i=0; i<colors-1; i++) { 
      // generate output by calling hypergeometric colors-1 times
      y = source[i];
      x = Hypergeometric(n, y, sum);
      n -= x; sum -= y;
      destination[i] = x;
   }
   // get the last one
   destination[i] = n;
}


/***********************************************************************
Poisson distribution
***********************************************************************/
int32 StochasticLib1::Poisson (double L) {
   /*
   This function generates a random variate with the poisson distribution.

   Uses inversion by chop-down method for L < 17, and ratio-of-uniforms
   method for L >= 17.

   For L < 1.E-6 numerical inaccuracy is avoided by direct calculation.
   */

   //------------------------------------------------------------------
   //                 choose method
   //------------------------------------------------------------------
   if (L < 17) {
      if (L < 1.E-6) {
         if (L == 0) return 0;
         if (L < 0) FatalError("Parameter negative in poisson function");

         //--------------------------------------------------------------
         // calculate probabilities
         //--------------------------------------------------------------
         // For extremely small L we calculate the probabilities of x = 1
         // and x = 2 (ignoring higher x). The reason for using this 
         // method is to prevent numerical inaccuracies in other methods.
         //--------------------------------------------------------------
         return PoissonLow(L);
      }    
      else {
         //--------------------------------------------------------------
         // inversion method
         //--------------------------------------------------------------
         // The computation time for this method grows with L.
         // Gives overflow for L > 80
         //--------------------------------------------------------------
         return PoissonInver(L);
      }
   }      
   else {
      if (L > 2.E9) FatalError("Parameter too big in poisson function");

      //----------------------------------------------------------------
      // ratio-of-uniforms method
      //----------------------------------------------------------------
      // The computation time for this method does not depend on L.
      // Use where other methods would be slower.
      //----------------------------------------------------------------
      return PoissonRatioUniforms(L);
   }
}


/***********************************************************************
Subfunctions used by poisson
***********************************************************************/
int32 StochasticLib1::PoissonLow(double L) {
   /*
   This subfunction generates a random variate with the poisson 
   distribution for extremely low values of L.

   The method is a simple calculation of the probabilities of x = 1
   and x = 2. Higher values are ignored.

   The reason for using this method is to avoid the numerical inaccuracies 
   in other methods.
   */   
   double d, r;
   d = sqrt(L);
   if (Random() >= d) return 0;
   r = Random() * d;
   if (r > L * (1.-L)) return 0;
   if (r > 0.5 * L*L * (1.-L)) return 1;
   return 2;
}


int32 StochasticLib1::PoissonInver(double L) {
   /*
   This subfunction generates a random variate with the poisson 
   distribution using inversion by the chop down method (PIN).

   Execution time grows with L. Gives overflow for L > 80.

   The value of bound must be adjusted to the maximal value of L.
   */   
   const int bound = 130;              // safety bound. Must be > L + 8*sqrt(L).
   double r;                           // uniform random number
   double f;                           // function value
   int32 x;                            // return value

   if (L != pois_L_last) {             // set up
      pois_L_last = L;
      pois_f0 = exp(-L);               // f(0) = probability of x=0
   }
   while (1) {  
      r = Random();  x = 0;  f = pois_f0;
      do {                             // recursive calculation: f(x) = f(x-1) * L / x
         r -= f;
         if (r <= 0) return x;
         x++;
         f *= L;
         r *= x;                       // instead of f /= x
      }
      while (x <= bound);
   }
}  


int32 StochasticLib1::PoissonRatioUniforms(double L) {
   /*
   This subfunction generates a random variate with the poisson 
   distribution using the ratio-of-uniforms rejection method (PRUAt).

   Execution time does not depend on L, except that it matters whether L
   is within the range where ln(n!) is tabulated.

   Reference: E. Stadlober: "The ratio of uniforms approach for generating
   discrete random variates". Journal of Computational and Applied Mathematics,
   vol. 31, no. 1, 1990, pp. 181-189.
   */
   double u;                                          // uniform random
   double lf;                                         // ln(f(x))
   double x;                                          // real sample
   int32 k;                                           // integer sample

   if (pois_L_last != L) {
      pois_L_last = L;                                // Set-up
      pois_a = L + 0.5;                               // hat center
      int32 mode = (int32)L;                          // mode
      pois_g  = log(L);
      pois_f0 = mode * pois_g - LnFac(mode);          // value at mode
      pois_h = sqrt(SHAT1 * (L+0.5)) + SHAT2;         // hat width
      pois_bound = (int32)(pois_a + 6.0 * pois_h);    // safety-bound
   }
   while(1) {
      u = Random();
      if (u == 0) continue;                           // avoid division by 0
      x = pois_a + pois_h * (Random() - 0.5) / u;
      if (x < 0 || x >= pois_bound) continue;         // reject if outside valid range
      k = (int32)(x);
      lf = k * pois_g - LnFac(k) - pois_f0;
      if (lf >= u * (4.0 - u) - 3.0) break;           // quick acceptance
      if (u * (u - lf) > 1.0) continue;               // quick rejection
      if (2.0 * log(u) <= lf) break;                  // final acceptance
   }
   return(k);
}


/***********************************************************************
Binomial distribution
***********************************************************************/
int32 StochasticLib1::Binomial (int32 n, double p) {
   /*
   This function generates a random variate with the binomial distribution.

   Uses inversion by chop-down method for n*p < 35, and ratio-of-uniforms
   method for n*p >= 35.

   For n*p < 1.E-6 numerical inaccuracy is avoided by poisson approximation.
   */
   int inv = 0;                        // invert
   int32 x;                            // result
   double np = n * p;

   if (p > 0.5) {                      // faster calculation by inversion
      p = 1. - p;  inv = 1;
   }
   if (n <= 0 || p <= 0) {
      if (n == 0 || p == 0) return inv * n;  // only one possible result
      FatalError("Parameter out of range in binomial function"); // error exit
   }

   //------------------------------------------------------------------
   //                 choose method
   //------------------------------------------------------------------
   if (np < 35.) {
      if (np < 1.E-6) {
         // Poisson approximation for extremely low np
         x = PoissonLow(np);
      }
      else {
         // inversion method, using chop-down search from 0
         x = BinomialInver(n, p);
      }
   }  
   else {
      // ratio of uniforms method
      x = BinomialRatioOfUniforms(n, p);
   }
   if (inv) {
      x = n - x;      // undo inversion
   }
   return x;
}


/***********************************************************************
Subfunctions used by binomial
***********************************************************************/

int32 StochasticLib1::BinomialInver (int32 n, double p) {
   /* 
   Subfunction for Binomial distribution. Assumes p < 0.5.

   Uses inversion method by search starting at 0.

   Gives overflow for n*p > 60.

   This method is fast when n*p is low. 
   */   
   double f0, f, q; 
   int32 bound;
   double pn, r, rc; 
   int32 x, n1, i;

   // f(0) = probability of x=0 is (1-p)^n
   // fast calculation of (1-p)^n
   f0 = 1.;  pn = 1.-p;  n1 = n;
   while (n1) {
      if (n1 & 1) f0 *= pn;
      pn *= pn;  n1 >>= 1;
   }
   // calculate safety bound
   rc = (n + 1) * p;
   bound = (int32)(rc + 11.0*(sqrt(rc) + 1.0));
   if (bound > n) bound = n; 
   q = p / (1. - p);

   while (1) {
      r = Random();
      // recursive calculation: f(x) = f(x-1) * (n-x+1)/x*p/(1-p)
      f = f0;  x = 0;  i = n;
      do {
         r -= f;
         if (r <= 0) return x;
         x++;
         f *= q * i;
         r *= x;       // it is faster to multiply r by x than dividing f by x
         i--;
      }
      while (x <= bound);
   }
}


int32 StochasticLib1::BinomialRatioOfUniforms (int32 n, double p) {
   /* 
   Subfunction for Binomial distribution. Assumes p < 0.5.

   Uses the Ratio-of-Uniforms rejection method.

   The computation time hardly depends on the parameters, except that it matters
   a lot whether parameters are within the range where the LnFac function is 
   tabulated.

   Reference: E. Stadlober: "The ratio of uniforms approach for generating
   discrete random variates". Journal of Computational and Applied Mathematics,
   vol. 31, no. 1, 1990, pp. 181-189.
   */   
   double u;                           // uniform random
   double q1;                          // 1-p
   double np;                          // n*p
   double var;                         // variance
   double lf;                          // ln(f(x))
   double x;                           // real sample
   int32 k;                            // integer sample

   if(bino_n_last != n || bino_p_last != p) {      // Set_up
      bino_n_last = n;
      bino_p_last = p;
      q1 = 1.0 - p;
      np = n * p;
      bino_mode = (int32)(np + p);              // mode
      bino_a = np + 0.5;                        // hat center
      bino_r1 = log(p / q1);
      bino_g = LnFac(bino_mode) + LnFac(n-bino_mode);
      var = np * q1;                         // variance
      bino_h = sqrt(SHAT1 * (var+0.5)) + SHAT2; // hat width
      bino_bound = (int32)(bino_a + 6.0 * bino_h);    // safety-bound
      if (bino_bound > n) bino_bound = n;          // safety-bound
   }

   while (1) {                               // rejection loop
      u = Random();
      if (u == 0) continue;                  // avoid division by 0
      x = bino_a + bino_h * (Random() - 0.5) / u;
      if (x < 0. || x > bino_bound) continue;   // reject, avoid overflow
      k = (int32)x;                          // truncate
      lf = (k-bino_mode)*bino_r1+bino_g-LnFac(k)-LnFac(n-k);// ln(f(k))
      if (u * (4.0 - u) - 3.0 <= lf) break;  // lower squeeze accept
      if (u * (u - lf) > 1.0) continue;      // upper squeeze reject
      if (2.0 * log(u) <= lf) break;         // final acceptance
   }
   return k;
}


/***********************************************************************
Multinomial distribution
***********************************************************************/
void StochasticLib1::Multinomial (int32 * destination, double * source, int32 n, int colors) {
   /*
   This function generates a vector of random variates, each with the
   binomial distribution.

   The multinomial distribution is the distribution you get when drawing
   balls from an urn with more than two colors, with replacement.

   Parameters:
   destination:    An output array to receive the number of balls of each 
   color. Must have space for at least 'colors' elements.
   source:         An input array containing the probability or fraction 
   of each color in the urn. Must have 'colors' elements.
   All elements must be non-negative. The sum doesn't have
   to be 1, but the sum must be positive.
   n:              The number of balls drawn from the urn.                   
   colors:         The number of possible colors. 
   */
   double s, sum;
   int32 x;
   int i;
   if (n < 0 || colors < 0) FatalError("Parameter negative in multinomial function");
   if (colors == 0) return;

   // compute sum of probabilities
   for (i=0, sum=0; i<colors; i++) { 
      s = source[i];
      if (s < 0) FatalError("Parameter negative in multinomial function");
      sum += s;
   }
   if (sum == 0 && n > 0) FatalError("Zero sum in multinomial function");

   for (i=0; i<colors-1; i++) { 
      // generate output by calling binomial (colors-1) times
      s = source[i];
      if (sum <= s) {
         // this fixes two problems:
         // 1. prevent division by 0 when sum = 0
         // 2. prevent s/sum getting bigger than 1 in case of rounding errors
         x = n;
      }
      else {    
         x = Binomial(n, s/sum);
      }
      n -= x; sum -= s;
      destination[i] = x;
   }
   // get the last one
   destination[i] = n;
}


void StochasticLib1::Multinomial (int32 * destination, int32 * source, int32 n, int colors) {
   // same as above, with integer source
   int32 x, p, sum;
   int i;
   if (n < 0 || colors < 0) FatalError("Parameter negative in multinomial function");
   if (colors == 0) return;

   // compute sum of probabilities
   for (i=0, sum=0; i<colors; i++) { 
      p = source[i];
      if (p < 0) FatalError("Parameter negative in multinomial function");
      sum += p;
   }
   if (sum == 0 && n > 0) FatalError("Zero sum in multinomial function");

   for (i=0; i<colors-1; i++) { 
      // generate output by calling binomial (colors-1) times
      if (sum == 0) {
         destination[i] = 0; continue;
      }
      p = source[i];
      x = Binomial(n, (double)p/sum);
      n -= x; sum -= p;
      destination[i] = x;
   }
   // get the last one
   destination[i] = n;
}


/***********************************************************************
Normal distribution
***********************************************************************/

double StochasticLib1::Normal(double m, double s) {
   // normal distribution with mean m and standard deviation s
   double normal_x1;                   // first random coordinate (normal_x2 is member of class)
   double w;                           // radius
   if (normal_x2_valid) {              // we have a valid result from last call
      normal_x2_valid = 0;
      return normal_x2 * s + m;
   }    
   // make two normally distributed variates by Box-Muller transformation
   do {
      normal_x1 = 2. * Random() - 1.;
      normal_x2 = 2. * Random() - 1.;
      w = normal_x1*normal_x1 + normal_x2*normal_x2;
   }
   while (w >= 1. || w < 1E-30);
   w = sqrt(log(w)*(-2./w));
   normal_x1 *= w;  normal_x2 *= w;    // normal_x1 and normal_x2 are independent normally distributed variates
   normal_x2_valid = 1;                // save normal_x2 for next call
   return normal_x1 * s + m;
}


/***********************************************************************
Bernoulli distribution
***********************************************************************/
int StochasticLib1::Bernoulli(double p) {
   // Bernoulli distribution with parameter p. This function returns 
   // 0 or 1 with probability (1-p) and p, respectively.
   if (p < 0 || p > 1) FatalError("Parameter out of range in Bernoulli function");
   return Random() < p;
}


/***********************************************************************
Shuffle function
***********************************************************************/
void StochasticLib1::Shuffle(int * list, int min, int n) {
   /*
   This function makes a list of the n numbers from min to min+n-1
   in random order.

   The parameter 'list' must be an array with at least n elements.
   The array index goes from 0 to n-1.

   If you want to shuffle something else than integers then use the 
   integers in list as an index into a table of the items you want to shuffle.
   */

   int i, j, swap;
   // put numbers from min to min+n-1 into list
   for (i=0, j=min; i<n; i++, j++) list[i] = j;
   // shuffle list
   for (i=0; i<n-1; i++) {
      // item number i has n-i numbers to choose between
      j = IRandom(i,n-1);
      // swap items i and j
      swap = list[j];  list[j] = list[i];  list[i] = swap;
   }
}

#endif  // ifndef R_BUILD



/***********************************************************************
constants
***********************************************************************/
static const double LN2 = 0.693147180559945309417; // log(2)


/***********************************************************************
Log and Exp functions with special care for small x
***********************************************************************/
// These are functions that involve expressions of the types log(1+x)
// and exp(x)-1.  Use library functions log1p and expm1 if available,
// otherwise, use Taylor expansions

#if defined(__GNUC__) || defined (__INTEL_COMPILER) || defined(HAVE_EXPM1)
// Functions log1p(x) = log(1+x) and expm1(x) = exp(x)-1 are available
// in the math libraries of Gnu and Intel compilers
// and in R.DLL (www.r-project.org).

double pow2_1(double q, double * y0 = 0) {
   // calculate 2^q and (1-2^q) without loss of precision.
   // return value is (1-2^q). 2^q is returned in *y0
   double y, y1;
   q *= LN2;
   if (fabs(q) > 0.1) {
      y = exp(q);                      // 2^q
      y1 = 1. - y;                     // 1-2^q
   }
   else { // Use expm1
      y1 = expm1(q);                   // 2^q-1
      y = y1 + 1;                      // 2^q
      y1 = -y1;                        // 1-2^q
   }
   if (y0) *y0 = y;                    // Return y if not void pointer
   return y1;                          // Return y1
}

double log1mx(double x, double x1) {
   // Calculate log(1-x) without loss of precision when x is small.
   // Parameter x1 must be = 1-x.
   if (fabs(x) > 0.03) {
      return log(x1);
   }
   else { // use log1p(x) = log(1+x)
      return log1p(-x);
   }
}

double log1pow(double q, double x) {
   // calculate log((1-e^q)^x) without loss of precision.
   // Combines the methods of the above two functions.
   double y, y1;

   if (fabs(q) > 0.1) {
      y = exp(q);                      // e^q
      y1 = 1. - y;                     // 1-e^q
   }
   else { // Use expm1
      y1 = expm1(q);                   // e^q-1
      y = y1 + 1;                      // e^q
      y1 = -y1;                        // 1-e^q
   }

   if (y > 0.1) { // (1-y)^x calculated without problem
      return x * log(y1);
   }
   else { // Use log1p
      return x * log1p(-y);
   }
}

#else
// (3)
// Functions log1p and expm1 are not available in MS and Borland compiler
// libraries. Use explicit Taylor expansion when needed.

double pow2_1(double q, double * y0 = 0) {
   // calculate 2^q and (1-2^q) without loss of precision.
   // return value is (1-2^q). 2^q is returned in *y0
   double y, y1, y2, qn, i, ifac;
   q *= LN2;
   if (fabs(q) > 0.1) {
      y = exp(q);
      y1 = 1. - y;
   }
   else { // expand 1-e^q = -summa(q^n/n!) to avoid loss of precision
      y1 = 0;  qn = i = ifac = 1;
      do {
         y2 = y1;
         qn *= q;  ifac *= i++;
         y1 -= qn / ifac;
      }
      while (y1 != y2);
      y = 1.-y1;
   }
   if (y0) *y0 = y;
   return y1;
}

double log1mx(double x, double x1) {
   // Calculate log(1-x) without loss of precision when x is small.
   // Parameter x1 must be = 1-x.
   if (fabs(x) > 0.03) {
      return log(x1);
   }
   else { // expand ln(1-x) = -summa(x^n/n)
      double y, z1, z2, i;
      y = i = 1.;  z1 = 0;
      do {
         z2 = z1;
         y *= x;
         z1 -= y / i++;
      }
      while (z1 != z2);
      return z1;
   }
}

double log1pow(double q, double x) {
   // calculate log((1-e^q)^x) without loss of precision
   // Uses various Taylor expansions to avoid loss of precision
   double y, y1, y2, z1, z2, qn, i, ifac;

   if (fabs(q) > 0.1) {
      y = exp(q);  y1 = 1. - y;
   }
   else { // expand 1-e^q = -summa(q^n/n!) to avoid loss of precision
      y1 = 0;  qn = i = ifac = 1;
      do {
         y2 = y1;
         qn *= q;  ifac *= i++;
         y1 -= qn / ifac;
      }
      while (y1 != y2);
      y = 1. - y1;
   }
   if (y > 0.1) { // (1-y)^x calculated without problem
      return x * log(y1);
   }
   else { // expand ln(1-y) = -summa(y^n/n)
      y1 = i = 1.;  z1 = 0;
      do {
         z2 = z1;
         y1 *= y;
         z1 -= y1 / i++;
      }
      while (z1 != z2);
      return x * z1;
   }
}

#endif

/***********************************************************************
Other shared functions
***********************************************************************/

double LnFacr(double x) {
   // log factorial of non-integer x
   int32 ix = (int32)(x);
   if (x == ix) return LnFac(ix);      // x is integer
   double r, r2, D = 1., f;
   static const double             
      C0 =  0.918938533204672722,      // ln(sqrt(2*pi))
      C1 =  1./12.,
      C3 = -1./360.,
      C5 =  1./1260.,
      C7 = -1./1680.;
   if (x < 6.) {
      if (x == 0 || x == 1) return 0;
      while (x < 6) D *= ++x;
   }
   r  = 1. / x;  r2 = r*r;
   f = (x + 0.5)*log(x) - x + C0 + r*(C1 + r2*(C3 + r2*(C5 + r2*C7)));
   if (D != 1.) f -= log(D);
   return f;
}


double FallingFactorial(double a, double b) {
   // calculates ln(a*(a-1)*(a-2)* ... * (a-b+1))

   if (b < 30 && int(b) == b && a < 1E10) {
      // direct calculation
      double f = 1.;
      for (int i = 0; i < b; i++) f *= a--;
      return log(f);
   }

   if (a > 100.*b && b > 1.) {
      // combine Stirling formulas for a and (a-b) to avoid loss of precision
      double ar = 1./a;
      double cr = 1./(a-b);
      // calculate -log(1-b/a) by Taylor expansion
      double s = 0., lasts, n = 1., ba = b*ar, f = ba;
      do {
         lasts = s;
         s += f/n;
         f *= ba;
         n++;
      }
      while (s != lasts);
      return (a+0.5)*s + b*log(a-b) - b + (1./12.)*(ar-cr)    
         //- (1./360.)*(ar*ar*ar-cr*cr*cr)
         ;
   }
   // use LnFacr function
   return LnFacr(a)-LnFacr(a-b);
}

double Erf (double x) {
   // Calculates the error function erf(x) as a series expansion or
   // continued fraction expansion.
   // This function may be available in math libraries as erf(x)
   static const double rsqrtpi  = 0.564189583547756286948; // 1/sqrt(pi)
   static const double rsqrtpi2 = 1.12837916709551257390;  // 2/sqrt(pi)
   if (x < 0.) return -Erf(-x);
   if (x > 6.) return 1.;
   if (x < 2.4) {
      // use series expansion
      double term;                     // term in summation
      double j21;                      // 2j+1
      double sum = 0;                  // summation
      double xx2 = x*x*2.;             // 2x^2
      int j;  
      term = x;  j21 = 1.;
      for (j=0; j<=50; j++) {          // summation loop
         sum += term;
         if (term <= 1.E-13) break;
         j21 += 2.;
         term *= xx2 / j21;
      }
      return exp(-x*x) * sum * rsqrtpi2;
   }
   else {
      // use continued fraction expansion
      double a, f;
      int n = int(2.25f*x*x - 23.4f*x + 60.84f); // predict expansion degree
      if (n < 1) n = 1;
      a = 0.5 * n;  f = x;
      for (; n > 0; n--) {             // continued fraction loop
         f = x + a / f;
         a -= 0.5;
      }
      return 1. - exp(-x*x) * rsqrtpi / f;
   }
}


int32 FloorLog2(float x) {
   // This function calculates floor(log2(x)) for positive x.
   // The return value is <= -127 for x <= 0.
#if defined(_M_IX86) || defined(__INTEL__) || defined(_M_X64) || defined(__IA64__) || defined(__POWERPC__)
   // Running on a platform known to use IEEE-754 floating point format
   int32 n = *(int32*)&x;
   return (n >> 23) - 0x7F;
#else
   // Check if floating point format is IEEE-754
   static const float one = 1.0f;
   if (*(int32*)&one == 0x3F800000) {
      // We have the standard IEEE floating point format
      int32 n = *(int32*)&x;
      return (n >> 23) - 0x7F;
   }
   else {
      // Unknown floating point format
      if (x <= 0.f) return -127;
      return (int32)floor(log(x)*(1./LN2));
   }
#endif
}


int NumSD (double accuracy) {
   // Gives the length of the integration interval necessary to achieve
   // the desired accuracy when integrating/summating a probability 
   // function, relative to the standard deviation
   // Returns an integer approximation to 2*NormalDistrFractile(accuracy/2)
   static const double fract[] = {
      2.699796e-03, 4.652582e-04, 6.334248e-05, 6.795346e-06, 5.733031e-07,
      3.797912e-08, 1.973175e-09, 8.032001e-11, 2.559625e-12, 6.381783e-14};
   int i;
   for (i = 0; i < (int)(sizeof(fract)/sizeof(*fract)); i++) {
      if (accuracy >= fract[i]) break;
   }
   return i + 6;
}


/***********************************************************************
Methods for class CWalleniusNCHypergeometric
***********************************************************************/

CWalleniusNCHypergeometric::CWalleniusNCHypergeometric(int32 n_, int32 m_, int32 N_, double odds_, double accuracy_) {
   // constructor
   accuracy = accuracy_;
   SetParameters(n_, m_, N_, odds_);}


void CWalleniusNCHypergeometric::SetParameters(int32 n_, int32 m_, int32 N_, double odds) {
   // change parameters
   if (n_ < 0 || n_ > N_ || m_ < 0 || m_ > N_ || odds < 0) FatalError("Parameter out of range in CWalleniusNCHypergeometric");
   n = n_; m = m_; N = N_; omega = odds;          // set parameters
   xmin = m + n - N;  if (xmin < 0) xmin = 0;     // calculate xmin
   xmax = n;  if (xmax > m) xmax = m;             // calculate xmax
   xLastBico = xLastFindpars = -99;               // indicate last x is invalid
   r = 1.;                                        // initialize
}


double CWalleniusNCHypergeometric::mean(void) {
   // find approximate mean
   int iter;                            // number of iterations
   double a, b;                         // temporaries in calculation of first guess
   double mean, mean1;                  // iteration value of mean
   double m1r, m2r;                     // 1/m, 1/m2
   double e1, e2;                       // temporaries
   double g;                            // function to find root of
   double gd;                           // derivative of g
   double omegar;                       // 1/omega

   if (omega == 1.) { // simple hypergeometric
      return double(m)*n/N;
   }

   // calculate Cornfield mean of Fisher noncentral hypergeometric distribution as first guess
   a = (m+n)*omega + (N-m-n); 
   b = a*a - 4.*omega*(omega-1.)*m*n;
   b = b > 0. ? sqrt(b) : 0.;
   mean = (a-b)/(2.*(omega-1.));
   if (mean < xmin) mean = xmin;
   if (mean > xmax) mean = xmax;

   m1r = 1./m;  m2r = 1./(N-m);
   iter = 0;

   if (omega > 1.) {
      do { // Newton Raphson iteration
         mean1 = mean;
         e1 = 1.-(n-mean)*m2r;
         if (e1 < 1E-14) {
            e2 = 0.;     // avoid underflow
         }
         else {
            e2 = pow(e1,omega-1.);
         }
         g = e2*e1 + (mean-m)*m1r;
         gd = e2*omega*m2r + m1r;
         mean -= g / gd;
         if (mean < xmin) mean = xmin;
         if (mean > xmax) mean = xmax;
         if (++iter > 40) {
            FatalError("Search for mean failed in function CWalleniusNCHypergeometric::mean");
         }
      }
      while (fabs(mean1 - mean) > 2E-6);
   }
   else { // omega < 1
      omegar = 1./omega;
      do { // Newton Raphson iteration
         mean1 = mean;
         e1 = 1.-mean*m1r;
         if (e1 < 1E-14) {
            e2 = 0.;   // avoid underflow
         }
         else {
            e2 = pow(e1,omegar-1.);
         }
         g = 1.-(n-mean)*m2r-e2*e1;
         gd = e2*omegar*m1r + m2r;
         mean -= g / gd;
         if (mean < xmin) mean = xmin;
         if (mean > xmax) mean = xmax;
         if (++iter > 40) {
            FatalError("Search for mean failed in function CWalleniusNCHypergeometric::mean");
         }
      }
      while (fabs(mean1 - mean) > 2E-6);
   }
   return mean;
}


double CWalleniusNCHypergeometric::variance(void) {
   // find approximate variance (poor approximation)    
   double my = mean(); // approximate mean
   // find approximate variance from Fisher's noncentral hypergeometric approximation
   double r1 = my * (m-my); double r2 = (n-my)*(my+N-n-m);
   double var = N*r1*r2/((N-1)*(m*r2+(N-m)*r1));
   if (var < 0.) var = 0.;
   return var;
}


double CWalleniusNCHypergeometric::moments(double * mean_, double * var_) {
   // calculate exact mean and variance
   // return value = sum of f(x), expected = 1.
   double y, sy=0, sxy=0, sxxy=0, me1;
   int32 x, xm, x1;
   const double accuracy = 1E-10f;  // accuracy of calculation
   xm = (int32)mean();  // approximation to mean
   for (x=xm; x<=xmax; x++) {
      y = probability(x);
      x1 = x - xm;  // subtract approximate mean to avoid loss of precision in sums
      sy += y; sxy += x1 * y; sxxy += x1 * x1 * y;
      if (y < accuracy) break;
   }
   for (x=xm-1; x>=xmin; x--) {
      y = probability(x);
      x1 = x - xm;  // subtract approximate mean to avoid loss of precision in sums
      sy += y; sxy += x1 * y; sxxy += x1 * x1 * y;
      if (y < accuracy) break;
   }

   me1 = sxy / sy;
   *mean_ = me1 + xm;
   y = sxxy / sy - me1 * me1;
   if (y < 0) y=0;
   *var_ = y;
   return sy;
}


int32 CWalleniusNCHypergeometric::mode(void) {
   // find mode
   int32 Mode;                           // mode

   if (omega == 1.) { 
      // simple hypergeometric
      int32 L  = m + n - N;
      int32 m1 = m + 1, n1 = n + 1;
      Mode = int32((double)m1*n1*omega/((m1+n1)*omega-L));
   }
   else {
      // find mode
      double f, f2 = 0.;  
      int32 xi, x2;
      int32 xmin = m + n - N;  if (xmin < 0) xmin = 0;  // calculate xmin
      int32 xmax = n;  if (xmax > m) xmax = m;          // calculate xmax

      Mode = (int32)mean();                             // floor(mean)
      if (omega < 1.) {
        if (Mode < xmax) Mode++;                        // ceil(mean)
        x2 = xmin;                                      // lower limit
        if (omega > 0.294 && N <= 10000000) {
          x2 = Mode - 1;}                    // search for mode can be limited
        for (xi = Mode; xi >= x2; xi--) {
          f = probability(xi);
          if (f <= f2) break;
          Mode = xi;  f2 = f;
        }
      }
      else {
        if (Mode < xmin) Mode++; 
        x2 = xmax;                           // upper limit
        if (omega < 3.4 && N <= 10000000) {
          x2 = Mode + 1;}                    // search for mode can be limited
        for (xi = Mode; xi <= x2; xi++) {
          f = probability(xi);
          if (f <= f2) break;
          Mode = xi; f2 = f;
        }
      }
   }
   return Mode;
}


double CWalleniusNCHypergeometric::lnbico() {
   // natural log of binomial coefficients.
   // returns lambda = log(m!*x!/(m-x)!*m2!*x2!/(m2-x2)!)
   int32 x2 = n-x, m2 = N-m;
   if (xLastBico < 0) { // m, n, N have changed
      mFac = LnFac(m) + LnFac(m2);
   }
   if (m < FAK_LEN && m2 < FAK_LEN)  goto DEFLT;
   switch (x - xLastBico) {
  case 0: // x unchanged
     break;
  case 1: // x incremented. calculate from previous value
     xFac += log (double(x) * (m2-x2) / (double(x2+1)*(m-x+1)));
     break;
  case -1: // x decremented. calculate from previous value
     xFac += log (double(x2) * (m-x) / (double(x+1)*(m2-x2+1)));
     break;
  default: DEFLT: // calculate all
     xFac = LnFac(x) + LnFac(x2) + LnFac(m-x) + LnFac(m2-x2);
   }
   xLastBico = x;
   return bico = mFac - xFac;
}


void CWalleniusNCHypergeometric::findpars() {
   // calculate d, E, r, w
   if (x == xLastFindpars) {
      return;    // all values are unchanged since last call
   }

   // find r to center peak of integrand at 0.5
   double dd, d1, z, zd, rr, lastr, rrc, rt, r2, r21, a, b, dummy;
   double oo[2];
   double xx[2] = {x, n-x};
   int i, j = 0;
   if (omega > 1.) { // make both omegas <= 1 to avoid overflow
      oo[0] = 1.;  oo[1] = 1./omega;
   }
   else {
      oo[0] = omega;  oo[1] = 1.;
   }
   dd = oo[0]*(m-x) + oo[1]*(N-m-xx[1]);
   d1 = 1./dd;
   E = (oo[0]*m + oo[1]*(N-m)) * d1;
   rr = r;
   if (rr <= d1) rr = 1.2*d1;           // initial guess
   // Newton-Raphson iteration to find r
   do {
      lastr = rr;
      rrc = 1. / rr;
      z = dd - rrc;
      zd = rrc * rrc;
      for (i=0; i<2; i++) {
         rt = rr * oo[i];
         if (rt < 100.) {                  // avoid overflow if rt big
            r21 = pow2_1(rt, &r2);         // r2=2^r, r21=1.-2^r
            a = oo[i] / r21;               // omegai/(1.-2^r)
            b = xx[i] * a;                 // x*omegai/(1.-2^r)
            z  += b;
            zd += b * a * LN2 * r2;
         }
      }
      if (zd == 0) FatalError("can't find r in function CWalleniusNCHypergeometric::findpars");
      rr -= z / zd;
      if (rr <= d1) rr = lastr * 0.125 + d1*0.875;
      if (++j == 70) FatalError("convergence problem searching for r in function CWalleniusNCHypergeometric::findpars");
   }
   while (fabs(rr-lastr) > rr * 1.E-6);
   if (omega > 1) {
      dd *= omega;  rr *= oo[1];
   }
   r = rr;  rd = rr * dd;

   // find peak width
   double ro, k1, k2;
   ro = r * omega;
   if (ro < 300) {                      // avoid overflow
      k1 = pow2_1(ro, &dummy);
      k1 = -1. / k1;
      k1 = omega*omega*(k1+k1*k1);
   }
   else k1 = 0.;
   if (r < 300) {                       // avoid overflow
      k2 = pow2_1(r, &dummy);
      k2 = -1. / k2;
      k2 = (k2+k2*k2);
   }
   else k2 = 0.;
   phi2d = -4.*r*r*(x*k1 + (n-x)*k2);
   if (phi2d >= 0.) {
      FatalError("peak width undefined in function CWalleniusNCHypergeometric::findpars");
      /* wr = r = 0.; */ 
   }
   else {
      wr = sqrt(-phi2d); w = 1./wr;
   }
   xLastFindpars = x;
}


int CWalleniusNCHypergeometric::BernouilliH(int32 x_, double h, double rh, StochasticLib1 *sto) {
   // This function generates a Bernouilli variate with probability proportional
   // to the univariate Wallenius' noncentral hypergeometric distribution.
   // The return value will be 1 with probability f(x_)/h and 0 with probability
   // 1-f(x_)/h.
   // This is equivalent to calling sto->Bernouilli(probability(x_)/h),
   // but this method is faster. The method used here avoids calculating the
   // Wallenius probability by sampling in the t-domain.
   // rh is a uniform random number in the interval 0 <= rh < h. The function
   // uses additional random numbers generated from sto.
   // This function is intended for use in rejection methods for sampling from
   // the Wallenius distribution. It is called from 
   // StochasticLib3::WalleniusNCHypRatioOfUnifoms in the file stoc3.cpp
   double f0;                      // Lambda*Phi()
   double phideri0;                // phi()/rd
   double qi;                      // 2^(-r*omega[i])
   double qi1;                     // 1-qi
   double omegai[2] = {omega,1.};  // weights for each color
   double romegi;                  // r*omega[i]
   double xi[2] = {x_, n-x_};      // number of each color sampled
   double k;                       // adjusted width for majorizing function Ypsilon(t)
   double erfk;                    // erf correction
   double rdm1;                    // rd - 1
   double G_integral;              // integral of majorizing function Ypsilon(t)
   double ts;                      // t sampled from Ypsilon(t) distribution
   double logts;                   // log(ts)
   double rlogts;                  // r*log(ts)
   double fts;                     // Phi(ts)/rd
   double rgts;                    // 1/(Ypsilon(ts)/rd)
   double t2;                      // temporary in calculation of Ypsilon(ts)
   int i, j;                       // loop counters
   static const double rsqrt8 = 0.3535533905932737622; // 1/sqrt(8)
   static const double sqrt2pi = 2.506628274631000454; // sqrt(2*pi)

   x = x_;                         // save x in class object
   lnbico();                       // calculate bico = log(Lambda)
   findpars();                     // calculate r, d, rd, w, E
   if (E > 0.) {
      k = log(E);                   // correction for majorizing function
      k = 1. + 0.0271 * (k * sqrt(k));
   }
   else k = 1.;
   k *= w;                         // w * k   
   rdm1 = rd - 1.;

   // calculate phi()/rd
   phideri0 = -LN2 * rdm1;
   for (i=0; i<2; i++) {
      romegi = r * omegai[i];
      if (romegi > 40.) {
         qi=0.;  qi1 = 1.;           // avoid underflow
      }
      else {
         qi1 = pow2_1(-romegi, &qi);
      }
      phideri0 += xi[i] * log1mx(qi, qi1);
   }

   erfk = Erf(rsqrt8 / k);
   f0 = rd * exp(phideri0 + bico);
   G_integral = f0 * sqrt2pi * k * erfk;

   if (G_integral <= h) {          // G fits under h-hat
      do {
         ts = sto->Normal(0,k);      // sample ts from normal distribution
      }
      while (fabs(ts) >= 0.5);      // reject values outside interval, and avoid ts = 0
      ts += 0.5;                    // ts = normal distributed in interval (0,1)

      for (fts=0., j=0; j<2; j++) { // calculate (Phi(ts)+Phi(1-ts))/2
         logts = log(ts);  rlogts = r * logts; // (ts = 0 avoided above)
         fts += exp(log1pow(rlogts*omega,xi[0]) + log1pow(rlogts,xi[1]) + rdm1*logts + bico);
         ts = 1. - ts;
      }
      fts *= 0.5;

      t2 = (ts-0.5) / k;            // calculate 1/Ypsilon(ts)
      rgts = exp(-(phideri0 + bico - 0.5 * t2*t2));
      return rh < G_integral * fts * rgts;   // Bernouilli variate
   }

   else { // G > h: can't use sampling in t-domain
      return rh < probability(x);
   }
}


/***********************************************************************
methods for calculating probability in class CWalleniusNCHypergeometric
***********************************************************************/

double CWalleniusNCHypergeometric::recursive() {
   // recursive calculation
   // Wallenius noncentral hypergeometric distribution by recursion formula
   // Approximate by ignoring probabilities < accuracy and minimize storage requirement
   const int BUFSIZE = 512;            // buffer size
   double p[BUFSIZE+2];                // probabilities
   double * p1, * p2;                  // offset into p
   double mxo;                         // (m-x)*omega
   double Nmnx;                        // N-m-nu+x
   double y, y1;                       // save old p[x] before it is overwritten
   double d1, d2, dcom;                // divisors in probability formula
   double accuracya;                   // absolute accuracy
   int32 xi, nu;                       // xi, nu = recursion values of x, n
   int32 x1, x2;                       // xi_min, xi_max

   accuracya = 0.005f * accuracy;      // absolute accuracy
   p1 = p2 = p + 1;                    // make space for p1[-1]
   p1[-1] = 0.;  p1[0]  = 1.;          // initialize for recursion
   x1 = x2 = 0;
   for (nu=1; nu<=n; nu++) {
      if (n - nu < x - x1 || p1[x1] < accuracya) {
         x1++;               // increase lower limit when breakpoint passed or probability negligible
         p2--;               // compensate buffer offset in order to reduce storage space
      }
      if (x2 < x && p1[x2] >= accuracya) {
         x2++;  y1 = 0.;     // increase upper limit until x has been reached
      }
      else {
         y1 = p1[x2];
      }
      if (x1 > x2) return 0.;
      if (p2+x2-p > BUFSIZE) FatalError("buffer overrun in function CWalleniusNCHypergeometric::recursive");

      mxo = (m-x2)*omega;
      Nmnx = N-m-nu+x2+1;
      for (xi = x2; xi >= x1; xi--) {    // backwards loop
         d2 = mxo + Nmnx;
         mxo += omega; Nmnx--;
         d1 = mxo + Nmnx;
         dcom = 1. / (d1 * d2);           // save a division by making common divisor
         y  = p1[xi-1]*mxo*d2*dcom + y1*(Nmnx+1)*d1*dcom;
         y1 = p1[xi-1];                   // (warning: pointer alias, can't swap instruction order)
         p2[xi] = y;
      }
      p1 = p2;
   }

   if (x < x1 || x > x2) return 0.;
   return p1[x];
}


double CWalleniusNCHypergeometric::binoexpand() {
   // calculate by binomial expansion of integrand
   // only for x < 2 or n-x < 2 (not implemented for higher x because of loss of precision)
   int32 x1, m1, m2;
   double o;
   if (x > n/2) { // invert
      x1 = n-x; m1 = N-m; m2 = m; o = 1./omega;
   }
   else {
      x1 = x; m1 = m; m2 = N-m; o = omega;
   }
   if (x1 == 0) {
      return exp(FallingFactorial(m2,n) - FallingFactorial(m2+o*m1,n));
   }    
   if (x1 == 1) {
      double d, e, q, q0, q1;
      q = FallingFactorial(m2,n-1);
      e = o*m1+m2;
      q1 = q - FallingFactorial(e,n);
      e -= o;
      q0 = q - FallingFactorial(e,n);
      d = e - (n-1);
      return m1*d*(exp(q0) - exp(q1));
   }

   FatalError("x > 1 not supported by function CWalleniusNCHypergeometric::binoexpand");
   return 0;
}


double CWalleniusNCHypergeometric::laplace() {
   // Laplace's method with narrow integration interval, 
   // using error function residues table, defined in erfres.cpp
   // Note that this function can only be used when the integrand peak is narrow.
   // findpars() must be called before this function.

   const int COLORS = 2;         // number of colors
   const int MAXDEG = 40;        // arraysize, maximum expansion degree
   int degree;                   // max expansion degree
   double accur;                 // stop expansion when terms below this threshold
   double omegai[COLORS] = {omega, 1.}; // weights for each color
   double xi[COLORS] = {x, n-x}; // number of each color sampled
   double f0;                    // factor outside integral
   double rho[COLORS];           // r*omegai
   double qi;                    // 2^(-rho)
   double qi1;                   // 1-qi
   double qq[COLORS];            // qi / qi1
   double eta[COLORS+1][MAXDEG+1]; // eta coefficients
   double phideri[MAXDEG+1];     // derivatives of phi
   double PSIderi[MAXDEG+1];     // derivatives of PSI
   double * erfresp;             // pointer to table of error function residues

   // variables in asymptotic summation
   static const double sqrt8  = 2.828427124746190098; // sqrt(8)
   double qqpow;                 // qq^j
   double pow2k;                 // 2^k
   double bino;                  // binomial coefficient  
   double vr;                    // 1/v, v = integration interval
   double v2m2;                  // (2*v)^(-2)
   double v2mk1;                 // (2*v)^(-k-1)
   double s;                     // summation term
   double sum;                   // Taylor sum

   int i;                        // loop counter for color
   int j;                        // loop counter for derivative
   int k;                        // loop counter for expansion degree
   int ll;                       // k/2
   int converg = 0;              // number of consequtive terms below accuracy
   int PrecisionIndex;           // index into ErfRes table according to desired precision

   // initialize
   for (k = 0; k <= 2; k++)  phideri[k] = PSIderi[k] = 0;

   // find rho[i], qq[i], first eta coefficients, and zero'th derivative of phi
   for (i = 0; i < COLORS; i++) {
      rho[i] = r * omegai[i];
      if (rho[i] > 40.) {
         qi=0.;  qi1 = 1.;}               // avoid underflow
      else {
         qi1 = pow2_1(-rho[i], &qi);}     // qi=2^(-rho), qi1=1.-2^(-rho)
      qq[i] = qi / qi1;                  // 2^(-r*omegai)/(1.-2^(-r*omegai))
      // peak = zero'th derivative
      phideri[0] += xi[i] * log1mx(qi, qi1);
      // eta coefficients
      eta[i][0] = 0.;
      eta[i][1] = eta[i][2] = rho[i]*rho[i];
   }

   // r, rd, and w must be calculated by findpars()
   // zero'th derivative
   phideri[0] -= (rd - 1.) * LN2;
   // scaled factor outside integral
   f0 = rd * exp(phideri[0] + lnbico());

   vr = sqrt8 * w;
   phideri[2] = phi2d;

   // get table according to desired precision
   PrecisionIndex = (-FloorLog2((float)accuracy) - ERFRES_B + ERFRES_S - 1) / ERFRES_S;
   if (PrecisionIndex < 0) PrecisionIndex = 0;
   if (PrecisionIndex > ERFRES_N-1) PrecisionIndex = ERFRES_N-1;
   while (w * NumSDev[PrecisionIndex] > 0.3) { 
      // check if integration interval is too wide
      if (PrecisionIndex == 0) {
         FatalError("Laplace method failed. Peak width too high in function CWalleniusNCHypergeometric::laplace");
         break;}
      PrecisionIndex--;                  // reduce precision to keep integration interval narrow
   }
   erfresp = ErfRes[PrecisionIndex];    // choose desired table

   degree = MAXDEG;                     // max expansion degree
   if (degree >= ERFRES_L*2) degree = ERFRES_L*2-2;

   // set up for starting loop at k=3
   v2m2 = 0.25 * vr * vr;               // (2*v)^(-2)
   PSIderi[0] = 1.;
   pow2k = 8.;
   sum = 0.5 * vr * erfresp[0];
   v2mk1 = 0.5 * vr * v2m2 * v2m2;
   accur = accuracy * sum;

   // summation loop
   for (k = 3; k <= degree; k++) {
      phideri[k] = 0.;

      // loop for all (2) colors
      for (i = 0; i < COLORS; i++) {
         eta[i][k] = 0.;
         // backward loop for all powers
         for (j = k; j > 0; j--) {
            // find coefficients recursively from previous coefficients
            eta[i][j]  =  eta[i][j]*(j*rho[i]-(k-2)) +  eta[i][j-1]*rho[i]*(j-1);
         }
         qqpow = 1.;
         // forward loop for all powers
         for (j=1; j<=k; j++) {
            qqpow *= qq[i];                // qq^j
            // contribution to derivative
            phideri[k] += xi[i] * eta[i][j] * qqpow;
         }
      }

      // finish calculation of derivatives
      phideri[k] = -pow2k*phideri[k] + 2*(1-k)*phideri[k-1];

      pow2k *= 2.;    // 2^k

      // loop to calculate derivatives of PSI from derivatives of psi.
      // terms # 0, 1, 2, k-2, and k-1 are zero and not included in loop.
      // The j'th derivatives of psi are identical to the derivatives of phi for j>2, and
      // zero for j=1,2. Hence we are using phideri[j] for j>2 here.
      PSIderi[k] = phideri[k];           // this is term # k
      bino = 0.5 * (k-1) * (k-2);        // binomial coefficient for term # 3
      for (j = 3; j < k-2; j++) {        // loop for remaining nonzero terms (if k>5)
         PSIderi[k] += PSIderi[k-j] * phideri[j] * bino;
         bino *= double(k-j)/double(j);
      }
      if ((k & 1) == 0) {                // only for even k
         ll = k/2;
         s = PSIderi[k] * v2mk1 * erfresp[ll];
         sum += s;

         // check for convergence of Taylor expansion
         if (fabs(s) < accur) converg++; else converg = 0;
         if (converg > 1) break;

         // update recursive expressions
         v2mk1 *= v2m2;
      }
   }
   // multiply by terms outside integral  
   return f0 * sum;
}


double CWalleniusNCHypergeometric::integrate() {
   // Wallenius non-central hypergeometric distribution function
   // calculation by numerical integration with variable-length steps
   // NOTE: findpars() must be called before this function.
   double s;                            // result of integration step
   double sum;                          // integral
   double ta, tb;                       // subinterval for integration step

   lnbico();                            // compute log of binomial coefficients

   // choose method:
   if (w < 0.02 || w < 0.1 && (x==m || n-x==N-m) && accuracy > 1E-6) {
      // normal method. Step length determined by peak width w
      double delta, s1;
      s1 = accuracy < 1E-9 ? 0.5 : 1.;
      delta = s1 * w;                    // integration steplength
      ta = 0.5 + 0.5 * delta;
      sum = integrate_step(1.-ta, ta);   // first integration step around center peak
      do {
         tb = ta + delta;
         if (tb > 1.) tb = 1.;
         s  = integrate_step(ta, tb);     // integration step to the right of peak
         s += integrate_step(1.-tb,1.-ta);// integration step to the left of peak
         sum += s;
         if (s < accuracy * sum) break;   // stop before interval finished if accuracy reached
         ta = tb;
         if (tb > 0.5 + w) delta *= 2.;   // increase step length far from peak
      }
      while (tb < 1.);
   }
   else {
      // difficult situation. Step length determined by inflection points
      double t1, t2, tinf, delta, delta1;
      sum = 0.;
      // do left and right half of integration interval separately:
      for (t1=0., t2=0.5; t1 < 1.; t1+=0.5, t2+=0.5) { 
         // integrate from 0 to 0.5 or from 0.5 to 1
         tinf = search_inflect(t1, t2);   // find inflection point
         delta = tinf - t1; if (delta > t2 - tinf) delta = t2 - tinf; // distance to nearest endpoint
         delta *= 1./7.;                  // 1/7 will give 3 steps to nearest endpoint
         if (delta < 1E-4) delta = 1E-4;
         delta1 = delta;
         // integrate from tinf forwards to t2
         ta = tinf;
         do {
            tb = ta + delta1;
            if (tb > t2 - 0.25*delta1) tb = t2; // last step of this subinterval
            s = integrate_step(ta, tb);         // integration step
            sum += s;
            delta1 *= 2;                        // double steplength
            if (s < sum * 1E-4) delta1 *= 8.;   // large step when s small
            ta = tb;
         }
         while (tb < t2);
         if (tinf) {
            // integrate from tinf backwards to t1
            tb = tinf;
            do {
               ta = tb - delta;
               if (ta < t1 + 0.25*delta) ta = t1; // last step of this subinterval
               s = integrate_step(ta, tb);        // integration step
               sum += s;
               delta *= 2;                        // double steplength
               if (s < sum * 1E-4) delta *= 8.;   // large step when s small
               tb = ta;}
            while (ta > t1);
         }
      }
   }
   return sum * rd;
}


double CWalleniusNCHypergeometric::integrate_step(double ta, double tb) {
   // integration subprocedure used by integrate()
   // makes one integration step from ta to tb using Gauss-Legendre method.
   // result is scaled by multiplication with exp(bico)
   double ab, delta, tau, ltau, y, sum, taur, rdm1;
   int i;

   // define constants for Gauss-Legendre integration with IPOINTS points
#define IPOINTS  8  // number of points in each integration step

#if   IPOINTS == 3
   static const double xval[3]    = {-.774596669241,0,0.774596668241};
   static const double weights[3] = {.5555555555555555,.88888888888888888,.55555555555555};
#elif IPOINTS == 4
   static const double xval[4]    = {-0.861136311594,-0.339981043585,0.339981043585,0.861136311594},
      static const double weights[4] = {0.347854845137,0.652145154863,0.652145154863,0.347854845137};
#elif IPOINTS == 5
   static const double xval[5]    = {-0.906179845939,-0.538469310106,0,0.538469310106,0.906179845939};
   static const double weights[5] = {0.236926885056,0.478628670499,0.568888888889,0.478628670499,0.236926885056};
#elif IPOINTS == 6
   static const double xval[6]    = {-0.932469514203,-0.661209386466,-0.238619186083,0.238619186083,0.661209386466,0.932469514203};
   static const double weights[6] = {0.171324492379,0.360761573048,0.467913934573,0.467913934573,0.360761573048,0.171324492379};
#elif IPOINTS == 8
   static const double xval[8]    = {-0.960289856498,-0.796666477414,-0.525532409916,-0.183434642496,0.183434642496,0.525532409916,0.796666477414,0.960289856498};
   static const double weights[8] = {0.10122853629,0.222381034453,0.313706645878,0.362683783378,0.362683783378,0.313706645878,0.222381034453,0.10122853629};
#elif IPOINTS == 12
   static const double xval[12]   = {-0.981560634247,-0.90411725637,-0.769902674194,-0.587317954287,-0.367831498998,-0.125233408511,0.125233408511,0.367831498998,0.587317954287,0.769902674194,0.90411725637,0.981560634247};
   static const double weights[12]= {0.0471753363866,0.106939325995,0.160078328543,0.203167426723,0.233492536538,0.249147045813,0.249147045813,0.233492536538,0.203167426723,0.160078328543,0.106939325995,0.0471753363866};
#elif IPOINTS == 16
   static const double xval[16]   = {-0.989400934992,-0.944575023073,-0.865631202388,-0.755404408355,-0.617876244403,-0.458016777657,-0.281603550779,-0.0950125098376,0.0950125098376,0.281603550779,0.458016777657,0.617876244403,0.755404408355,0.865631202388,0.944575023073,0.989400934992};
   static const double weights[16]= {0.027152459411,0.0622535239372,0.0951585116838,0.124628971256,0.149595988817,0.169156519395,0.182603415045,0.189450610455,0.189450610455,0.182603415045,0.169156519395,0.149595988817,0.124628971256,0.0951585116838,0.0622535239372,0.027152459411};
#else
#error // IPOINTS must be a value for which the tables are defined
#endif

   delta = 0.5 * (tb - ta);
   ab = 0.5 * (ta + tb);
   rdm1 = rd - 1.;
   sum = 0;

   for (i = 0; i < IPOINTS; i++) {
      tau = ab + delta * xval[i];
      ltau = log(tau);
      taur = r * ltau;
      // possible loss of precision due to subtraction here:
      y = log1pow(taur*omega,x) + log1pow(taur,n-x) + rdm1*ltau + bico;
      if (y > -50.) sum += weights[i] * exp(y);
   }
   return delta * sum;
}


double CWalleniusNCHypergeometric::search_inflect(double t_from, double t_to) {
   // search for an inflection point of the integrand PHI(t) in the interval
   // t_from < t < t_to
   const int COLORS = 2;                // number of colors
   double t, t1;                        // independent variable
   double rho[COLORS];                  // r*omega[i]
   double q;                            // t^rho[i] / (1-t^rho[i])
   double q1;                           // 1-t^rho[i]
   double xx[COLORS];                   // x[i]
   double zeta[COLORS][4][4];           // zeta[i,j,k] coefficients
   double phi[4];                       // derivatives of phi(t) = log PHI(t)
   double Z2;                           // PHI''(t)/PHI(t)
   double Zd;                           // derivative in Newton Raphson iteration
   double rdm1;                         // r * d - 1
   double tr;                           // 1/t
   double log2t;                        // log2(t)
   double method;                       // 0 for z2'(t) method, 1 for z3(t) method
   int i;                               // color
   int iter;                            // count iterations

   rdm1 = rd - 1.;
   if (t_from == 0 && rdm1 <= 1.) return 0.; //no inflection point
   rho[0] = r*omega;  rho[1] = r;
   xx[0] = x;  xx[1] = n - x;
   t = 0.5 * (t_from + t_to);
   for (i = 0; i < COLORS; i++) {           // calculate zeta coefficients
      zeta[i][1][1] = rho[i];
      zeta[i][1][2] = rho[i] * (rho[i] - 1.);
      zeta[i][2][2] = rho[i] * rho[i];
      zeta[i][1][3] = zeta[i][1][2] * (rho[i] - 2.);
      zeta[i][2][3] = zeta[i][1][2] * rho[i] * 3.;
      zeta[i][3][3] = zeta[i][2][2] * rho[i] * 2.;
   }
   iter = 0;

   do {
      t1 = t;
      tr = 1. / t;
      log2t = log(t)*(1./LN2);
      phi[1] = phi[2] = phi[3] = 0.;
      for (i=0; i<COLORS; i++) {         // calculate first 3 derivatives of phi(t)
         q1 = pow2_1(rho[i]*log2t,&q);
         q /= q1;
         phi[1] -= xx[i] * zeta[i][1][1] * q;
         phi[2] -= xx[i] * q * (zeta[i][1][2] + q * zeta[i][2][2]);
         phi[3] -= xx[i] * q * (zeta[i][1][3] + q * (zeta[i][2][3] + q * zeta[i][3][3]));
      }
      phi[1] += rdm1;
      phi[2] -= rdm1;
      phi[3] += 2. * rdm1;
      phi[1] *= tr;
      phi[2] *= tr * tr;
      phi[3] *= tr * tr * tr;
      method = (iter & 2) >> 1;        // alternate between the two methods
      Z2 = phi[1]*phi[1] + phi[2];
      Zd = method*phi[1]*phi[1]*phi[1] + (2.+method)*phi[1]*phi[2] + phi[3];

      if (t < 0.5) {
         if (Z2 > 0) {
            t_from = t;
         }
         else {
            t_to = t;
         }
         if (Zd >= 0) { 
            // use binary search if Newton-Raphson iteration makes problems
            t = (t_from ? 0.5 : 0.2) * (t_from + t_to);
         }
         else {
            // Newton-Raphson iteration
            t -= Z2 / Zd;
         }
      }
      else {
         if (Z2 < 0) {
            t_from = t;
         }
         else {
            t_to = t;
         }
         if (Zd <= 0) {
            // use binary search if Newton-Raphson iteration makes problems
            t = 0.5 * (t_from + t_to);
         }
         else {
            // Newton-Raphson iteration
            t -= Z2 / Zd;
         }
      }
      if (t >= t_to) t = (t1 + t_to) * 0.5;
      if (t <= t_from) t = (t1 + t_from) * 0.5;
      if (++iter > 20) FatalError("Search for inflection point failed in function CWalleniusNCHypergeometric::search_inflect");
   }
   while (fabs(t - t1) > 1E-5);
   return t;
}


double CWalleniusNCHypergeometric::probability(int32 x_) {
   // calculate probability function. choosing best method
   x = x_;
   if (x < xmin || x > xmax) return 0.;
   if (xmin == xmax) return 1.;
   if (omega == 1.) { // hypergeometric
      return exp(lnbico() + LnFac(n) + LnFac(N-n) - LnFac(N));
   }

   int32 x2 = n - x;
   int32 x0 = x < x2 ? x : x2;
   int em = (x == m || x2 == N-m);

   if (x0 == 0 && n > 500) {
      return binoexpand();
   }

   if (double(n)*x0 < 1000 || double(n)*x0 < 10000 && (N > 1000.*n || em)) {
      return recursive();
   }

   if (x0 <= 1 && N-n <= 1) {
      return binoexpand();
   }

   findpars();

   if (w < 0.04 && E < 10 && (!em || w > 0.004)) {
      return laplace();
   }

   return integrate();
}


int32 CWalleniusNCHypergeometric::MakeTable(double * table, int32 MaxLength, int32 * xfirst, int32 * xlast, double cutoff) {
   // Makes a table of Wallenius noncentral hypergeometric probabilities 
   // table must point to an array of length MaxLength. 
   // The function returns 1 if table is long enough. Otherwise it fills
   // the table with as many correct values as possible and returns 0.
   // The tails are cut off where the values are < cutoff, so that 
   // *xfirst may be > xmin and *xlast may be < xmax.
   // The value of cutoff will be 0.01 * accuracy if not specified.
   // The first and last x value represented in the table are returned in 
   // *xfirst and *xlast. The resulting probability values are returned in 
   // the first (*xfirst - *xlast + 1) positions of table. Any unused part
   // of table may be overwritten with garbage.
   //
   // The function will return the following information when MaxLength = 0:
   // The return value is the desired length of table.
   // *xfirst is 1 if it will be more efficient to call MakeTable than to call
   // probability repeatedly, even if only some of the table values are needed.
   // *xfirst is 0 if it is more efficient to call probability repeatedly.

   double * p1, * p2;                  // offset into p
   double mxo;                         // (m-x)*omega
   double Nmnx;                        // N-m-nu+x
   double y, y1;                       // probability. Save old p[x] before it is overwritten
   double d1, d2, dcom;                // divisors in probability formula
   double area;                        // estimate of area needed for recursion method
   int32 xi, nu;                       // xi, nu = recursion values of x, n
   int32 x1, x2;                       // lowest and highest x or xi
   int32 i1, i2;                       // index into table
   int32 UseTable;                     // 1 if table method used
   int32 LengthNeeded;                 // Necessary table length

   if (cutoff <= 0. || cutoff > 0.1) cutoff = 0.01 * accuracy;

   LengthNeeded = N - m;               // m2
   if (m < LengthNeeded) LengthNeeded = m;
   if (n < LengthNeeded) LengthNeeded = n; // LengthNeeded = min(m1,m2,n)
   area = double(n)*LengthNeeded;      // Estimate calculation time for table method
   UseTable = area < 5000. || area < 10000. && N > 1000. * n;

   if (MaxLength <= 0) {
      // Return UseTable and LengthNeeded
      if (xfirst) *xfirst = UseTable;
      i1 = LengthNeeded + 2;           // Necessary table length
      if (!UseTable && i1 > 200) {
         // Calculate necessary table length from standard deviation
         double sd = sqrt(variance()); // calculate approximate standard deviation
         // estimate number of standard deviations to include from normal distribution
         i2 = (int32)(NumSD(accuracy) * sd + 0.5);
         if (i1 > i2) i1 = i2;
      }
      return i1;
   }

   if (UseTable && MaxLength > LengthNeeded) {
      // use recursion table method
      p1 = p2 = table + 1;             // make space for p1[-1]
      p1[-1] = 0.;  p1[0] = 1.;        // initialize for recursion
      x1 = x2 = 0;
      for (nu = 1; nu <= n; nu++) {
         if (n - nu < xmin - x1 || p1[x1] < cutoff) {
            x1++;                      // increase lower limit when breakpoint passed or probability negligible
            p2--;                      // compensate buffer offset in order to reduce storage space
         }
         if (x2 < xmax && p1[x2] >= cutoff) {
            x2++;  y1 = 0.;            // increase upper limit until x has been reached
         }
         else {
            y1 = p1[x2];
         }
         if (p2 - table + x2 >= MaxLength || x1 > x2) {
            goto ONE_BY_ONE;           // Error: table length exceeded. Use other method
         }

         mxo = (m-x2)*omega;
         Nmnx = N-m-nu+x2+1;
         for (xi = x2; xi >= x1; xi--) { // backwards loop
            d2 = mxo + Nmnx;
            mxo += omega; Nmnx--;
            d1 = mxo + Nmnx;
            dcom = 1. / (d1 * d2);     // save a division by making common divisor
            y  = p1[xi-1]*mxo*d2*dcom + y1*(Nmnx+1)*d1*dcom;
            y1 = p1[xi-1];             // (warning: pointer alias, can't swap instruction order)
            p2[xi] = y;
         }
         p1 = p2;
      }

      // return results
      i1 = i2 = x2 - x1 + 1;              // desired table length
      if (i2 > MaxLength) i2 = MaxLength; // limit table length
      *xfirst = x1;  *xlast = x1 + i2 - 1;
      if (i2 > 0) memcpy(table, table+1, i2*sizeof(table[0]));// copy to start of table
      return i1 == i2;                    // true if table size not reduced
   }

   else {
      // Recursion method would take too much time
      // Calculate values one by one
      ONE_BY_ONE:

      // Start to fill table from the end and down. start with x = floor(mean)
      x2 = (int32)mean();
      x1 = x2 + 1;  i1 = MaxLength;
      while (x1 > xmin) {              // loop for left tail
         x1--;  i1--;
         y = probability(x1);
         table[i1] = y;
         if (y < cutoff) break;
         if (i1 == 0) break;
      }
      *xfirst = x1;
      i2 = x2 - x1 + 1; 
      if (i1 > 0 && i2 > 0) { // move numbers down to beginning of table
         memcpy(table, table+i1, i2*sizeof(table[0]));
      }
      // Fill rest of table from mean and up
      i2--;
      while (x2 < xmax) {              // loop for right tail
         if (i2 == MaxLength-1) {
            *xlast = x2; return 0;     // table full
         }
         x2++;  i2++;
         y = probability(x2);
         table[i2] = y;
         if (y < cutoff) break;
      }
      *xlast = x2;
      return 1;
   }
}


/***********************************************************************
calculation methods in class CMultiWalleniusNCHypergeometric
***********************************************************************/

CMultiWalleniusNCHypergeometric::CMultiWalleniusNCHypergeometric(int32 n_, int32 * m_, double * odds_, int colors_, double accuracy_) {
   // constructor
   accuracy = accuracy_;
   SetParameters(n_, m_, odds_, colors_);
}


void CMultiWalleniusNCHypergeometric::SetParameters(int32 n_, int32 * m_, double * odds_, int colors_) {
   // change parameters
   int32 N1;
   int i;
   n = n_;  m = m_;  omega = odds_;  colors = colors_;
   r = 1.;
   for (N=N1=0, i=0; i < colors; i++) {
      if (m[i] < 0 || omega[i] < 0) FatalError("Parameter negative in constructor for CMultiWalleniusNCHypergeometric");
      N += m[i];
      if (omega[i]) N1 += m[i];
   }
   if (N < n) FatalError("Not enough items in constructor for CMultiWalleniusNCHypergeometric");
   if (N1< n) FatalError("Not enough items with nonzero weight in constructor for CMultiWalleniusNCHypergeometric");
}


void CMultiWalleniusNCHypergeometric::mean(double * mu) {
   // calculate approximate mean of multivariate Wallenius noncentral hypergeometric 
   // distribution. Result is returned in mu[0..colors-1]
   double omeg[MAXCOLORS];              // scaled weights
   double omr;                          // reciprocal mean weight
   double t, t1;                        // independent variable in iteration
   double To, To1;                      // exp(t*omega[i]), 1-exp(t*omega[i])
   double H;                            // function to find root of
   double HD;                           // derivative of H
   double dummy;                        // unused return
   int i;                               // color index
   int iter;                            // number of iterations

   // calculate mean weight
   for (omr=0., i=0; i < colors; i++) omr += omega[i]*m[i];
   omr = N / omr;
   // scale weights to make mean = 1
   for (i = 0; i < colors; i++) omeg[i] = omega[i] * omr;
   // Newton Raphson iteration
   iter = 0;  t = -1.;                  // first guess
   do {
      t1 = t;
      H = HD = 0.;
      // calculate H and HD
      for (i = 0; i < colors; i++) {
         if (omeg[i] != 0.) {
            To1 = pow2_1(t * (1./LN2) * omeg[i], &To);
            H += m[i] * To1;
            HD -= m[i] * omeg[i] * To;
         }
      }
      t -= (H-n) / HD;
      if (t >= 0) t = 0.5 * t1;
      if (++iter > 20) {
         FatalError("Search for mean failed in function CMultiWalleniusNCHypergeometric::mean");
      }
   }
   while (fabs(H - n) > 1E-3);
   // finished iteration. Get all mu[i]
   for (i = 0; i < colors; i++) {
      if (omeg[i] != 0.) {
         To1 = pow2_1(t * (1./LN2) * omeg[i], &dummy);
         mu[i] = m[i] * To1;
      }
      else {
         mu[i] = 0.;
      }
   }
}


// implementations of different calculation methods
double CMultiWalleniusNCHypergeometric::binoexpand(void) {
   // binomial expansion of integrand
   // only implemented for x[i] = 0 for all but one i
   int i, j, k;
   double W = 0.;                       // total weight
   for (i=j=k=0; i<colors; i++) {
      W += omega[i] * m[i];
      if (x[i]) {
         j=i; k++;                        // find the nonzero x[i]
      }
   }
   if (k > 1) FatalError("More than one x[i] nonzero in CMultiWalleniusNCHypergeometric::binoexpand");
   return exp(FallingFactorial(m[j],n) - FallingFactorial(W/omega[j],n));
}


double CMultiWalleniusNCHypergeometric::lnbico(void) {
   // natural log of binomial coefficients
   bico = 0.;
   int i;
   for (i=0; i<colors; i++) {
      if (x[i] < m[i] && omega[i]) {
         bico += LnFac(m[i]) - LnFac(x[i]) - LnFac(m[i]-x[i]);
      }
   }
   return bico;
}


void CMultiWalleniusNCHypergeometric::findpars(void) {
   // calculate r, w, E
   // calculate d, E, r, w

   // find r to center peak of integrand at 0.5
   double dd;                           // scaled d
   double dr;                           // 1/d

   double z, zd, rr, lastr, rrc, rt, r2, r21, a, b, ro, k1, dummy;
   double omax;                         // highest omega
   double omaxr;                        // 1/omax
   double omeg[MAXCOLORS];              // scaled weights
   int i, j = 0;

   // find highest omega
   for (omax=0., i=0; i < colors; i++) {
      if (omega[i] > omax) omax = omega[i];
   }
   omaxr = 1. / omax;
   dd = E = 0.;
   for (i = 0; i < colors; i++) {
      // scale weights to make max = 1
      omeg[i] = omega[i] * omaxr;
      // calculate d and E
      dd += omeg[i] * (m[i]-x[i]);
      E  += omeg[i] * m[i];
   }
   dr = 1. / dd;
   E *= dr;
   rr = r * omax;
   if (rr <= dr) rr = 1.2 * dr;  // initial guess
   // Newton-Raphson iteration to find r
   do {
      lastr = rr;
      rrc = 1. / rr;
      z = dd - rrc;                      // z(r)
      zd = rrc * rrc;                    // z'(r)
      for (i=0; i<colors; i++) {
         rt = rr * omeg[i];
         if (rt < 100. && rt > 0.) {      // avoid overflow and division by 0
            r21 = pow2_1(rt, &r2);         // r2=2^r, r21=1.-2^r
            a = omeg[i] / r21;             // omegai/(1.-2^r)
            b = x[i] * a;                  // x*omegai/(1.-2^r)
            z  += b;
            zd += b * a * r2 * LN2;
         }
      }
      if (zd == 0) FatalError("can't find r in function CMultiWalleniusNCHypergeometric::findpars");
      rr -= z / zd;                      // next r
      if (rr <= dr) rr = lastr * 0.125 + dr * 0.875;
      if (++j == 70) FatalError("convergence problem searching for r in function CMultiWalleniusNCHypergeometric::findpars");
   }
   while (fabs(rr-lastr) > rr * 1.E-5);
   rd = rr * dd;
   r = rr * omaxr;

   // find peak width
   phi2d = 0.;
   for (i=0; i<colors; i++) {
      ro = rr * omeg[i];
      if (ro < 300 && ro > 0.) {         // avoid overflow and division by 0
         k1 = pow2_1(ro, &dummy);
         k1 = -1. / k1;
         k1 = omeg[i] * omeg[i] * (k1 + k1*k1);
      }
      else k1 = 0.;
      phi2d += x[i] * k1;
   }
   phi2d *= -4. * rr * rr;
   if (phi2d > 0.) FatalError("peak width undefined in function CMultiWalleniusNCHypergeometric::findpars");
   wr = sqrt(-phi2d);  w = 1. / wr;
}


double CMultiWalleniusNCHypergeometric::laplace(void) {
   // Laplace's method with narrow integration interval, 
   // using error function residues table, defined in erfres.cpp
   // Note that this function can only be used when the integrand peak is narrow.
   // findpars() must be called before this function.

   const int MAXDEG = 40;        // arraysize
   int degree;                   // max expansion degree
   double accur;                 // stop expansion when terms below this threshold
   double f0;                    // factor outside integral
   double rho[MAXCOLORS];        // r*omegai
   double qi;                    // 2^(-rho)
   double qi1;                   // 1-qi
   double qq[MAXCOLORS];         // qi / qi1
   double eta[MAXCOLORS+1][MAXDEG+1]; // eta coefficients
   double phideri[MAXDEG+1];     // derivatives of phi
   double PSIderi[MAXDEG+1];     // derivatives of PSI
   double * erfresp;             // pointer to table of error function residues

   // variables in asymptotic summation
   static const double sqrt8  = 2.828427124746190098; // sqrt(8)
   double qqpow;                 // qq^j
   double pow2k;                 // 2^k
   double bino;                  // binomial coefficient  
   double vr;                    // 1/v, v = integration interval
   double v2m2;                  // (2*v)^(-2)
   double v2mk1;                 // (2*v)^(-k-1)
   double s;                     // summation term
   double sum;                   // Taylor sum

   int i;                        // loop counter for color
   int j;                        // loop counter for derivative
   int k;                        // loop counter for expansion degree
   int ll;                       // k/2
   int converg = 0;              // number of consequtive terms below accuracy
   int PrecisionIndex;           // index into ErfRes table according to desired precision

   // initialize
   for (k = 0; k <= 2; k++)  phideri[k] = PSIderi[k] = 0;

   // find rho[i], qq[i], first eta coefficients, and zero'th derivative of phi
   for (i = 0; i < colors; i++) {
      rho[i] = r * omega[i];
      if (rho[i] == 0.) continue;
      if (rho[i] > 40.) {
         qi=0.;  qi1 = 1.;   // avoid underflow
      }
      else {
         qi1 = pow2_1(-rho[i], &qi);   // qi=2^(-rho), qi1=1.-2^(-rho)
      }
      qq[i] = qi / qi1;    // 2^(-r*omegai)/(1.-2^(-r*omegai))
      // peak = zero'th derivative
      phideri[0] += x[i] * log1mx(qi, qi1);
      // eta coefficients
      eta[i][0] = 0.;
      eta[i][1] = eta[i][2] = rho[i]*rho[i];
   }

   // d, r, and w must be calculated by findpars()
   // zero'th derivative
   phideri[0] -= (rd - 1.) * LN2;
   // scaled factor outside integral
   f0 = rd * exp(phideri[0] + lnbico());
   // calculate narrowed integration interval
   vr = sqrt8 * w;
   phideri[2] = phi2d;

   // get table according to desired precision
   PrecisionIndex = (-FloorLog2((float)accuracy) - ERFRES_B + ERFRES_S - 1) / ERFRES_S;
   if (PrecisionIndex < 0) PrecisionIndex = 0;
   if (PrecisionIndex > ERFRES_N-1) PrecisionIndex = ERFRES_N-1;
   while (w * NumSDev[PrecisionIndex] > 0.3) { 
      // check if integration interval is too wide
      if (PrecisionIndex == 0) {
         FatalError("Laplace method failed. Peak width too high in function CWalleniusNCHypergeometric::laplace");
         break;
      }
      PrecisionIndex--;                  // reduce precision to keep integration interval narrow
   }
   erfresp = ErfRes[PrecisionIndex];    // choose desired table

   degree = MAXDEG;                     // max expansion degree
   if (degree >= ERFRES_L*2) degree = ERFRES_L*2-2;

   // set up for starting loop at k=3
   v2m2 = 0.25 * vr * vr;               // (2*v)^(-2)
   PSIderi[0] = 1.;
   pow2k = 8.;
   sum = 0.5 * vr * erfresp[0];
   v2mk1 = 0.5 * vr * v2m2 * v2m2;
   accur = accuracy * sum;

   // summation loop
   for (k = 3; k <= degree; k++) {
      phideri[k] = 0.;

      // loop for all colors
      for (i = 0; i < colors; i++) {
         if (rho[i] == 0.) continue;
         eta[i][k] = 0.;
         // backward loop for all powers
         for (j = k; j > 0; j--) {
            // find coefficients recursively from previous coefficients
            eta[i][j]  =  eta[i][j]*(j*rho[i]-(k-2)) +  eta[i][j-1]*rho[i]*(j-1);
         }
         qqpow = 1.;
         // forward loop for all powers
         for (j = 1; j <= k; j++) {
            qqpow *= qq[i];   // qq^j
            // contribution to derivative
            phideri[k] += x[i] * eta[i][j] * qqpow;
         }
      }

      // finish calculation of derivatives
      phideri[k] = -pow2k * phideri[k] + 2*(1-k)*phideri[k-1];

      pow2k *= 2.;    // 2^k

      // loop to calculate derivatives of PSI from derivatives of psi.
      // terms # 0, 1, 2, k-2, and k-1 are zero and not included in loop.
      // The j'th derivatives of psi are identical to the derivatives of phi for j>2, and
      // zero for j=1,2. Hence we are using phideri[j] for j>2 here.
      PSIderi[k] = phideri[k];           // this is term # k
      bino = 0.5 * (k-1) * (k-2);        // binomial coefficient for term # 3
      for (j=3; j < k-2; j++) { // loop for remaining nonzero terms (if k>5)
         PSIderi[k] += PSIderi[k-j] * phideri[j] * bino;
         bino *= double(k-j)/double(j);
      }

      if ((k & 1) == 0) { // only for even k
         ll = k/2;
         s = PSIderi[k] * v2mk1 * erfresp[ll];
         sum += s;

         // check for convergence of Taylor expansion
         if (fabs(s) < accur) converg++; else converg = 0;
         if (converg > 1) break;

         // update recursive expressions
         v2mk1 *= v2m2;
      }
   }

   // multiply by terms outside integral  
   return f0 * sum;
}


double CMultiWalleniusNCHypergeometric::integrate(void) {
   // Wallenius non-central hypergeometric distribution function
   // calculation by numerical integration with variable-length steps
   // NOTE: findpars() must be called before this function.
   double s;                            // result of integration step
   double sum;                          // integral
   double ta, tb;                       // subinterval for integration step

   lnbico();                            // compute log of binomial coefficients

   // choose method:
   if (w < 0.02) {
      // normal method. Step length determined by peak width w
      double delta, s1;
      s1 = accuracy < 1E-9 ? 0.5 : 1.;
      delta = s1 * w;                    // integration steplength
      ta = 0.5 + 0.5 * delta;
      sum = integrate_step(1.-ta, ta);   // first integration step around center peak
      do {
         tb = ta + delta;
         if (tb > 1.) tb = 1.;
         s  = integrate_step(ta, tb);     // integration step to the right of peak
         s += integrate_step(1.-tb,1.-ta);// integration step to the left of peak
         sum += s;
         if (s < accuracy * sum) break;   // stop before interval finished if accuracy reached
         ta = tb;
         if (tb > 0.5 + w) delta *= 2.;   // increase step length far from peak
      }
      while (tb < 1.);
   }

   else {
      // difficult situation. Step length determined by inflection points
      double t1, t2, tinf, delta, delta1;
      sum = 0.;
      // do left and right half of integration interval separately:
      for (t1=0., t2=0.5; t1 < 1.; t1+=0.5, t2+=0.5) { 
         // integrate from 0 to 0.5 or from 0.5 to 1
         tinf = search_inflect(t1, t2);   // find inflection point
         delta = tinf - t1; if (delta > t2 - tinf) delta = t2 - tinf; // distance to nearest endpoint
         delta *= 1./7.;                  // 1/7 will give 3 steps to nearest endpoint
         if (delta < 1E-4) delta = 1E-4;
         delta1 = delta;
         // integrate from tinf forwards to t2
         ta = tinf;
         do {
            tb = ta + delta1;
            if (tb > t2 - 0.25*delta1) tb = t2; // last step of this subinterval
            s = integrate_step(ta, tb);         // integration step
            sum += s;
            delta1 *= 2;                        // double steplength
            if (s < sum * 1E-4) delta1 *= 8.;   // large step when s small
            ta = tb;
         }
         while (tb < t2);
         if (tinf) {
            // integrate from tinf backwards to t1
            tb = tinf;
            do {
               ta = tb - delta;
               if (ta < t1 + 0.25*delta) ta = t1; // last step of this subinterval
               s = integrate_step(ta, tb);        // integration step
               sum += s;
               delta *= 2;                        // double steplength
               if (s < sum * 1E-4) delta *= 8.;   // large step when s small
               tb = ta;
            }
            while (ta > t1);
         }
      }
   }
   return sum * rd;
}


double CMultiWalleniusNCHypergeometric::integrate_step(double ta, double tb) {
   // integration subprocedure used by integrate()
   // makes one integration step from ta to tb using Gauss-Legendre method.
   // result is scaled by multiplication with exp(bico)
   double ab, delta, tau, ltau, y, sum, taur, rdm1;
   int i, j;

   // define constants for Gauss-Legendre integration with IPOINTS points
#define IPOINTS  8  // number of points in each integration step

#if   IPOINTS == 3
   static const double xval[3]    = {-.774596669241,0,0.774596668241};
   static const double weights[3] = {.5555555555555555,.88888888888888888,.55555555555555};
#elif IPOINTS == 4
   static const double xval[4]    = {-0.861136311594,-0.339981043585,0.339981043585,0.861136311594},
      static const double weights[4] = {0.347854845137,0.652145154863,0.652145154863,0.347854845137};
#elif IPOINTS == 5
   static const double xval[5]    = {-0.906179845939,-0.538469310106,0,0.538469310106,0.906179845939};
   static const double weights[5] = {0.236926885056,0.478628670499,0.568888888889,0.478628670499,0.236926885056};
#elif IPOINTS == 6
   static const double xval[6]    = {-0.932469514203,-0.661209386466,-0.238619186083,0.238619186083,0.661209386466,0.932469514203};
   static const double weights[6] = {0.171324492379,0.360761573048,0.467913934573,0.467913934573,0.360761573048,0.171324492379};
#elif IPOINTS == 8
   static const double xval[8]    = {-0.960289856498,-0.796666477414,-0.525532409916,-0.183434642496,0.183434642496,0.525532409916,0.796666477414,0.960289856498};
   static const double weights[8] = {0.10122853629,0.222381034453,0.313706645878,0.362683783378,0.362683783378,0.313706645878,0.222381034453,0.10122853629};
#elif IPOINTS == 12
   static const double xval[12]   = {-0.981560634247,-0.90411725637,-0.769902674194,-0.587317954287,-0.367831498998,-0.125233408511,0.125233408511,0.367831498998,0.587317954287,0.769902674194,0.90411725637,0.981560634247};
   static const double weights[12]= {0.0471753363866,0.106939325995,0.160078328543,0.203167426723,0.233492536538,0.249147045813,0.249147045813,0.233492536538,0.203167426723,0.160078328543,0.106939325995,0.0471753363866};
#elif IPOINTS == 16
   static const double xval[16]   = {-0.989400934992,-0.944575023073,-0.865631202388,-0.755404408355,-0.617876244403,-0.458016777657,-0.281603550779,-0.0950125098376,0.0950125098376,0.281603550779,0.458016777657,0.617876244403,0.755404408355,0.865631202388,0.944575023073,0.989400934992};
   static const double weights[16]= {0.027152459411,0.0622535239372,0.0951585116838,0.124628971256,0.149595988817,0.169156519395,0.182603415045,0.189450610455,0.189450610455,0.182603415045,0.169156519395,0.149595988817,0.124628971256,0.0951585116838,0.0622535239372,0.027152459411};
#else
#error // IPOINTS must be a value for which the tables are defined
#endif

   delta = 0.5 * (tb - ta);
   ab = 0.5 * (ta + tb);
   rdm1 = rd - 1.;
   sum = 0;

   for (j = 0; j < IPOINTS; j++) {
      tau = ab + delta * xval[j];
      ltau = log(tau);
      taur = r * ltau;
      y = 0.;
      for (i = 0; i < colors; i++) {
         // possible loss of precision due to subtraction here:
         if (omega[i]) {
            y += log1pow(taur*omega[i],x[i]);   // ln((1-e^taur*omegai)^xi)
         }
      }
      y += rdm1*ltau + bico;
      if (y > -50.) sum += weights[j] * exp(y);
   }
   return delta * sum;
}


double CMultiWalleniusNCHypergeometric::search_inflect(double t_from, double t_to) {
   // search for an inflection point of the integrand PHI(t) in the interval
   // t_from < t < t_to
   double t, t1;                        // independent variable
   double rho[MAXCOLORS];               // r*omega[i]
   double q;                            // t^rho[i] / (1-t^rho[i])
   double q1;                           // 1-t^rho[i]
   double zeta[MAXCOLORS][4][4];        // zeta[i,j,k] coefficients
   double phi[4];                       // derivatives of phi(t) = log PHI(t)
   double Z2;                           // PHI''(t)/PHI(t)
   double Zd;                           // derivative in Newton Raphson iteration
   double rdm1;                         // r * d - 1
   double tr;                           // 1/t
   double log2t;                        // log2(t)
   double method;                       // 0 for z2'(t) method, 1 for z3(t) method
   int i;                               // color
   int iter;                            // count iterations

   rdm1 = rd - 1.;
   if (t_from == 0 && rdm1 <= 1.) return 0.; //no inflection point
   t = 0.5 * (t_from + t_to);
   for (i = 0; i < colors; i++) {            // calculate zeta coefficients
      rho[i] = r * omega[i];
      zeta[i][1][1] = rho[i];
      zeta[i][1][2] = rho[i] * (rho[i] - 1.);
      zeta[i][2][2] = rho[i] * rho[i];
      zeta[i][1][3] = zeta[i][1][2] * (rho[i] - 2.);
      zeta[i][2][3] = zeta[i][1][2] * rho[i] * 3.;
      zeta[i][3][3] = zeta[i][2][2] * rho[i] * 2.;
   }
   iter = 0;

   do {
      t1 = t;
      tr = 1. / t;
      log2t = log(t)*(1./LN2);
      phi[1] = phi[2] = phi[3] = 0.;
      for (i=0; i<colors; i++) {         // calculate first 3 derivatives of phi(t)
         if (rho[i] == 0.) continue;
         q1 = pow2_1(rho[i]*log2t,&q);
         q /= q1;
         phi[1] -= x[i] * zeta[i][1][1] * q;
         phi[2] -= x[i] * q * (zeta[i][1][2] + q * zeta[i][2][2]);
         phi[3] -= x[i] * q * (zeta[i][1][3] + q * (zeta[i][2][3] + q * zeta[i][3][3]));
      }
      phi[1] += rdm1;
      phi[2] -= rdm1;
      phi[3] += 2. * rdm1;
      phi[1] *= tr;
      phi[2] *= tr * tr;
      phi[3] *= tr * tr * tr;
      method = (iter & 2) >> 1;          // alternate between the two methods
      Z2 = phi[1]*phi[1] + phi[2];
      Zd = method*phi[1]*phi[1]*phi[1] + (2.+method)*phi[1]*phi[2] + phi[3];

      if (t < 0.5) {
         if (Z2 > 0) {
            t_from = t;
         }
         else {
            t_to = t;
         }
         if (Zd >= 0) { 
            // use binary search if Newton-Raphson iteration makes problems
            t = (t_from ? 0.5 : 0.2) * (t_from + t_to);
         }
         else {
            // Newton-Raphson iteration
            t -= Z2 / Zd;
         }
      }
      else {
         if (Z2 < 0) {
            t_from = t;
         }
         else {
            t_to = t;
         }
         if (Zd <= 0) {
            // use binary search if Newton-Raphson iteration makes problems
            t = 0.5 * (t_from + t_to);
         }
         else {
            // Newton-Raphson iteration
            t -= Z2 / Zd;
         }
      }
      if (t >= t_to) t = (t1 + t_to) * 0.5;
      if (t <= t_from) t = (t1 + t_from) * 0.5;
      if (++iter > 20) FatalError("Search for inflection point failed in function CMultiWalleniusNCHypergeometric::search_inflect");
   }
   while (fabs(t - t1) > 1E-5);
   return t;
}


double CMultiWalleniusNCHypergeometric::probability(int32 * x_) {
   // calculate probability function. choosing best method
   int i, j, em;
   int32 xsum;
   x = x_;

   for (xsum = i = 0; i < colors; i++)  xsum += x[i];
   if (xsum != n) {
      FatalError("sum of x values not equal to n in function CMultiWalleniusNCHypergeometric::probability");
   }

   if (colors < 3) { 
      if (colors <= 0) return 1.;
      if (colors == 1) return x[0] == m[0];
      // colors = 2
      if (omega[1] == 0.) return x[0] == m[0];
      return CWalleniusNCHypergeometric(n,m[0],N,omega[0]/omega[1],accuracy).probability(x[0]);
   }

   for (i = j = em = 0; i < colors; i++) {
      if (x[i] > m[i] || x[i] < 0 || x[i] < n - N + m[i]) return 0.;
      if (x[i] > 0) j++;
      if (omega[i] == 0. && x[i]) return 0.;
      if (x[i] == m[i] || omega[i] == 0.) em++;
   }

   if (n == 0 || em == colors) return 1.;

   if (j == 1) { 
      return binoexpand();
   }

   findpars();
   if (w < 0.04 && E < 10 && (!em || w > 0.004)) {
      return laplace();
   }

   return integrate();
}


/***********************************************************************
Methods for CMultiWalleniusNCHypergeometricMoments
***********************************************************************/

double CMultiWalleniusNCHypergeometricMoments::moments(double * mu, double * variance, int32 * combinations) {
   // calculates mean and variance of multivariate Wallenius noncentral 
   // hypergeometric distribution by calculating all combinations of x-values.
   // Return value = sum of all probabilities. The deviation of this value 
   // from 1 is a measure of the accuracy.
   // Returns the mean to mean[0...colors-1]
   // Returns the variance to variance[0...colors-1]
   double sumf;               // sum of all f(x) values
   int32 msum;                // temporary sum
   int i;                     // loop counter

   // get approximate mean
   mean(sx);
   // round mean to integers
   for (i=0; i < colors; i++) {
      xm[i] = (int32)(sx[i]+0.4999999);
   }

   // set up for recursive loops
   for (i=colors-1, msum=0; i >= 0; i--) {
      remaining[i] = msum;  msum += m[i];
   }
   for (i=0; i<colors; i++)  sx[i] = sxx[i] = 0.;
   sn = 0;

   // recursive loops to calculate sums  
   sumf = loop(n, 0);

   // calculate mean and variance
   for (i = 0; i < colors; i++) {
      mu[i] = sx[i]/sumf;
      variance[i] = sxx[i]/sumf - sx[i]*sx[i]/(sumf*sumf);
   }

   // return combinations and sum
   if (combinations) *combinations = sn;
   return sumf;
}


double CMultiWalleniusNCHypergeometricMoments::loop(int32 n, int c) {
   // recursive function to loop through all combinations of x-values.
   // used by moments()
   int32 x, x0;                         // x of color c
   int32 xmin, xmax;                    // min and max of x[c]
   double s1, s2, sum = 0.;             // sum of f(x) values
   int i;                               // loop counter

   if (c < colors-1) {
      // not the last color
      // calculate min and max of x[c] for given x[0]..x[c-1]
      xmin = n - remaining[c];  if (xmin < 0) xmin = 0;
      xmax = m[c];  if (xmax > n) xmax = n;
      x0 = xm[c];  if (x0 < xmin) x0 = xmin;  if (x0 > xmax) x0 = xmax;
      // loop for all x[c] from mean and up
      for (x = x0, s2 = 0.; x <= xmax; x++) {
         xi[c] = x;
         sum += s1 = loop(n-x, c+1); // recursive loop for remaining colors
         if (s1 < accuracy && s1 < s2) break; // stop when values become negligible
         s2 = s1;
      }
      // loop for all x[c] from mean and down
      for (x = x0-1; x >= xmin; x--) {
         xi[c] = x;
         sum += s1 = loop(n-x, c+1); // recursive loop for remaining colors
         if (s1 < accuracy && s1 < s2) break; // stop when values become negligible
         s2 = s1;
      }
   }
   else {
      // last color
      xi[c] = n;
      s1 = probability(xi);
      for (i=0; i < colors; i++) {
         sx[i]  += s1 * xi[i];
         sxx[i] += s1 * xi[i] * xi[i];
      }
      sn++;
      sum = s1;
   }
   return sum;
}



//SYSTEM FUNCTIONS
void continueOrExit()  
//utility function used to ask the user whether they wish to continue to program of exit(1)
{
 std::cout<<"Do you wish to continue [(y)es or (n)o] ?"<<std::endl;
 char ans = 'q';
 while((ans != 'y') && (ans != 'n'))
  std::cin>>ans;

 if(ans == 'n')
  exit(1);
}

void writeOutPipelineGoFile(std::string ofname) 
//a hack to work around a bug in the pipeline.  It writes out a simple txt file with the word GO
{

 std::ofstream ofile(ofname.c_str(), std::ios::out);
 ofile << "GO!";

#if VERBOSE
 std::cout<<"Done!"<<std::endl;
#endif

 ofile.close();


}


OSType getOSType()
//determines the type of the operating system and returns the result as a enumerated type OSType
{
 
 OSType ostype = UNKNOWNOS;  //defaults to an unknown OS

 #if _WIN32  //for Win32
  ostype = WIN;
 #elif __MACH__ //Mac OSX
  ostype = OSX;
 #elif sun || __sun  //SunOS
  ostype = OSX;
 #else PIPELINE  //OS for the pipeline
  ostype = OSX; 
 #endif

#if ERRORCHECK
 if(ostype == UNKNOWNOS)
 {
  std::cout<<"ERROR in OSType getOSType()"<<std::endl;
  std::cout<<"OS Type is not known"<<std::endl;
  exit(1);
 }
#endif

 return ostype;
}

CompilerType getCompilerType()
//determines the type of the compiler and returns the result as a enumerated type CompilerType
{

 CompilerType comtype = UNKNOWNCOMPILER;  //defaults to an unknown OS

 #if _MSC_VER  //Microsoft VS compiler
  comtype = MSVS;
 #elif __GNUC__  //GNU compiler
  comtype = hageman::GNU;
 #endif

#if ERRORCHECK
 if(comtype == UNKNOWNCOMPILER)
 {
  std::cout<<"ERROR in CompilerType getCompilerType()"<<std::endl;
  std::cout<<"Compiler Type is not known"<<std::endl;
  exit(1);
 }
#endif

 return comtype;

}



//STRING/CHARACTER PROCESSING FUNCTIONS
template<>
void convertVectorOfStringsToArray<double>(const std::vector<std::string> &data, double*& dataarray, hageman::AllocateMem memflag)  
//this instantiation of the above general function uses atof to perform the conversion from string to double
{

 //checks whether memory needs to be allocated to dataarray
 if(memflag != NOALLOCATE)
 {
  const int ARRAYSIZE = data.size();
  hageman::allocateMem(dataarray,ARRAYSIZE,memflag);
 }

 //converts each string from data into a double
 for(int idx = 0; idx < data.size(); idx++)
 {
  dataarray[idx] = atof((data.at(idx)).c_str());
 }

}



void addATrailingZeroIfNeeded(std::string &data) 
//adds a trailing zero to a string that ends with a .
{
 if(data.at(data.size()-1) == '.')
  data.append("0");
 
}


void stripQuotes(std::string &input)
//function which strips off the quotation marks on the ends of arguments on the command line.  Quotations are common in CL arguments, especially to specify args with spaces
//if the input is empty, then no changes are made
{
 if(!input.empty())
 {
  if(*(input.begin()) == '\"')
   input.erase(input.begin());
  if(*(input.end() - 1) == '\"')
   input.erase(input.end()-1);
 }
 
#if VALIDATE
 std::cout<<"From function void stripQuotes(std::string &input)"<<std::endl;
 std::cout<<"Final result: "<<input<<std::endl;
#endif

 
}

void addPrecedingDot(std::string &input) 
//adds a preceding dot to input.  if input is empty, it is returned unchanged.
{

 if(!input.empty())
 {
  if(input.at(0) != '.')
  {
   input.insert(0,".");
  }
 }
#if ERRORCHECK
 else
 {
  std::cout<<"ERROR in void addPrecedingDot(std::string &input)"<<std::endl;
  std::cout<<"Input is empty."<<std::endl;
  exit(1);
 }
#endif



}

void addTerminatingBackslashToDirectoryString(std::string &input) 
//function which adds a terminating backslash to anything it considers a directory.  Strings specifying directories that are fed to other program/functions
//often must have a terminating backslash.  This function identifies input as a directory and adds a backslash if input fullfills the following requirements
//(1) Must start with a drive letter (searches for : as the second letter and \ as the third letter (Win32 only)
//(2) Must not end with a .??? which would specify a filename (searches for a . at the fourth to last character)
//if the function determines that input is not a directory, then it is unchanged
{
 //removes any empty whitespaces from the beginning or end of the string
 hageman::removeTrailingWhitespaces(input);
 hageman::removePrecedingWhitespaces(input);
 
 //if the platform is Windows, the directory argument is assumed to begin with the drive letter
 if(hageman::getOSType() == hageman::WIN)  //Windows-specific
 {
  //checks to makes sure the size of the string is sufficient to encode a directory.  The smallest possible string would be
  //4 characters (C:\?).  If not big enough, just return the original input string
  if(input.size() < 4)  
   return;

#if VALIDATE
  std::cout<<"From void addTerminatingBackslashToDirectoryString(std::string &input)"<<std::endl;
  std::cout<<"input.at(1): "<<(input.at(1) == ':')<<std::endl;
  std::cout<<"input.at(2): "<<(input.at(2) == '\\')<<std::endl;
  if(input.rfind(".") != std::string::npos)
   std::cout<<"Period found!"<<std::endl;
  else 
   std::cout<<"Period not found"<<std::endl;
#endif

  //checks to make sure that the directory string follows the format ?:\? with no file extension .*  FILE CANNOT HAVE MULTIPLE . WITHIN IT
  if((input.at(1) == ':') && (input.at(2) == '\\') && (input.rfind(".") == std::string::npos))  
  {
   if((input.at(input.size()-1)) != '\\')  //if it already has a terminating backslash, just return it; otherwise, add a backslash
    input.append("\\");
  }
 }
 //if the platform is Mac, the directory argument is assumed to begin with the drive letter
 else if(hageman::getOSType() == hageman::OSX)
 {
  //if the input string is empty, just return it
  if(input.empty())
   return;
   
  //Mac directories must begin with a / or a ./; 
  if((input.at(0) == '/') || (input.substr(0,1) == "./")) 
  {
   //Also, checks whether a file extension is present.  if so, then just return the string
   if((input.rfind(".") == std::string::npos) || (input.rfind(".") == 0))  //checks whether a . is in the string that is not at the beginning 
   {
    if((input.at(input.size()-1)) != '/')  //if it already has a terminating backslash, just return it; otherwise, add a backslash
     input.append("/");
   }
  }
  
 }
#if ERRORCHECK
 else
 {
  std::cout<<"WARNING in void addTerminatingBackslashToDirectoryString(std::string &input) "<<std::endl;
  std::cout<<"No valid OS type"<<std::endl;
  exit(1);
 }
#endif

 
#if VALIDATE
 std::cout<<"From function std::string addTerminatingBackslashToDirectoryString(const std::string &input)"<<std::endl;
 std::cout<<"Final output: "<<input<<std::endl;
#endif 


 
}


void removeTerminatingBackslashFromDirectoryString(std::string &input)
//function which removes a terminating backslash from anything it considers a directory.  Strings specifying directories that are fed to other program/functions
//often must have a terminating backslash.  This function identifies input as a directory and adds a backslash if input fullfills two requirements
//(1) Must start with a drive letter (searches for : as the second letter and \ as the third letter
//(2) Must not end with a .??? which would specify a filename (searches for a . at the fourth to last character)
//if the function determines that input is not a directory, then it is unchanged
{

 //removes any empty whitespaces from the beginning or end of the string
 hageman::removeTrailingWhitespaces(input);
 hageman::removePrecedingWhitespaces(input);

 //if the platform is Windows, the directory argument is assumed to begin with the drive letter
 if(hageman::getOSType() == hageman::WIN)  //Windows-specific
 {
  //checks to makes sure the size of the string is sufficient to encode a directory.  The smallest possible string would be
  //4 characters (C:\?).  If not big enough, just return the original input string
  if(input.size() < 4)  
   return;


  //checks to make sure that the directory string follows the format ?:\? with no file extension .*  FILE CANNOT HAVE MULTIPLE . WITHIN IT
  if((input.at(1) == ':') && (input.at(2) == '\\') && (input.rfind(".") != std::string::npos))  
  {
   if((input.at(input.size()-1)) == '\\')  //if it already has a terminating backslash, just return it; otherwise, add a backslash
    input.erase(input.size()-1,1);
  }
 }
 //if the platform is Mac, the directory argument is assumed to begin with the drive letter
 else if(hageman::getOSType() == hageman::OSX)
 {
  //if the input string is empty, just return it
  if(input.empty())
   return;
   
  //Mac directories must begin with a / or a ./; 
  if((input.at(0) == '/') || (input.substr(0,1) == "./")) 
  {
   //Also, checks whether a file extension is present.  if so, then just return the string
   if((input.rfind(".") != std::string::npos) && (input.rfind(".") != 0))  //checks whether a . is in the string that is not at the beginning 
   {
    if((input.at(input.size()-1)) == '/')  //if it already has a terminating backslash, just return it; otherwise, add a backslash
     input.erase(input.size()-1,1);
   }
  }
  
 }
#if ERRORCHECK
 else
 {
  std::cout<<"WARNING in void removeTerminatingBackslashFromDirectoryString(std::string &input)"<<std::endl;
  std::cout<<"No valid OS type"<<std::endl;
  exit(1);
 }
#endif

 
#if VALIDATE
 std::cout<<"From function void removeTerminatingBackslashFromDirectoryString(std::string &input)"<<std::endl;
 std::cout<<"Output: "<<input<<std::endl;
#endif 

 
}

void removedPrecedingDotFromExtension(std::string &ext)
//removes the . from an arbitrary extension.  if ext is not an extension (.*), then it is unchanged
{
 if(ext.at(0) == '.')
  ext.erase(0,1);
#if ERRORCHECK
 else
 {
  std::cout<<"WARNING in void removedPrecedingDotFromExtension(std::string &ext)"<<std::endl;
  std::cout<<"ext = "<<ext<<" is not an extension"<<std::endl;
  std::cout<<"ext has not be altered"<<std::endl;
 }
#endif


}


void removePrecedingNonDigitChars(std::string &input)  
//removes all the non-number characters from input
{
 while((!isdigit(input.at(0))) && (input.at(0) != '-'))  //removes all preceding non-digit chars
   input.erase(0,1);


}


void removeTerminatingNonDigitChars(std::string &input)  
//removes all the non-number characters from input
{
 while(!isdigit(input.at(input.size()-1)))  //removes all preceding non-digit chars
   input.erase(input.size()-1);


}



bool doesStringBeginWith(const std::string &teststr, char test)  
//returns true if the string begins with test
{
 return((*(teststr.begin())) == test);  //invoking the iterator built into std::string


}


//PARSING/CONVERSION FUNCTIONS 

template<>
void parseLineOfNumbers<double>(double*& results, const int NUMSIZE, std::string textline, std::string delim, AllocateMem memflag)
//a templated function for parsing a string of text as a series of NUMSIZE numbers of datatype T, each separated by a space
{

#if ERRORCHECK
 if(textline.empty())
 {
  std::cout<<"WARNING in void parseLineOfNumbers<double>(std::string textline, double*& results, const int NUMSIZE, std::string delim, AllocateMem memflag)"<<std::endl;
  std::cout<<"String was empty - no action taken"<<std::endl;
  return;
 }
#endif
 
 //checks whether memory needs to be allocated to results
 if(memflag != NOALLOCATE)
 {
  hageman::allocateMem(results,NUMSIZE,memflag);
 }
 
 //removes whitespaces for before or after the string
 hageman::removePrecedingWhitespaces(textline);
 hageman::removeTrailingWhitespaces(textline);
 
 std::string numstr;
 int idx = 0;

 while((textline.find(delim) != std::string::npos) && (idx < NUMSIZE))  //searching for delimiter
 {
  numstr = textline.substr(0,textline.find(delim));  
  results[idx] = static_cast<double>(atof(numstr.c_str()));  //uses atof to convert numstr to a float/double

#if VALIDATE
  std::cout<<"Results[idx]: "<<results[idx]<<std::endl;
  std::cout<<"Numstr: "<<numstr<<std::endl;
#endif

  textline.erase(0, textline.find(delim)+1);  //erases everything up to the current first delimiter
  hageman::removePrecedingWhitespaces(textline); //removes any additional whitespaces that may be between elements
  

  numstr.clear();
  idx++;
   
 }

 //if there is one remaining item (no delim is present), then need to convert the one remaining element
 if(textline.find(delim) == std::string::npos)
 {
  hageman::removePrecedingWhitespaces(textline); //removes any additional whitespaces that may be between elements
  results[idx] = static_cast<double>(atof(textline.c_str()));  //uses atof to convert numstr to a float/doubletextline
  idx++;
 }

//checks whether the number of converted substrings is equal to the specified arraysize NUMSIZE
#if ERRORCHECK
 if(idx != NUMSIZE)
 {
   std::cout<<"ERROR in void parseLineOfNumbers(std::string textline, T*& results, int NUMSIZE, std::string delim = " ", AllocateMem memflag = NOALLOCATE)"<<std::endl;
   std::cout<<"Number of elements (idx) not equal to specified array size.  Exiting..."<<std::endl;
   exit(1);
 }
#endif
  
}




template<>
void parseLineOfNumbers<double>(std::string textline, std::vector<double> &results, std::string delim) 
//a templated function for parsing a string of text as a series of NUMSIZE numbers of datatype T, each separated by delim
{

 if(!textline.empty())
 {
  std::string numstr;
 
  while(textline.find(delim) != std::string::npos)
  {
   numstr = textline.substr(0,textline.find(delim));
   results.push_back(static_cast<double>(atof(numstr.c_str())));
   textline.erase(0, textline.find(delim)+1);
   hageman::removePrecedingWhitespaces(textline); //removes any additional whitespaces that may be between elements
   numstr.clear();
   
  }

  numstr = textline.substr(0,textline.find(delim));
  results.push_back(static_cast<double>(atof(numstr.c_str())));
 
 }
 
}


void replaceFileExtension(std::string &input, std::string extension)
//replaces the file extension (everything after the .)(does not assume length on file ext).  if the input string does not contain a valid extension, then it is unchanged
{

#if ERRORCHECK
 if(input.empty())
 {
  std::cout<<"ERROR in std::string replaceFileExtension(std::string input, std::string extension)"<<std::endl;
  std::cout<<"String is empty.  Cannot perform file extension replacement.  Exiting..."<<std::endl;
  exit(1);
 }
#endif

#if ERRORCHECK
 if(input.rfind(".") == std::string::npos)
 {
  std::cout<<"WARNING in void replaceFileExtension(std::string &input, const std::string &extension)"<<std::endl;
  std::cout<<"Input = "<<input<<std::endl;
  std::cout<<"This is not a input with a proper file extension.  Cannot perform file extension replacement.  Input is unchanged."<<std::endl;
 }
#endif
 

 if(input.rfind(".") != std::string::npos)  //if the input has .* already
 {
  if(extension.at(0) != '.')  //if the extension doesnt have a . in front, then add one
   extension = std::string(".") + extension;
  
  input.replace(input.rfind("."),input.size()-1,extension);
 }


}

void removeTrailingWhitespaces(std::string &result)
//removes all trailing white spaces from input.  If the input has no whitespaces or is empty, the original string is returned unchanged.
{

 if(!result.empty())  //checks to make sure that the input is now empty; not part of ERRORCHECK b/c empty string is still valid
 {
  int idx = result.size();
 
  while(isspace(result.at(idx-1)))
  {
   result.erase(idx-1,1);
   idx = result.size();

   if(result.empty())  //if the result is now empty, just return the now empty string
    return;
  }
 }

#if VALIDATE
 std::cout<<"From function void removeTrailingWhitespaces(std::string &result)"<<std::endl;
 std::cout<<"Final Result: "<<result<<std::endl;
 std::cout<<"Final Result Size: "<<result.size()<<std::endl;
#endif


}

void removePrecedingWhitespaces(std::string &result)
//removes all preceding white spaces from the input.  If the input has no whitespaces or is empty, the original string is returned unchanged.
{

 if(!result.empty())  //checks to make sure that the input is now empty; not part of ERRORCHECK b/c empty string is still valid
 {
  while(isspace(result.at(0)))
  {
   result.erase(0,1);

   if(result.empty())  //if the result is now empty, just return the now empty string
    return;
  }
 }

#if VALIDATE
 std::cout<<"From function void removePrecedingWhitespaces(std::string &result)"<<std::endl;
 std::cout<<"Final Result: "<<result<<std::endl;
 std::cout<<"Final Result Size: "<<result.size()<<std::endl;
#endif


}

void removeWhitespaces(std::string &result)  
//removes the all the whitespaces from the string input
{
 hageman::removePrecedingWhitespaces(result);
 hageman::removeTrailingWhitespaces(result);

 if(result.empty())  //if the result is now empty, just return the now empty string
  return;

 std::remove(result.begin(), result.end(), ' ');

}



std::string getFileNameMinusPath(const std::string &input)  
//stripes off the path and returns just the filename.  The input is not changed.
{

#if ERRORCHECK
 if(input.empty())
 {
  std::cout<<"ERROR in std::string getFileNameMinusPath(const std::string &input)"<<std::endl;
  std::cout<<"String is empty.  Cannot return filename.  Exiting..."<<std::endl;
  exit(1);
 }
#endif
 
 std::string fnameonly(input);
 hageman::addTerminatingBackslashToDirectoryString(fnameonly);  //adds terminating backslash to anything it considers a directory; if not a directory, then fnameonly is not changed

 //if OS in Windows, then the directory should end with a backslash
 if(hageman::getOSType() == hageman::WIN)  //Windows-specific
 {
  if(fnameonly.rfind("\\") != std::string::npos)  //searches for the last backslash and returns everything in front of it; if none is found, then the input is not changed
  {  
   fnameonly = fnameonly.substr(fnameonly.rfind("\\")+1,fnameonly.size()-1);
  }
 }
 //if OS in Mac, then the directory should end with a forward slash
 else if(hageman::getOSType() == hageman::OSX)
 {
  if(fnameonly.rfind("/") != std::string::npos)  //searches for the last backslash and returns everything in front of it; if none is found, then the input is not changed
  {  
   fnameonly = fnameonly.substr(fnameonly.rfind("/")+1,fnameonly.size()-1);
  }
 }
#if ERRORCHECK
 else
 {
  std::cout<<"ERROR in std::string getFileNameMinusPath(const std::string &input)  "<<std::endl;
  std::cout<<"No valid OS type"<<std::endl;
  exit(1);
 }
#endif

 
#if VALIDATE
 std::cout<<"From function std::string getFileNameMinusPath(const std::string &input)"<<std::endl;
 std::cout<<"Input: "<<input<<std::endl;
 std::cout<<"Filename: "<<fnameonly<<std::endl;
#endif

 return fnameonly;
 
}

std::string getFileNameMinusExtension(const std::string &input)  
//stripes off the extension and returns just the filename.  The input is not changed.  Extension is assumed to be everything after the last .
{

#if ERRORCHECK
 if(input.empty())
 {
  std::cout<<"ERROR in std::string getFileNameMinusExtension(const std::string &input)"<<std::endl;
  std::cout<<"String is empty.  Cannot return filename.  Exiting..."<<std::endl;
  exit(1);
 }
#endif

  
 std::string fnameonly(input);
 fnameonly = fnameonly.erase(fnameonly.rfind("."));

#if VALIDATE
 std::cout<<"From function getFileNameMinusExtension(const std::string &input) "<<std::endl;
 std::cout<<"Input: "<<input<<std::endl;
 std::cout<<"Filename: "<<fnameonly<<std::endl;
#endif
 
 return fnameonly;

}


template<>
bool convertToBoolean<std::string>(const std::string &input)
//converts the string input to a boolean value: values strings must be either "true" or "false" to be converted; otherwise an exception is thrown.  if conversion fails without ERRORCHECK,
//then false is returned
{
 std::string temp(input);
 hageman::removeTrailingWhitespaces(temp);
 hageman::removePrecedingWhitespaces(temp);

 if(temp == std::string("true"))
  return true;
 else if(temp == std::string("false"))
  return false;
#if ERRORCHECK
 else
 {
  std::cout<<"ERROR in bool convertToBoolean<std::string>(const std::string &input)"<<std::endl;
  std::cout<<"Input string = "<<temp<<std::endl;
  std::cout<<"This is not a valid string for conversion to a boolean value.  Exiting..."<<std::endl;
  exit(1);
 }
#endif
 
 return false;
 

}

std::string addSpaceBetweenBeforeCapitals(const std::string &input)  
//adds a space before any captial letter except the beginning of the string
{
 std::string result(input);

#if ERRORCHECK
 if(input.empty())
 {
  std::cout<<"WARNING in std::string addSpaceBetweenBeforeCapitals(const std::string &input) "<<std::endl;
  std::cout<<"String is empty. Nothing is done"<<std::endl;
 }
#endif
 
 int counter = 0; //the insert function depends on an iterator that refers idx to the original string and ignores any inserts, so a counter must be used

 for(int idx = 0; idx < input.size(); idx++)
 {
  if(idx == 0)
   continue;
  else if(isupper(input[idx]))
  {
   result.insert(idx+counter," ");
   counter++;
  }
 }

 return result;



}

int getNumberOfDataInLine(std::string cline, std::string delim)
//returns the number of individual data elements in cline that are separated by delim
{
 int resultcount = 0;

 //since the original string will be destroyed by this process, we make a temp copy
 std::string clinetemp(cline);

 //initially remove all preceding and trailing whitespaces
 hageman::removeTrailingWhitespaces(clinetemp);
 hageman::removePrecedingWhitespaces(clinetemp);

 //if the string is empty, return 0 elements
 if(cline.empty())
  return 0;

 int idx;  //the index of the search operation for delim

 //loop over all the elements in the string, always searching for delim.  As each element is found, it is counted and then erased
 while(true){
  
  //find the next delim and count the element
  idx = clinetemp.find(delim);
  resultcount++;
  
  //if the search operation failed, then break out of the loop
  if(idx == std::string::npos)
   break;
 
  //erase the element that was just found
  clinetemp.erase(0,idx+1);
  //remove any additional whitespaces that might be between the elements
  hageman::removePrecedingWhitespaces(clinetemp);
 }

#if VALIDATE
 std::cout<<"Number of data elements in the current line: "<<resultcount<<std::endl;
#endif

 return resultcount;

}


DataType convertStringToDataType(const std::string &input)
//converts a std::string to enum type Datatype.  if string is not recognized, function returns UNKNOWNTYPE
{
 DataType result = UNKNOWNTYPE;

 std::string temp(input);
 hageman::removeTrailingWhitespaces(temp);
 hageman::removePrecedingWhitespaces(temp);

 if(temp == "CHAR")
  result = CHARTYPE;
 else if(temp == "DOUBLE")
  result = DOUBLETYPE;
 else if(temp == "FLOAT")
  result = FLOATTYPE;
 else if(temp == "RGB")
  result = RGBTYPE;
 else if(temp == "SINT16")
  result = SINT16TYPE;
 else if(temp == "SINT32")
  result = SINT32TYPE;
 else if(temp == "SINT8")
  result = SINT8TYPE;
 else if(temp == "TEXT")
  result = TEXTTYPE;
 else if(temp == "UINT16")
  result = UINT16TYPE;
 else if(temp == "UINT32")
  result = UINT32TYPE;
 else if(temp == "UINT8")
  result = UINT8TYPE;
 else if(temp == "EIGEN")
  result = EIGENTYPE;
 else if(temp == "UNKNOWN")
  result = UNKNOWNTYPE;
#if ERRORCHECK
 else
 {
  std::cout<<"ERROR in Datatype convertStringToDatatype(const std::string &input)"<<std::endl;
  std::cout<<"String = "<<temp<<std::endl;
  std::cout<<"This string is not recognized as a valid datatype.  Exiting..."<<std::endl;
  exit(1);
 }
#endif
   
 return result;
}

const int getDataTypeByteSize(const DataType &dt)
//returns the size of the datatype in bytes.  if datatype is not recognized, 0 is returned
{

 int size = 0;
 
 if(dt == CHARTYPE)
  size = CHAR_SIZE;
 else if(dt == SINT32TYPE)
  size = SINT32_SIZE;
 else if(dt == FLOATTYPE)
  size = FLOAT_SIZE;
 else if(dt == UINT8TYPE)
  size = UINT8_SIZE;
 else if(dt == SINT8TYPE)
  size = SINT8_SIZE;
 else if(dt == SINT16TYPE)
  size = SINT16_SIZE;
 else if(dt == UINT16TYPE)
  size = UINT16_SIZE;
 else if(dt == DOUBLETYPE)
  size = DOUBLE_SIZE;
#if ERRORCHECK
 else
 {
  std::cout<<"ERROR in int getDataTypeSize(const DataType &dt)"<<std::endl;
  std::cout<<"Datatype = "<<dt<<std::endl;
  std::cout<<"This is not a valid datatype.  Exiting..."<<std::endl;
  exit(1);
 }
#endif
 

 return size;
}

std::string convertDataTypeToString(const DataType &dt)
//converts enumerated type, DataType, to a string.  if the DataType is not recognized, then it returns an empty string
{

 std::string result;

 switch(dt){
  case CHARTYPE:
   result = "CHAR";
   break;
  case UCHARTYPE:
   result = "UCHAR";
   break;
  case TEXTTYPE:
   result = "TEXT";
   break;
  case SINT8TYPE:
   result = "SINT8";
   break;
  case SINT16TYPE:
   result = "SINT16";
   break;
  case SINT32TYPE:
   result = "SINT32";
   break;
  case UNKNOWNTYPE:
   result = "UNKNOWN";
   break;
  case UINT8TYPE:
   result = "UINT8";
   break;
  case UINT16TYPE:
   result = "UINT16";
   break;
  case UINT32TYPE:
   result = "UINT32";
   break;
  case FLOATTYPE:
   result = "FLOAT";
   break;
  case DOUBLETYPE:
   result = "DOUBLE";
   break;
  case RGBTYPE:
   result = "RGB";
   break;
  case EIGENTYPE:
   result = "EIGEN";
  case EMPTYTYPE:
   result = "EMPTY";
  default:
   result = "Unknown Datatype";
   break;
 }

#if ERRORCHECK
 if(result.empty())
 {
  std::cout<<"ERROR in std::string convertDataTypeToString(const DataType &dt)"<<std::endl;
  std::cout<<"Datatype, dt = "<<dt<<" is not recognized.  Exiting..."<<std::endl;
  exit(1);
 }
#endif

 return result;

}





//GET FUNCTIONS
std::string getFileExtensionWithoutDot(std::string fname) 
//returns the filename extension without a period.  without ERRORCHECK, if the function cannot return an extension, it returns an empty string
{
 std::string extension;

 if(fname.rfind(".") != std::string::npos)
 {
  extension = fname.substr(fname.rfind(".")+1);
 }
#if ERRORCHECK
 else
 {
  std::cout<<"std::string getFileExtensionWithoutDot(std::string fname)"<<std::endl; 
  std::cout<<"Cannot get filename extensions from "<<fname<<std::endl;
  exit(1);
 }
#endif

 return extension;



}



template<>
template<>
void ReadFromFileV1N1<std::string>::readFromFileConvertIntoVector(std::vector<double> &cvec)
//this is a special form of the general function above for converting T=std::string into S = float using atod.  It reads the entire file into a vector 
//of type double and returns it.  
{
 //assumes the stream has already been opened
 std::string cline;

 while(!(this->reachedEOF()))  //reads until EOF
 {
  cline = this->readProcessedCurrentLineFromStream();
  if(!cline.empty())  //does not try to convert empty lines
   cvec.push_back(static_cast<double>(atof(cline.c_str())));
 }


}


template<>
template<>
void ReadFromFileV1N1<std::string>::readFromFileConvertIntoVector(std::vector<float> &cvec)
//this is a special form of the general function above for converting T=std::string into S = float using atof.  It reads the entire file into a vector 
//of type float and returns it.  
{
 std::string cline;

 while(!(this->reachedEOF()))  //reads until EOF
 {
  cline = this->readProcessedCurrentLineFromStream();
  if(!cline.empty())  //does not try to convert empty lines
   cvec.push_back(atof(cline.c_str()));
 }

 
}


template<>
template<>
void ReadFromFileV1N1<std::string>::readFromFileConvertIntoVector(std::vector<int> &cvec)
//this is a special form of the general function above for converting T=std::string into S = float using atof.  It reads the entire file into a vector 
//of type float and returns it.  
{
 std::string cline;

 while(!(this->reachedEOF()))  //reads until EOF
 {
  cline = this->readProcessedCurrentLineFromStream();
  if(!cline.empty())  //does not try to convert empty lines
   cvec.push_back(atoi(cline.c_str()));
 }

 

}



//CONSTRUCTORS

CLArgParserV1N3::CLArgParserV1N3(int argc, char* argv[], QueryState shouldprocess, std::string htxt)
//takes the arguments to main and parses them into multimap args.
{
 //assigns the helptext to htxt or a default value if it is empty
 if(htxt.empty())
 {
  helptext = "Sorry, no help available!";
 }
 else
 {
  helptext = htxt;
 }

 bool shouldstripquotes = true;
 
 //if the enum type QueryState = QUERY, then the parser will ask the user questions about how to process the arguments; otherwise, the defaults will be used
 if(shouldprocess == QUERY)
 {
  char ans = 'j';
  std::cout<<"Do you Want to Strip off All Double Quotes (y = yes, n = no)?: "<<std::endl;
  while((ans != 'n') && (ans != 'y'))
   std::cin >> ans;

  if(ans == 'y')
   shouldstripquotes = true;

  
 }

 
 if(argc >= 2)  //the CL needs to have at least 1 flag
 {
  
  std::string flag("-empty");
  int idx = 1;
  std::string value;

  while(idx < argc)  //remember that argv[0] is the name of the program
  {
   value.clear();
   if(doesStringBeginWith(std::string(argv[idx]),'-'))  //if argv[idx] is a flag (checks for a '-' at the beginning)
   {
    flag = std::string(argv[idx]);  //reads in the flag.  any further values (if a list) will be given the same flag
    ++idx;
    
    if(idx >= argc)  //checks to makes sure that the last argument on the CL is a flag.  if so, then there is no value following
    {
     value.clear();
    }
    else
    {
     value = std::string(argv[idx]);
     
     if(hageman::doesStringBeginWith(value,'-'))  //checks whether the value is a flag, if so, then it checks whether it is a special case and, if so, accepts it as a value.  
     //if it is a true flag, then it clears it and decrements the index so the flag is fed into the loop again
     {
      if(isdigit(value.at(1)) || ((value.at(1) == '.') && isdigit(value.at(2))))  //checks whether the flag is actually a negative number -5 or a negative float -.7
      {
      }
      else
      {
       value.clear();
       --idx;  //decrements the index so the flag is fed into the loop again
      }
     }
    } 

    

   }
   else  //argv[idx] is a value
   {
    value = std::string(argv[idx]);  //value in the list is given the last flag read in
   }

   //each argument has quotes stripped by default
   if(shouldstripquotes)
    hageman::stripQuotes(value);
   
   args.insert(std::make_pair<std::string, std::string>(flag, value));  //inserts the (flag,value) pair into the multimap
   ++idx;
  }
 }

 //checks to see if the -help flag is specified.  If so, then prints out the help text and exits the program
 if(this->doesFlagExist("-help"))
 {
  std::cout<<"HELP: "<<std::endl;
  std::cout<<helptext<<std::endl;
  exit(1);
 }

  

}

CLArgParserV1N3::CLArgParserV1N3(const CLArgParserV1N3 &paradigm)
//copy constructor
{

 this->args = paradigm.getArgs();  //uses the STL multimap overloaded = operator
 helptext = paradigm.getHelpText();  //copies the separate helptext

}

//PRINT FUNCTIONS
void CLArgParserV1N3::printCLArgs() const
//prints out the (flag,value) pairs on the CL
{
 printOutSTLMap<std::multimap<std::string, std::string> >(args);
 
}

void CLArgParserV1N3::incorrectUsage() const 
//prints out the help text when the program is executed incorrectly and exits the program
{
 std::cout<<"Incorrect Usage.  Exiting..."<<std::endl;
 std::cout<<this->helptext<<std::endl;
 exit(1);

}


//GET FUNCTIONS
std::vector<std::string> CLArgParserV1N3::getParameter(std::string flag) const 
//returns all the value(s) assigned to flag; flag must contain the preceding -
{
 return (hageman::getMultipleParametersFromMultimap(flag,args));  //returns all the values that are paired to a particular flag 

}

void CLArgParserV1N3::getCLFileNamePtrList(std::string flag, std::vector<FileNameV1N1<> *> &ptrlist) const  
//returns a list of value(s) assigned to flag and converts into a vector of FileNameV1N1 ptrs
{
 std::vector<std::string> temp;
 temp = this->getParameter(flag);  //gets a vector of strings that represent filenames
 convertStringVectorToFileNamePtrList<std::string>(temp, ptrlist);  //converts all the strings into FileNameV1N1 ptrs

}
 

std::string CLArgParserV1N3::getSingleParameter(std::string flag) const
//returns the value of a flag known to have a single value
{
 std::multimap<std::string, std::string>::const_iterator pos;
 pos = args.find(flag);
 std::string result;

 if(pos != args.end())  //flag is found
  result = pos->second;
 else  //flag was not found; returns empty string
 {
#if ERRORCHECK
  std::cout<<"ERROR in std::string CLArgParserV1N3::getSingleParameter(std::string flag)"<<std::endl;
  std::cout<<"Cannot return a value.  Flag not found.  Exiting..."<<std::endl;
  exit(1);
#endif

#if VERBOSE
  std::cout<<"WARNING in std::string CLArgParserV1N3::getSingleParameter(std::string flag)"<<std::endl;
  std::cout<<"Cannot return a value.  Flag not found."<<std::endl;
#endif


 }
 

 return (result);

}


FMArgParserV1N4::FMArgParserV1N4()
//empty default constructor
:CLArgParserV1N3()
{

}

FMArgParserV1N4::FMArgParserV1N4(int argc, char *argv[], QueryState shouldprocess, std::string htxt)
//constructor which initializes the class using arguments from the command line
:CLArgParserV1N3(argc,argv,shouldprocess,htxt)
{
 



}


//GET FUNCTIONS
double FMArgParserV1N4::getMINFATHRESHOLD() const
//returns the minimum FA threshold as a double; if no flag, then return 0.0
{
 double result = 0.0f;

 if(this->doesFlagExist(DSL_MINFATHRESHOLD_FLAG))
 {
  result = atof((this->getSingleParameter(DSL_MINFATHRESHOLD_FLAG)).c_str());
 }

 return result;
 
}



double FMArgParserV1N4::getMINTRACTLENGTH() const
//returns the minimum tract length as a double; if no flag, then returns 0.0
{
 double result = 0.0f;

 if(this->doesFlagExist(DSL_MINTRACTLENGTH_FLAG))
 {
  result = atof((this->getSingleParameter(DSL_MINTRACTLENGTH_FLAG)).c_str());
 }

 return result;
 
}

double FMArgParserV1N4::getMAXTRACTLENGTH() const
//returns the max tract length as a double; if no flag, then returns 0.0
{
 double result = 0.0f;

 if(this->doesFlagExist(DSL_MAXTRACTLENGTH_FLAG))
 {
  result = atof((this->getSingleParameter(DSL_MAXTRACTLENGTH_FLAG)).c_str());
 }

 return result;
 
}


double FMArgParserV1N4::getSTEPSIZE() const
//returns the stepsize interpolating eigenvolume as a double; if no flag, then return 0.0
{

 double result = 0.0f;

 if(this->doesFlagExist(DSL_STEPSIZE_FLAG))
 {
  result = atof((this->getSingleParameter(DSL_STEPSIZE_FLAG)).c_str());
 }

 return result;
 
}

double FMArgParserV1N4::getMAXTURNANGLE() const
//returns the max turn angle in degrees (as a double); if no flag, then return 0.0
{

 double result = 0.0f;

 if(this->doesFlagExist(DSL_MAXTURNANGLE_FLAG))
 {
  result = atof((this->getSingleParameter(DSL_MAXTURNANGLE_FLAG)).c_str());
 }

 return result;
 
}


std::vector<std::string> FMArgParserV1N4::getSeedMaskVolFNameVec() const
//returns the vector of filenames of seed ROI masks; if no flag, then returns an empty vector 
{

 std::vector<std::string> result;
 if(this->isThereSeedMaskVolFName())
 {
  result = (this->getParameter(DSL_SEEDMASKVOL_FLAG));
 }

 return result;
 
}


std::vector<std::string> FMArgParserV1N4::getStopMaskVolFNameVec() const
//returns the vector of filenames of stop ROI masks; if no flag, then returns an empty vector 
{
 std::vector<std::string> result;
 if(this->isThereStopMaskVolFName())
 {
  result = (this->getParameter(DSL_STOPMASKVOL_FLAG));
 }
 return result;
}


int FMArgParserV1N4::getTotalTrys() const
//returns the total number of trys as an integer; if no flag, then returns the default of 1 
{
 int result = 1;

 if(this->isThereTotalTrys())
  result = atoi((this->getSingleParameter(DSL_TOTALTRYS_FLAG)).c_str());

 return result;

}

int FMArgParserV1N4::getMaxTractNumber() const
//returns the max tract number as an integer; if no flag, then return 0
{
 int result = 0;

 if(this->isThereMaxTractNumber())
 {
  std::string numstr(this->getSingleParameter(DSL_MAXTRACTNUMBER_FLAG));
  result = atoi(numstr.c_str());
 }

 return result;

}



}



//#ifdef _DEBUG
//#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
//#define new DEBUG_NEW
//#endif


int main(int argc, char *argv[])
{
 //_CrtSetBreakAlloc(269);

 PARSE_ARGS;

//#ifdef _DEBUG
// CMemoryState oldMemState, newMemState, diffMemState;
//  oldMemState.Checkpoint();
//#endif

 //_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );

 //typedef itk::Image<itk::DiffusionTensor3D<double>,3> DiffImageType;
 //typedef itk::Image<unsigned short,3> MaskImageType;


 //itk::ImageFileReader<DiffImageType>::Pointer diffreader = itk::ImageFileReader<DiffImageType>::New();
 //std::string difffname("DiffusionEditor_1._TensorNode.nrrd");
 //diffreader->SetFileName(difffname.c_str());
 //diffreader->Update();
 //DiffImageType::Pointer diffimage = diffreader->GetOutput();

 //hageman::printDIMSITK<itk::DiffusionTensor3D<double> >(diffimage);
 //hageman::printVoxelLengthsITK<itk::DiffusionTensor3D<double> >(diffimage);

 //hageman::printTensorElementITK<double>(diffimage,128,154,26);
 //hageman::printEigenSystemITK<double>(diffimage,128,154,26);

 //itk::ImageFileReader<MaskImageType>::Pointer maskreader = itk::ImageFileReader<MaskImageType>::New();
 //std::string maskfname("DiffusionEditor_1._ThresholdMask.img");
 
 
 //hageman::ImageVolumeV2N4<UINT16> maskvol;
 //maskvol.readInAnalyzeVolumeFromFile( 
 
 //maskreader->SetFileName(maskfname.c_str());
 //maskreader->Update();
 //MaskImageType::Pointer maskimage = maskreader->GetOutput();

 //hageman::EigenVolume3DV1N4<double> evol(256,256,53);
 //hageman::constructEigenVolumeITK<double>(diffimage,evol);

 //evol.printElementCL(128,154,26);
 //ImageType::Pointer image = ImageType::New();

 //std::string tline("ITKHelloWorld!");
 //std::cout<<tline<<std::endl;
 //tline = hageman::addSpaceBetweenBeforeCapitals(tline);
 //std::cout<<tline<<std::endl;

 std::string htxt = "USAGE: FMTractography -ieigenvolfname <fname> -idtype <DataType> (of seed ROI) -seedroi <fname1> <fname2> ... \
        -MINFATHRESHOLD <double> -STEPSIZE <double> -MINTRACTLENGTH <double> -MAXTRACTLENGTH <double> \
        -MAXTURNANGLE <double> -totaltrys <int> -ofprefix <string> -ofpath <string> -maxtractnumber <int>";
        
 hageman::FMArgParserV1N4 *dtiargs = new hageman::FMArgParserV1N4(argc,argv,hageman::NOQUERY, htxt);
 
 hageman::DataType imgdtype = hageman::EMPTYTYPE;

 if(dtiargs->doesFlagExist(DSL_IMGDATATYPE_FLAG))
  imgdtype = hageman::convertStringToDataType(dtiargs->getSingleParameter(DSL_IMGDATATYPE_FLAG));
 //else
 //{
 // std::vector<std::string> seedfnames(dtiargs->getSeedMaskVolFNameVec());
 // imgdtype = hageman::determineDataType(seedfnames);
 //}

 if(imgdtype == hageman::SINT16TYPE)
 {
  signed short dumval = 0;
  hageman::runITK<signed short>(*dtiargs, dumval);
 }
 else if(imgdtype == hageman::UINT16TYPE)
 {
  unsigned short dumval = 0;
  hageman::runITK<unsigned short>(*dtiargs, dumval);
 }
 else if(imgdtype == hageman::UINT8TYPE)
 {
  unsigned char dumval;
  hageman::runITK<unsigned char>(*dtiargs, dumval);
 }
 else if(imgdtype == hageman::SINT8TYPE)
 {
  signed char dumval;
  hageman::runITK<signed char>(*dtiargs, dumval);
 }
 else if(imgdtype == hageman::FLOATTYPE)
 {
  float dumval = 0.0;
  hageman::runITK<float>(*dtiargs, dumval);
 }
 else if(imgdtype == hageman::DOUBLETYPE)
 {
  double dumval = 0.0;
  hageman::runITK<double>(*dtiargs, dumval);
 }
 else
 {
  std::cout<<"ERROR in main.cpp."<<std::endl;
  std::cout<<"No Valid Datatype.  Exiting..."<<std::endl;
  exit(1);
 
 }

  

 delete dtiargs;
 dtiargs = NULL;

//#ifdef _DEBUG
  //  newMemState.Checkpoint();
   // if( diffMemState.Difference( oldMemState, newMemState ) )
    //{
      //  TRACE( "Memory leaked!\n" );
 // diffMemState.DumpStatistics();
 // diffMemState.DumpAllObjectsSince();
    //}
//#endif


 //CMemoryState::DumpAllObjectsSince();

 //int *ptr = (int*)(malloc(10));

 //_CrtDumpMemoryLeaks();
 

 return EXIT_SUCCESS;
 //return 0;

}




