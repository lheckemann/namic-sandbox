%
% Complete documentation on the extended LaTeX markup used for Insight
% documentation is available in ``Documenting Insight'', which is part
% of the standard documentation for Insight.  It may be found online
% at:
%
%     http://www.itk.org/

\documentclass{InsightArticle}

\usepackage[dvips]{graphicx}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  hyperref should be the last package to be loaded.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[dvips,
bookmarks,
bookmarksopen,
backref,
colorlinks,linkcolor={blue},citecolor={blue},urlcolor={blue},
]{hyperref}


%  This is a template for Papers to the Insight Journal. 
%  It is comparable to a technical report format.
\title{Reader/Writer for Analyze Object Maps for ITK}

% Increment the release number whenever significant changes are made.
% The author and/or editor can define 'significant' however they like.
\release{1.00}

% At minimum, give your name and an email address.  You can include a
% snail-mail address if you like.
\author{Jeffrey Hawley, Hans Johnson }
\authoraddress{University of Iowa}

\begin{document}


\ifpdf
\else
   %
   % Commands for including Graphics when using latex
   % 
   \DeclareGraphicsExtensions{.eps,.jpg,.gif,.tiff,.bmp,.png}
   \DeclareGraphicsRule{.jpg}{eps}{.jpg.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.gif}{eps}{.gif.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.tiff}{eps}{.tiff.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.bmp}{eps}{.bmp.bb}{`convert #1 eps:-}
   \DeclareGraphicsRule{.png}{eps}{.png.bb}{`convert #1 eps:-}
\fi


\maketitle


\ifhtml
\chapter*{Front Matter\label{front}}
\fi


% The abstract should be a paragraph or two long, and describe the
% scope of the document.
\begin{abstract}
\noindent
This document describes an addition to the Image IO Library of the Insight Toolkit (ITK).
ITK has been able to read in Analyze image files but not the object maps that correspond
to the images.  Without the object maps, regions of interest were not being shown.
These regions of interest are helpful in designating locations, giving a name to those
locations, as well as colors and other information, which is useful if you are trying to tell
someone where to look in an image.  This report describes the reason why this code should be
added into ITK and how to use the code.
\end{abstract}

\tableofcontents

\section{Anaylze Object Maps}
An Analyze Object Map is an image that is plotted with numbers from 0-255 that correspond to an Analyze Object(or, as will be referred to in this paper as, Analyze Object Entry).  Each Analyze Object Entry
is a specific Region of Interest that a user has specified. With these Regions of Interest the user can put a name to the Region, a specific color and be able to communicate to other people what areas to look at or know which Regions they are talking about.  Regions of Interest could be differentiating a part of the brain, marking a location where someone thinks a tumor is or many other ways to group a specific area to a name and color.  The Analyze Object Maps can be shown by themselves or overlaid of another image, such as the original image that was the basis of the Analyze Object Map, to show which areas were highlighted.
  
\section{Description}
There are two utility files (objectmap and objectentry) and the main IO file (itkAnalyzeObjectLabelMapImageIO) and the corresponding
IO factory file (itkAnalyzeObjectLabelMapImageIOFactory).  

The IO file takes care of reading and writing out an object file.  Whenever
you read or write an object file you have at the very beginning information about the object map.  The very first data is the version
of the object map, next you have the x,y,z size of the object map, the number of object entries and finally for version 7 (the newest
version) number of volumes.  After you have the beginning information there is the information about each object file, that means that
there is going to have to be a vector of all of the entries.  

That is why there is a utility file called objectentry that stores the
information for one specific entry, if you make a vector of the file then you have all of the object entries for an object map.  There
are also some other functions in the objectentry that will read or write the information for the object entry.  

Finally, after you have all of the entries you have a run length encoding.  The run length encoding corresponds to an image of the numbers of the entries starting from 0 and going all the way up to the number of object entries.  

The objectmap file has functions that take care of doing things to an object map once it is created - such as converting the objectmap to an RGB Image. 

The one other file that is included is ImageToAnalyzeObjectMap, this file takes care of converting an image with the meta data information for object entries into an object map.

\section{Examples}

This section provides some examples on how to use the programs.
\begin{itemize}
\item Example 1 

This example is for reading in any file, then creating a new object map, then add entries to the object map, pick one entry and then write out the new object map with the one entry only.


Command:

\textbf{CreatingObjects.exe 2dtest.nii creatingObjects.obj}\\


\small \begin{verbatim}
int main( int argc, char ** argv )
{
  typedef unsigned char       InputPixelType;
  
  typedef unsigned char       OutputPixelType;
  
  const   unsigned int        Dimension = 3;
  
  typedef itk::Image< InputPixelType,  Dimension >    InputImageType;
  
  typedef itk::Image< OutputPixelType, Dimension >    OutputImageType;
  
  typedef itk::ImageFileReader< InputImageType  >  ReaderType;
  
  typedef itk::ImageFileWriter< OutputImageType >  WriterType;
  ReaderType::Pointer reader = ReaderType::New();
  WriterType::Pointer writer = WriterType::New();
  ...
  reader->SetFileName(NiftiFile);
  ...
  reader->Update();
  ...
  itk::AnalyzeObjectMap<InputImageType>::Pointer CreateObjectMap = itk::AnalyzeObjectMap<InputImageType>::New();
  
  ...
  
  //Add one entry to the object map named "You Can Delete Me", this entry corresponds to 1 if you do a pickOneEntry
  CreateObjectMap->AddAnalyzeObject("You Can Delete Me");

  //Add another two entries that will be based on the image that is passed into 
  //the function, also, the intensity that you would like searched for, the name of the entry and then finally the RGB values
  //you would like the entry to have for the regions that are found.

  //This entry corrsponds to 2 if you do a pickOneEntry
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 200, "Square", 250, 0, 0);

  //This entry corrsponds to 3 if you do a pickOneEntry
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 128, "Circle", 0, 250,0);

  //This entry corrsponds to 4 if you do a pickOneEntry
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 45,  "SquareTwo", 0, 0, 250);

  //Then anoter entry is added, this entry corrsponds to 5 if you do a pickOneEntry
  CreateObjectMap->AddAnalyzeObject("Nothing In Here");

  //The entry that was just added is deleted
  CreateObjectMap->DeleteAnalyzeObject("Nothing In Here");
  
  ...
  writer->SetInput(CreateObjectMapTwo);
  ...
  
  writer->Update();
  ...
}
\end{verbatim} \normalsize
  

\begin{figure}[h]
  \hfill
  \begin{minipage}[t]{.45\textwidth}
    \begin{center}  
      \includegraphics[width=.28\textwidth]{2dtest.eps}
      \caption{2dtest.nii}
      \label{fig-tc}
    \end{center}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{.45\textwidth}
    \begin{center}  
      \includegraphics[width=.28\textwidth]{creatingObject.eps}
      \caption{creatingObjects.obj, this is what it should look like when you convert it to an RGB image.  See next example on how to display 
    object maps.}
      \label{fig-tc}
    \end{center}
  \end{minipage}
  \hfill
\end{figure}  

\item Example 2

This is a simple example for reading in an Analyze object map and
then showing how to use vtk to display the object map. 


Command:

\textbf{DisplayingObjectMaps.exe creatingObjects.obj 0}

\small \begin{verbatim}
typedef unsigned char PixelType;
const unsigned int Dimension = 3;
typedef itk::Image< PixelType, Dimension > ImageType;
typedef itk::RGBPixel<PixelType> RGBPixelType;
typedef itk::Image< RGBPixelType, Dimension > RGBImageType;

typedef itk::ImageFileReader< ImageType > ReaderType;

//typedef itk::ImageToVTKImageFilter<RGBImageType> ConnectorType;

int main(int argc, char * argv [] )
{
  ReaderType::Pointer reader  = ReaderType::New();
  
  //The input should be an Anaylze Object Map file
  reader->SetFileName( DisplayImage );
  ...
  
  reader->Update();
  
  //This will convert the output of the reader into an object map
  itk::AnalyzeObjectMap<ImageType, RGBImageType>::Pointer Objectmap = itk::AnalyzeObjectMap<ImageType, RGBImageType>::New();
  Objectmap->TransformImage(reader->GetOutput());
  
  //If you have vtk and itkApplications installed then you can uncomment this out to display
  //an object map to the screen.  Otherwise you can see how to display an object map using vtk.
  
  //Set the input, to the connector connecting itk with vtk, with an RGB image of the specific
  //colors that corresponds to each entry in the object map.
  
  //vtkRenderWindowInteractor *windowInteractor = vtkRenderWindowInteractor::New();
  //ConnectorType::Pointer connector= ConnectorType::New();
  //connector->SetInput( Objectmap->ObjectMapToRGBImage() );
  
  //connector->Update();
  
  //Display a two dimensional view of the object map that was read in
  //vtkImageViewer2 * twodimage = vtkImageViewer2::New();
  
  //const int SliceNumber = 0;
  //twodimage->SetInput(connector->GetOutput());
  //twodimage->SetSlice(SliceNumber);
  //twodimage->SetSliceOrientationToXY();
  
  //Set the background of the renderer to a grayish color so that it is easier to see
  //the outline of the object map since it is usually black
  // twodimage->GetRenderer()->SetBackground(0.4392, 0.5020, 0.5647);
  // twodimage->SetupInteractor(windowInteractor);
   
  // twodimage->Render();
  // windowInteractor->Start();
	...
}
\end{verbatim} \normalsize
                                                                               
\item Example 3

This example is for reading in any file, then creating a new object map, then add entries to the object map, pick one entry and then write out the new object map with the one entry only.

Command:

\textbf{PickOneObjectEntry.exe 2dtest.nii circle.obj}

\small \begin{verbatim}
int main( int argc, char ** argv )
{
  ...
  //Now we bring in a nifti file that Hans and Jeffrey created, 
  //the image as two squares and a circle in it of different intensity values.
  reader->SetFileName(NiftiFile);
  ...
  reader->Update();
  ...
  
  itk::AnalyzeObjectMap<InputImageType>::Pointer CreateObjectMap = itk::AnalyzeObjectMap<InputImageType>::New();
  
  //Add another two entries that will be based on the image that is passed into 
  //the function, also, the intensity that you would like searched for, 
  //the name of the entry and then finally the RGB values
  //you would like the entry to have for the regions that are found.
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 200, "Square", 250, 0, 0);
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 128, "Circle", 0, 250,0);
  CreateObjectMap->AddObjectEntryBasedOnImagePixel(reader->GetOutput(), 45,  "SquareTwo", 0, 0, 250);
  
  //Pick the circle entry and have it put into CreateObjectMap two.  These means
  //that there is only one entry in CreateObjectMapTwo and the image has also
  //been taken care of.
  itk::AnalyzeObjectMap<InputImageType>::Pointer CreateObjectMapTwo = CreateObjectMap->PickOneEntry(2);
  
  //Place all of the entries into the meta data so that the entries can be written
  //out to an object file.
  CreateObjectMapTwo->PlaceObjectMapEntriesIntoMetaData();
  
  //Now write out an object file
  writer->SetInput(CreateObjectMapTwo);
  writer->SetFileName(CreatingObject);
  ...
  writer->Update();
  ...
}
\end{verbatim} \normalsize

\begin{figure}[h]
\center
\includegraphics[width=.14\textwidth]{circle.eps}
\itkcaption[Streaming Concept Diagram]{circle.obj, this is what it should look like when it is converted to an RGB image.  Also, see the first example to see what 2dtest.nii should look like.}
\label{fig:StreamingConceptDiagram}
\end{figure}


\end{itemize}

\section{Testing}

Right now we have one test that does all of the testing.  The filename for the test is AnalyzeObjectMapTest.cxx.  The file takes in five arguments.
Each argument corresponds to a certain name of another file.  

For the first argument it should be the name of test.obj and that file is a 3-Dimensional object file that Hans created.  The file is read in, then converted into an object map and finally an RGB image is created from the object map.  This was just to make sure that everything worked without any errors.  

After that the output of the reader is sent to a writer to write out the exact copy of the argument but with a different file name.  That is where the second argument comes in.  Once the file is written out then both files are opened up and compared to make sure they have the exact same bit by bit data.  

After that the third argument that corresponds to the name of a nifti file that Hans and I created which is the same image seen in example 1 is read in.  With that nifti file read in we create a new object map with some extra entries and other entries based on the nifti file that was read in.  That new object map is written out a file as an object file that corresponds to the fourth argument read in.  That file that was just written out is then read back in where the reader output is then converted into an object map and finally an RGB image is created from the object map.  

Then from that object map one entry is picked and new object map is created with just the one entry in it.  This object map with the one entry is written to file that corresponds with the fifth argument.  The file that was just written out is read back in and then converted into an object map and finally an RGB image is created from the object map.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%  Insert the bibliography using BibTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{plain}
\bibliography{InsightJournal}


\end{document}

