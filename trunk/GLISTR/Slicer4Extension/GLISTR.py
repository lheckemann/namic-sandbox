##############################################################################
# \file  GLISTR.py
# \brief GLISTR slicer extension implemented as scripted Python module.
#
# Visit https://www.rad.upenn.edu/sbia/software/index.html#glistr for
# information on how to obtain a copy of the GLISTR sources.
#
# Copyright (c) 2011 University of Pennsylvania. All rights reserved.
# See COPYING file or https://www.rad.upenn.edu/sbia/software/license.html.
#
# Contact: sbia-software at uphs.upenn.edu
##############################################################################

# ============================================================================
# imports
# ============================================================================

from __main__ import slicer, qt
import os, sys, subprocess

# ============================================================================
# helpers
# ============================================================================

# ****************************************************************************
## Execute command.
#
# \todo
def execCmd(cmdArray):
    cmd = [str (i) for i in cmdArray]
    print cmd
    p = subprocess.Popen (cmd, stdout = subprocess.PIPE, stderr = subprocess.PIPE)
    print p.stdout.read ()
    if p.returncode != 0:
        print p.stderr.read ()
    return p.returncode

# ============================================================================
# class: GLISTR - the module description
# ============================================================================

## Provides the module description for Slicer
#
class GLISTR:
    
    # ************************************************************************
    ## Constructor.
    def __init__ (self, parent):
        parent.title               = "GLISTR"
        parent.category            = "Segmentation"
        parent.contributor         = "Ali Gooya, Andreas Schuh, Christos Davatzikos, Kilian Pohl"
        parent.helpText            = """This is a help text"""
        parent.acknowledgementText = """The acknowledgements"""
        self.parent = parent

# ============================================================================
# class: GLISTRLogic - the logic
# ============================================================================

## Implements the module's logic, i.e., wraps the calls to GLISTR.
#
class GLISTRLogic:
    
    # ************************************************************************
    ## Constructor.
    #
    def __init__ (self):
        self.__mrmlScene = None
        
        # \todo There should be a better way to connect to the GLISTR software
        #       itself. All three main executables which are required by this
        #       module are implemented in Python. Adjustments of these script
        #       should enable the direct import of these.
        self.__glistrPrefix = os.environ.get ('GLISTR_PREFIX')
        if self.__glistrPrefix:
            self.__glistrBin    = os.path.join (self.__glistrPrefix, 'bin')
            # \todo The atlas directory should be selectable by the user with a
            #       preset as given here. The reference T1 scan of the atlas must
            #       then be identified as well as the list of moving images.
            #       This could be easily achieved by introducing simple naming
            #       conventions for the files making up the atlas. The moving
            #       image list could in fact be generated by this module.
            #       Alternatively, have the user select all the different atlas
            #       volumes. These could be default set to the default atlas
            #       volumes which are packaged with GLISTR.
            self.__glistrAtlas   = os.path.join (self.__glistrPrefix, 'data/Atlas')
            self.__refAtlasFile  = os.path.join (self.__glistrAtlas,  'jakob_stripped_with_cere_lps_256256128.hdr')
            self.__brainMaskFile = os.path.join (self.__glistrAtlas,  'brain_mask.hdr')
        else:
            print "GLISTR_PREFIX environment variable not set!\n"
    
    # ************************************************************************
    ## Set MRML scene.
    #
    def setMRMLScene (self, mrmlScene):
        self.__mrmlScene = mrmlScene
       
    # ************************************************************************
    ## Pre-process features, i.e., transform volumes into atlas space.
    #
    def preProcessFeatures (self, refVolumeNode, volumeNodes, outputDirectory):
        fixedImagesListFile = outputDirectory + "/glistr_fixed_images.lst"
        # save features and create features list file
        featuresListFile = self.writeFeatures (volumeNodes, outputDirectory)
        if featuresListFile == "":
            return False
        # save reference volume and append to features list
        refVolumeFile = self.writeVolume (refVolumeNode, outputDirectory)
        if refVolumeFile == "":
            return False
        fp = open (featuresListFile, 'a')
        fp.write (refVolumeFile + '\n')
        fp.close ()
        
        # perform pre-processing
        cmd = [os.path.join (self.__glistrBin, "PreProcessFeatures"),
               "-i", featuresListFile,
               "-o", outputDirectory,
               "-T", refVolumeFile,
               "-A", self.__refAtlasFile,
               "-p", fixedImagesListFile,
               "-m", self.__brainMaskFile]
        
        execCmd (cmd)
        
        # load pre-processed volumes
        volumeNodes = self.loadVolumes (fixedImagesListFile)
        if len (volumeNodes) > 0:
            self.selectVolume (volumeNodes [0].GetID ())
        
        return True
    
    # ************************************************************************
    ## Write volume to disk.
    #
    def writeVolume (self, volumeNode, outputDirectory):
        storageNode = volumeNode.GetStorageNode ()
        name = volumeNode.GetName ()
        name.replace (".", "_")
        storageNode.SetFileName (outputDirectory + "/glistr_" + name + ".nii")
        if not storageNode.WriteData (volumeNode):
            print "Failed to write volume '" \
                  + volumeNode.GetName () + "' to file '" \
                  + storageNode.GetFileName () + "'\n"
            return ""
        return storageNode.GetFileName ()
    
    # ************************************************************************
    ## Write feature volumes to disk and create input features list file.
    #
    def writeFeatures (self, volumeNodes, outputDirectory):
        featuresList = "" # content of features list file
        
        # iterate over volumes, write them to disk and add entry to features list
        for i in range (len (volumeNodes)):
            storageNode = volumeNodes [i].GetStorageNode ()
            name = volumeNodes [i].GetName ()
            name.replace (".", "_")
            storageNode.SetFileName (outputDirectory + "/glistr_" + name + ".nii")
            if not storageNode.WriteData (volumeNodes [i]):
                print "Failed to write volume '" \
                      + volumeNodes [i].GetName () + "' to file '" \
                      + storageNode.GetFileName () + "'\n"
                return ""
            featuresList = featuresList + storageNode.GetFileName () + '\n'
        
        # write features list file
        featuresListFile = outputDirectory + "/glistr_features.lst"
        fp = open (featuresListFile, 'w')
        if not fp:
            print "Failed to open file '" + featuresListFile + "' for writing\n"
            return ""
        fp.write (featuresList)
        
        return featuresListFile
    
    # ************************************************************************
    ## Removes all loaded scalar volumes from the Slicer MRML scene.
    #
    # This method removes all nodes of type vtkMRMLScalarVolumeNode from the
    # MRML scene of Slicer. Generally this is not quite nice, but the current
    # workflow of the GLISTR module is implemented to process all loaded
    # scalar volumes. When the user chose to pre-process these, they should
    # live with these volumes being replaced by the pre-processed volumes.
    #
    # \noate THIS METHOD IS CURRENTLY NOT USED
    #
    # \note The only reason for doing so is that Slicer does not well
    #       support the selection of multiple MRML nodes.
    #       The qMRMLCheckableNodeComboBox did not seem to provide a working
    #       method in Python to retrieve all checked nodes.
    def unloadAllVolumes (self):
        mrmlScene = self.__mrmlScene
        nodes = mrmlScene.GetNodesByClass ("vtkMRMLScalarVolumeNode")
        nodes.InitTraversal ()
        node = nodes.GetNextItemAsObject ()
        while node:
            mrmlScene.RemoveNode (node)
            node = nodes.GetNextItemAsObject ()
    
    # ************************************************************************
    ## Load volume into Slicer.
    #
    def loadVolume (self, fileName):
        # add scalar volume to MRML scene
        volumesLogic = slicer.modules.volumes.logic ()
        volumeName   = os.path.basename (fileName).split ('.',1) [0]
        return volumesLogic.AddArchetypeScalarVolume (fileName, volumeName, 0)
    
    # ************************************************************************
    ## Select a given volume and make it visible in the viewers.
    #
    def selectVolume (self, nodeId):
        mrmlLogic = slicer.app.mrmlApplicationLogic ()
        selNode = mrmlLogic.GetSelectionNode ()
        selNode.SetReferenceActiveVolumeID (nodeId)
        mrmlLogic.PropagateVolumeSelection ()
    
    # ************************************************************************
    ## Load volumes specified by a list file into the Slicer MRML scene.
    def loadVolumes (self, listFile):
        mrmlScene   = self.__mrmlScene
        volumeNodes = []
        # read list file line-by-line
        fp = open (listFile, 'r')
        if not fp:
            print "Failed to open file '" + listFile + "' for reading\n"
            return False
        fileName = fp.readline ().strip ()
        while fileName != "":
            volumeNodes.append (self.loadVolume (fileName))
            fileName = fp.readline ().strip ()
        return volumeNodes

# ============================================================================
# class: GLISTRWidget - the widget
# ============================================================================

## This is the graphical user interface of the GLISTR Slicer module.
#
class GLISTRWidget:
    
    # ************************************************************************
    ## Constructor.
    #
    # If no parent is given, this widget connects itself with slicer, i.e.,
    # declares itself as being derived from the slicer.qMRMLWidget class.
    def __init__ (self, parent = None):
        
        # connect with Slicer
        if not parent:
            self.parent = slicer.qMRMLWidget ()
            self.parent.setLayout (qt.QVBoxLayout ())
            self.parent.setMRMLScene (slicer.mrmlScene)      
        else:
            self.parent = parent
        self.layout = self.parent.layout ()
        
        # instantiate widget logic
        self.__logic = GLISTRLogic ()
        self.__logic.setMRMLScene (slicer.mrmlScene)
        
        # create the widget and display it
        if not parent:
            self.setup ()
            self.parent.show()
        
        # initialize members
        self.__preOutputDirectoryDlg = None
        
        # register default slots
        #self.parent.connect ('mrmlSceneChanged(vtkMRMLScene*)', self.onMRMLSceneChanged)
    
    # ************************************************************************
    ## Create widget.
    #
    # The setup method creates the widget and registers the handlers for
    # the events triggered by the user interacting with Slicer or the widget.
    def setup (self):
        
        mrmlScene = slicer.mrmlScene
        
        # --------------------------------------------------------------------
        # Pre-processing tab
        preTab           = slicer.qMRMLCollapsibleButton ()
        preTab.text      = "Step 1: Affine Transformation of Patient Scans into Atlas Space"
        preTab.collapsed = False
        
        preTabLayout = qt.QGridLayout (preTab)
        
        row = 0 # row counter for grid layout
        
        # selection of T1 patient scan
        preRefVolumeSelector = slicer.qMRMLNodeComboBox ()
        preRefVolumeSelector.toolTip       = "Select the T1 patient scan " \
                                             "which is used to determine\nthe " \
                                             "affine transformation which maps " \
                                             "the (co-registered)\npatient scans " \
                                             "into the atlas space"
        preRefVolumeSelector.nodeTypes     = ['vtkMRMLScalarVolumeNode']
        preRefVolumeSelector.noneEnabled   = False
        preRefVolumeSelector.addEnabled    = False
        preRefVolumeSelector.removeEnabled = False
        
        preRefVolumeSelector.setMRMLScene (mrmlScene)
        
        preTabLayout.addWidget (qt.QLabel ("T1 Volume:"), row, 0, 1, 1)
        preTabLayout.addWidget (preRefVolumeSelector,     row, 1, 1, 2)
        row = row + 1
        
        # selection of other patient scans
        preVolumeSelector        = []
        preVolumeSelectorLabel   = []
        preVolumeSelectorToolTip = []
        
        preVolumeSelectorLabel  .append ("T1-CE Volume:")
        preVolumeSelectorToolTip.append ("Select T1-CE volume used as additional segmentation feature")
        preVolumeSelectorLabel  .append ("T2 Volume:")
        preVolumeSelectorToolTip.append ("Select T2 volume used as additional segmentation feature")
        preVolumeSelectorLabel  .append ("FLAIR Volume:")
        preVolumeSelectorToolTip.append ("Select FLAIR volume used as additional segmentation feature")
        
        for i in range (len (preVolumeSelectorLabel)):
            preVolumeSelector.append (slicer.qMRMLNodeComboBox ())
            preVolumeSelector [i].toolTip       = preVolumeSelectorToolTip [i]
            preVolumeSelector [i].nodeTypes     = ['vtkMRMLScalarVolumeNode']
            preVolumeSelector [i].noneEnabled   = True
            preVolumeSelector [i].addEnabled    = False
            preVolumeSelector [i].removeEnabled = False
            
            preVolumeSelector [i].setMRMLScene (mrmlScene)
            
            preTabLayout.addWidget (qt.QLabel (preVolumeSelectorLabel [i]), row, 0, 1, 1)
            preTabLayout.addWidget (preVolumeSelector [i],                  row, 1, 1, 2)
            row = row + 1
        
        # output directory of pre-processed volumes
        preOutputDirectoryBtn          = qt.QPushButton ()
        preOutputDirectoryBtn.text     = "..."
        preOutputDirectoryBtn.setMaximumWidth (20)
        
        preOutputDirectoryBtn.connect ('clicked ()', self.showPreOutputDirectoryDialog)
        
        preOutputDirectoryEdit         = qt.QLineEdit ()
        preOutputDirectoryEdit.toolTip = "Output directory for pre-processed " \
                                         "patient scans, i.e.,\nthe patient " \
                                         "scans affine transformed into the atlas space"
        preOutputDirectoryEdit.enabled = True
        preOutputDirectoryEdit.sizeHint.setHeight (preOutputDirectoryBtn.height)
        
        preTabLayout.addWidget (qt.QLabel ("Output Directory:"), row, 0, 1, 1)
        preTabLayout.addWidget (preOutputDirectoryEdit,          row, 1, 1, 1)
        preTabLayout.addWidget (preOutputDirectoryBtn,           row, 2, 1, 1)
        row = row + 1
        
        # run button
        preRunBtn = qt.QPushButton ()
        preRunBtn.text = "Pre-process Features"
        
        preRunBtn.connect ('clicked ()', self.onPreProcessFeatures)
        
        preTabLayout.addWidget (preRunBtn, row, 0, 1, 3)
        row = row + 1
        
        # finalize tab and keep required references to widgets
        self.__preRefVolumeSelector = preRefVolumeSelector
        self.__preVolumeSelector = []
        for i in range (len (preVolumeSelector)):
            self.__preVolumeSelector.append (preVolumeSelector [i])
        self.__preOutputDirectoryEdit = preOutputDirectoryEdit
        
        self.layout.addWidget (preTab)
        
        # --------------------------------------------------------------------
        # Annotation tab
        annoTab           = slicer.qMRMLCollapsibleButton ()
        annoTab.text      = "Step 2: Annotate Pre-processed Patient Scans"
        annoTab.collapsed = False
        
        annoTabLayout = qt.QGridLayout (annoTab)
        
        annoLabel1 = qt.QLabel ("Open the Annotation module and set fiducials "
                                "inside the following tissues: TUMOR, NCR, VEINS, "
                                "CSF, GM, WM, EDEMA, and BG.")
        annoLabel2 = qt.QLabel ("Note:")
        annoLabel3 = qt.QLabel ("Some patients do not have both types "
                               "of tumors. In those cases, annotate only "
                               "TUMOR and not NCR. Similarly, if no edema "
                               " is observed, it may not need to be annotated"
                               " either.")
        annoLabel1.wordWrap = True
        annoLabel2.wordWrap = True
        annoLabel3.wordWrap = True
        
        annoLabel2.sizeHint.setWidth (20)
        
        annoTabLayout.addWidget (annoLabel1, 0, 0, 1, 2)
        annoTabLayout.addWidget (annoLabel2, 1, 0, 1, 1)
        annoTabLayout.addWidget (annoLabel3, 1, 1, 1, 1)
        
        # finalize tab
        self.layout.addWidget (annoTab)
        
        # --------------------------------------------------------------------
        # Joint segmentation & registration tab
        mainTab           = slicer.qMRMLCollapsibleButton ()
        mainTab.text      = "Step 3: Joint Segmentation && Registration"
        mainTab.collapsed = False
        
        # finalize tab
        self.layout.addWidget (mainTab)
        
        # --------------------------------------------------------------------
        # Post-processing tab
        postTab           = slicer.qMRMLCollapsibleButton ()
        postTab.text      = "Step 4: Transform Results back into Patient Space"
        postTab.collapsed = False
        
        # finalize tab
        self.layout.addWidget (postTab)
        
        # --------------------------------------------------------------------
        # Make segmentation tab
        postTab           = slicer.qMRMLCollapsibleButton ()
        postTab.text      = "Step 5: Make Segmentation from Posteriors"
        postTab.collapsed = False
        
        # finalize tab
        self.layout.addWidget (postTab)
    
    # ************************************************************************
    ## Show output directory selection dialog for pre-processing.
    #
    def showPreOutputDirectoryDialog (self):
        dlg = self.__preOutputDirectoryDlg
        if not dlg:
            dlg          = qt.QFileDialog ()
            dlg.fileMode = dlg.DirectoryOnly
            dlg.connect ('fileSelected(QString)', self.onSelectedPreOutputDirectory)
            self.__preOutputDirectoryDlg = dlg
        directory = self.__preOutputDirectoryEdit.text
        if directory == '':
            directory = os.environ.get ('HOME')
        dlg.setDirectory (directory)
        dlg.show ()
    
    # ************************************************************************
    ## Set output directory for pre-processing results.
    #
    def onSelectedPreOutputDirectory (self, directory):
        self.__preOutputDirectoryEdit.text = directory
    
    # ************************************************************************
    ## Pre-process the features, i.e., affine transform patient scans.
    #
    def onPreProcessFeatures (self):
        
        logic = self.__logic
        
        # get arguments
        refVolumeNode = self.__preRefVolumeSelector.currentNode ()
        volumeNodes = []
        for i in range (len (self.__preVolumeSelector)):
            volumeNode = self.__preVolumeSelector [i].currentNode ()
            if volumeNode:
                volumeNodes.append (volumeNode)
        outputDirectory = self.__preOutputDirectoryEdit.text
        
        # pre-process features
        logic.preProcessFeatures (refVolumeNode, volumeNodes, outputDirectory)
        
        # switch to main tab

