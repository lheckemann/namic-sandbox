
typedef itk::MultiModal3DMutualRegistrationHelper
< TransformType, OptimizerType, fixedVolumeType, movingVolumeType > MultiModal3DMutualRegistrationHelperType;

MultiModal3DMutualRegistrationHelperType::Pointer
appMutualRegistration = MultiModal3DMutualRegistrationHelperType::New();

appMutualRegistration->SetFixedBinaryVolume(fixedMask);
appMutualRegistration->SetMovingBinaryVolume(movingMask);
appMutualRegistration->SetNumberOfHistogramBins(numberOfHistogramBins);

appMutualRegistration->SetNumberOfIterations( numberOfIterations[l] );

// TODO:  What do the following two lines really accomplish?
// debug parameter, suppressed from command line
const bool initialTransformPassThru(false);
appMutualRegistration->SetInitialTransformPassThruFlag( initialTransformPassThru );
appMutualRegistration->SetUseExplicitPDFDerivativesFlag( useExplicitPDFDerivativesMode == "OFF" );
appMutualRegistration->SetPermissionToVaryGuide( permitParameterVariation );
appMutualRegistration->SetNumberOfSpatialSamples( numberOfSamples );
appMutualRegistration->SetRelaxationFactor( relaxationFactor );
appMutualRegistration->SetMaximumStepLength( maximumStepSize );
appMutualRegistration->SetMinimumStepLength( minimumStepSize[l] );
appMutualRegistration->SetTranslationScale( spatialScale );
appMutualRegistration->SetReproportionScale( reproportionScale );
appMutualRegistration->SetSkewScale( skewScale );

appMutualRegistration->SetFixedImage(    orientedFixedVolume    );
appMutualRegistration->SetMovingImage(   orientedMovingVolume   );
appMutualRegistration->SetBackgroundFillValue(   backgroundFillValue   );

appMutualRegistration->SetInitialTransform( initialITKTransform );

/*
 *  At this point appMutualRegistration should be all set to make
 *  an itk pipeline class templated in TransformType etc.
 *  with all its inputs in place;
 */

// initialize the interconnects between components
appMutualRegistration->Initialize(NumberOfEstimatedParameter);

TransformType::Pointer finalTransform;
try
{
  appMutualRegistration->Update();
  finalTransform = appMutualRegistration->GetTransform();
  //MultiModal3DMutualRegistrationHelperType::OptimizerType *optimizer =
  //  appMutualRegistration->OptimizerPointer;
  //std::cerr << " ************ Stop condition: " <<
  //  optimizer->GetStopCondition() << std::endl;
}
catch( itk::ExceptionObject& err )
{
  // pass exception to caller
  throw err;
}

////////////////////////////////////////////////////////////////////////////
// Write out tranfoms.
//
actualIterations = appMutualRegistration->GetActualNumberOfIterations();
if (actualIterations + 1 >= allLevelsIterations)
{
  if (writeTransformOnFailure == false)
    {
    return failureExitCode;
    }
}
if(l < transformType.size() - 1 ) //Not the last transform, so do not save to disk
{
  //Initialize next level of transformations with previous transform result
  //TransformList.clear();
  //TransformList.push_back(finalTransform);
  transformsList.clear();
  transformsList.push_back(itk::TransformIOBase::TransformPointer(finalTransform));
  initializeTransformMode="Off"; //Now turn of the initiallize code to off
  initialTransform="InternalTransformPush";//Now push the transform from the internal list instead of a file
}
else //The last transform in list, so save to disk
{
  /*
   *  At this point should save the transform.
   */
    {
    typedef itk::VersorRigid3DTransform< double > VersorRigidTransformType;
    VersorRigidTransformType::Pointer versorRigid = VersorRigidTransformType::New();
    versorRigid->SetIdentity();
    AssignRigid::ExtractVersorRigid3DTransform(versorRigid, finalTransform);
    TransformType::Pointer StrippedinitialITKTransform = TransformType::New();
    //Should just write out the rigid transform here.
    AssignRigid::AssignConvertedTransform(StrippedinitialITKTransform, versorRigid);
    if (strippedOutputTransform.size() > 0)
      {
      WriteTransform<TransformType>(StrippedinitialITKTransform,strippedOutputTransform);
      }
    std::cout << " StrippedinitialITKTransform Rotation: " << std::endl
      << StrippedinitialITKTransform->GetMatrix() << std::endl;
    }

    {
    //TODO:  No need to convert to AffineTransformation here, just write out whatever format
    //was used in registration.
    TransformType::Pointer initialITKTransform = TransformType::New();
    AssignRigid::AssignConvertedTransform(initialITKTransform, finalTransform);
    if (outputTransform.size() > 0)
      {
      WriteTransform<TransformType>(initialITKTransform,outputTransform);
      }
    std::cout << " initialITKTransform Rotation: " << std::endl
      << initialITKTransform->GetMatrix() << std::endl;
    }
}

if(l == ( transformType.size() - 1 )) //This is the last transform to be computed, so compute the resampled image.
{
  //TODO:  This needs to be moved outside the registration loops.  We do not need
  if(useWindowedSinc==true)
    {
    resampledImage = appMutualRegistration->GetResampledImage(MultiModal3DMutualRegistrationHelperType::WINDOWSINC_INTERP);
    }
  else
    {
    resampledImage = appMutualRegistration->GetResampledImage(MultiModal3DMutualRegistrationHelperType::LINEAR_INTERP);
    }
}

