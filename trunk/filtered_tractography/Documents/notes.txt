tensor2fa
   MATLAB norm  != Python norm
   3/2 == 1

MATLAB [xyz] ==> Python [zyx]

MATLAB 1-index    Python   0-index


resizing an array -- things don't say in the same place
    (5, array([[ 27.        ,  26.9914856 ,  26.97974396,  26.96519279,
             26.94815445],
           [ 69.        ,  68.94831085,  68.89681244,  68.84685516,
             68.79935455],
           [ 72.        ,  71.85944366,  71.71905518,  71.57836914,  71.4371109 ]], dtype=float32))
    before (3, 5)   list[1,0] 69.0
    after  (3, 10)   list[1,0] 72.0
    (6, array([[ 27.        ,  26.9914856 ,  26.97974396,  26.96519279,
             26.94815445,  26.928545  ,  68.94831085,  68.89681244,
             68.84685516,  68.79935455],
           [ 72.        ,  71.85944366,  71.71905518,  71.57836914,
             71.4371109 ,  68.75478363,  26.9914856 ,  26.97974396,
             26.96519279,  26.94815445],
           [ 69.        ,  68.94831085,  68.89681244,  68.84685516,
             68.79935455,  71.29523468,  71.85944366,  71.71905518,
             71.57836914,  71.4371109 ]], dtype=float32))
  BUG: http://projects.scipy.org/numpy/ticket/775


touples versus direct
    np.random.rand(2,3)
    np.eye(2,3)
    np.ones((2,3))
    np.zeros((2,3))



Gopal Veni <gveni@sci.utah.edu>



np.inner(np.zeros(3),np.zeros((3,1))   --> fails because dimension mismatch


------

  A = np.mat(..)

now A[0] is a sub-matrix (not a scalar) and so it can't be directly passed into various routines

However,
  A = np.array(..)
now A[0] is a scalar!


Basically: if you start using np.mat()....then everything ends up as a matrix
-- then you can't easily grab pieces, e.g. scalars, and pass into other
functions, e.g. ITK


    print [[l1,  0,  0], [0,  l2,  0], [0,   0, l2]]


Traceback (most recent call last):
  File "<string>", line 31, in <module>
  File "/Users/malcolm/Documents/Dropbox/python/filtered_1t.py", line 88, in Execute
    pts.InsertNextPoint(x_[0],x_[1],x_[2])
  File "<string>", line 1, in InsertNextPoint
  File "/usr/local/share/Slicer3-3.4-2009-05-21-darwin-x86/lib/Slicer3/SlicerBaseGUI/Python/Slicer.py", line 139, in __convertArgumentList
    arg = arg.GetTclName()
AttributeError: 'matrix' object has no attribute 'GetTclName'



[[matrix([[ 2831.1625694]]), 0, 0], [0, matrix([[ 1969.09745378]]), 0], [0, 0, matrix([[ 1969.09745378]])]]





---------------------------------

There is a slight offset position discrepancy in the i2r matrix we use in
MATLAB and the one Slicer reports.

From Slicer....

[[  -1.6667    0.        0.      119.169 ]
 [   0.       -1.6667    0.      119.169 ]
 [   0.        0.       -1.7      71.4   ]
 [   0.        0.        0.        1.    ]]
[[ 73.]
 [ 70.]
 [ 28.]]
[[ -2.5001]
 [  2.5   ]
 [ 23.8   ]]


From MATLAB....

M =
   1.0e+02 *
  -0.016667000000000                   0                   0
                   0  -0.016667000000000                   0
                   0                   0  -0.017000000000000
   1.200024000000000   1.200024000000000   0.722500000000000

ans =
  73.0000000
  70.0000000
  28.0000000
tt =
  -1.6666979
   3.3334012
  24.6499977

------------------------

Follow time dominates.  Time to pull in from slicer is trivial.  Time to
convert list of np.array positions into polydata is trivial.

init time   0.114076852798
[  0%] (      0 -      18)
....
follow time   8.11866211891
output time   0.166449069977








For smallest spacing, set the \sigma_{i} = 0.5, and compute the remaining sigma's as follows:
   the spacing is (1.2,1.2,3) then, \sigma_x = \sigma_y = 0.5
   and \sigma_z = (3 x 0.5)/1.2

1. Integrate the signal normalization part into the tractography module (no one will use it otherwise).

2. Have a field where the user can specify the label number and the number of times to seed in that label.
   (If seeding 1 time, use deterministic seeding, or else randomly generate seeds as we do in the maltab case).

3. In the advanced tab, the user should be able to change Qm, Ql and Rs.

4. For the 2T, a field where the user can check "branch" and specify the angle of separation.  One level of branching.

5. Store the state and covariance at each point along the tract. (This could be use to compute FA, Trace etc) and
   return them to Slicer space for future access.




Annoying how things can end up with one dimension and then cause trouble in assignments:

ss_st_arr[cell_id,:].shape == "(5,)"
f_st[j].shape == "(5, 1)"

Yet...
Traceback (most recent call last):
  File "<string>", line 95, in <module>
  File "/Users/malcolm/src/filtered_tractography/Source/filtered.py", line 290, in Execute
    ss_st_arr[cell_id,:] = f_st[j]
ValueError: array dimensions are not compatible for copy
