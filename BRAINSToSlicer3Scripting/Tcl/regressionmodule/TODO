Below is the breakup of the regression tests. From your name to the next name 
are functions which you are responsible for testing. It has come to light 
that we may want to add a few new BRAINS2 commands to query information about 
certain objects. Now is the time to add these functions. I have a start of 
the load image regression test in the regressionmodule/module directory. If 
you do not agree with the design let me know.

*****************************************************************************

Regression Test

Run each filter and make sure that all will run without errors.
Filters with an "x" already have data in the regression test directory
which can be used for testing. Others will have to have additional
data added.
--------------------These are tested by all tests -------------
--------------------These are tested by all tests -------------
--------------------These are tested by all tests -------------
For destroy we may want to reimplement the free printing when in a
certain level of debug mode. We could then verify output to check for
general memory leaks.

b2 destroy every [object-type | viewer]
b2 destroy everything
b2 destroy histogram [histogram]
b2 destroy image [image]
b2 destroy landmark [landmark]
b2 destroy mask [mask]
b2 destroy palette [palette]
b2 destroy roi [roi]
b2 destroy surface [surface]
b2 destroy table [table]
b2 destroy talairach-parameters [talairach-parameters]
b2 destroy talairach-box [talairach-box]
b2 destroy tissue-class [tissue-class]
b2 destroy transform [transform]

------------------------------Hans --------------------------------------
------------------------------Hans --------------------------------------
------------------------------Hans --------------------------------------
------------------------------Hans --------------------------------------
Load, Hide, Mode and Active would have to be an interactive test. Maybe run
first or occasionally berfore a relase.
DONE b2 version
DONE b2 window geometry [window-name] <geometry= geometry-field>
DONE b2 show every [object-type | viewer]
DONE b2 show everything
DONE b2 show image [image]
DONE b2 show landmark [landmark]
DONE b2 show mask [mask]
DONE b2 show roi [roi]
DONE b2 show surface [surface]
DONE b2 show talairach-parameters [talairach-parameters]
DONE b2 show tracker
DONE b2 show viewer [axi | sag | cor | surf | tracker]
DONE b2 hide every [object-type] [object]
DONE b2 hide everything
DONE b2 hide image [image]
DONE b2 hide landmark [landmark]
DONE b2 hide mask [mask]
DONE b2 hide roi [roi]
DONE b2 hide surface [surface]
DONE b2 hide talairach-parameters [talairach-parameters]
DONE b2 hide tracker
DONE b2 hide viewer [axi | sag | cor | surf | tracker]
DONE b2 show time-graph
DONE b2 hide time-graph
DONE b2 mode landmark
DONE b2 mode resample
DONE b2 mode tracing
DONE b2 mode talairach-parameters   Pop-up menu's are wrong.  First element not selectable
DONE b2 mode cerebellum-parameters
DONE b2 mode hippocampus-parameters
DONE b2 active landmark [landmark-name]
DONE b2 active roi [roi-name] <plane= plane>
DONE b2 active talairach-parameters [talairach-parameters | -1]     Looks like it is in an infinite loop
DONE b2 active cerebellum-parameters [cerebellum-parameters | -1]
DONE b2 active hippocampus-parameters [hippocampus-parameters | -1]

##Get a surface ready for running. Compare measurements with a surface already
##generated. Results should be within some delta
DONE b2 create surface [parameter-list] [bound-list] [decimation-list] [option-list]
##Test with a loaded trimodal image
DONE b2 convert rgb-image to hsi [image] [saturation-scale (1, -1)] <palette= palette>
DONE b2 measure surface mask [mask] [surface-1] ... [surface-N]
DONE b2 measure surface roi [roi] [surface-1] ... [surface-N]
DONE b2 measure volume mask [mask]
DONE b2 measure volume roi [roi] <min= min-slice> <max= max-slice>
DONE b2 measure class-volume mask [mask] [image]
DONE b2 measure class-volume roi [roi] [image] <min= min-slice> <max= max-slice>
DONE b2 measure image mask [mask] [image] <functional-flag= true|false>
DONE b2 measure image roi [roi] [image] <min= min-slice> <max= max-slice> <functional-flag= true|false>
DONE b2 student-T {<number> ...} {<number> ...}

b2 object-index [object-type] [object]
b2 object-filename [object-type] [object]
b2 object-list [object-type]
b2 object-name [object-type] [object]

We should generate a tissue classified image and measure the resulting image
ND b2 generate class-plugs [image list] [class list] [mean table] [plug-region] <r= random-seed> <n= num-plugs> <nm= normal min-plugs> <sm= scarce min-plugs> <c= coverage> <p= permissiveness> <mo= trim mean outlier effect> <vo= trim variance outlier effect> <ps= plugSize-in-mm> <dx= num-x-chunks> <dy= num-y-chunks> <dz= num-z-chunks> <pb= pick blood from mask or rule code> <bi= blood-picking-image> <CLASS= class-minPlugs>
ND b2 generate class-model [image-name list] [image list] [class-name list] [mask list] [brainbox mask] <hist-eq= 0|1> <tg= float> <ts= float> <x= 0|1> <y= 0|1> <z= 0|1> <xx= 0|1> <xy= 0|1> <xz= 0|1> <yy= 0|1> <yz= 0|1> <zz= 0|1>
ND b2 apply class-model [image-name list] [image list] [tissue-model] <bg= bg-mask> <bw= bw-mask> <ex_t1= mask> <cth= thresh>
ND b2 apply full-class-model [image-name list] [image list] [tissue-model]

ND b2 threshold histogram pair [percent] [grey-hist] [csf-hist]
ND b2 transform point [transform] [sign (1 or -1)] [floating-point-X] [floating-point-Y] [floating-point-Z]

FIX seg fault when the following is run:
b2 load tissue-class athlon/DEBUG/generateTissueClassify/TEST_10_segment.cls


REWRITE WITH NEW INTERFACE: b2 measure landmark distance [landmark] [point1-name] [point2-name]
PER DISCUSSION W/ Vince, the interface to landmark distances should be more general so that the same point in two different landmark files can be compared
perhaps: b2 measure landmark distance [landmarkSetID] [point1-name] [landmarkSetID] [point2-name]

b2 file [file-type] <filename= filename>\nwhere file-type: saved-volume, saved-class-volume, saved-surface-measures, saved-distance, saved-image-stats
b2 file-filter [add|remove] [filter-type] [name] <check= check-filter> <read= read-filter> <status= status-filter> <write= write-filter>
b2 filter-list [object-type] <mode= mode>

HAVE THE FOLLOWING BEEN CHANGED?
b2 default landmark <group-name= name> <mode= add|remove|remove-all> <points= {point-name-1> ... <point-name-N}>
b2 default roi <name= roiName> <red= float> <green= float> <blue= float> <line-thickness= float> <xHairSize= float> <visible= on|off> <mode= add|remove|remove-all>
b2 default mask
b2 configuration list [roinames | landmarks]

NEEDS TO BE PART OF INTERACTIVE TESTS  b2 dirty-list [roi | landmarks]
NEEDS TO BE PART OF INTERACTIVE TESTS  b2 exit <status-int>, i.e. after brains2 quits, make sure that there are no zombie processes.
b2 echo [string] <more-strings>
b2 snap tiff [pathname] [viewer]
b2 apropos [string]
b2 help 'command'
--------------------------------Vince-------------------------------------------
--------------------------------Vince-------------------------------------------
--------------------------------Vince-------------------------------------------
--------------------------------Vince-------------------------------------------
Filter
applyROIdelta   - Need a delta file
b2alignlinear

Brains2 Commands to Check

Idea for loading and saving would be to load an object and then
save the object with all types of filters. Results should be compared
to previous results. All options should be tested to verify
the command line and that each mode works properly.


Vince can work on this set of commands. I will need some input from Greg
on a couple of commands.
b2 clip image [image] [mask]
b2 compute wbbf [image]" );  /* 1 */
? b2 divide images [image-1] ... [image-N]\nwhere 1 <= N < 256" );  /* 1 */
? b2 equal images [image-1] [image-2]" );  /* 1 */
b2 filter2D image [image] [filter] [orientation] <size= size>" );  /* 1 */
b2 fit image interleaved [image] [#-interleaves] <skip-anterior= num>
<skip-posterior= num>" );  /* 1 */
b2 image max [image]" );  /* 1 */
b2 image min [image]" );  /* 1 */
? b2 interpolation-filtered image [image] <mask= mask>" );  /* 1 *//* ? */
? b2 max images [image-1] ... [image-N]\nwhere 1 <= N < 256" );  /* 1 */
? b2 min images [image-1] ... [image-N]\nwhere 1 <= N < 256" );  /* 1 */
? b2 multiply images [image-1] ... [image-N]\nwhere 1 <= N < 256" );  /* 1 */
b2 normalize pet [image] <clip-mean-flag= flag>" );  /* 1 */
b2 oversample image [image] [x-Middle] [y-Middle] [z-Middle] [x-cubeSize]
[y-cubeSize] [z-cubeSize]\nwhere cubeSize: a power of 2" );  /* 1 */
b2 resample image [image] <plane= plane> <min= min-Slice> <max= max-Slice>
<time= time-index> <storage-type= type> <interp= interpolation> <channel=
channel>" );  /* 1 */
b2 resample worsley-mr [image] [talairach-parameters] <hist-equal= on|off>
<xdim= xSize> <ydim= ySize> <zdim= zSize>" );  /* 1 */
b2 resample worsley-pet [image] [talairach-parameters] <filter-size= float>
<task= taskNumber> <xdim= xSize> <ydim= ySize> <zdim= zSize> <brains-flag=
True|False> <normalize= True|False>" );  /* 1 */
? b2 scaled-multiply images [float] [image-1] ... [image-N]\nwhere 1 <= N <
256" );  /* 1 */
b2 subtract functional-image [image1] [image2]" );  /* 1 */
? b2 subtract from constant [constant] [image-1] ... [image-N]\nwhere 1 <= N
< 256" );  /* 1 */
? b2 subtract images <functional= IPL_TRUE|IPL_FALSE> [image-1] ...
[image-N]\nwhere 1 <= N < 256" );  /* 1 */
? b2 standardize-triquadratic image [image] [mask] <x= 0|1> <y= 0|1> <z= 0|1>
<xx= 0|1> <xy= 0|1> <xz= 0|1> <yy= 0|1> <yz= 0|1> <zz= 0|1>" );  /* 1 */
? b2 standardize-neighborhood image [image] [mask] [neighborhood-size]\nwhere
size: 3 .. min(image dims) - 1" );  /* 1 */
b2 sum images [image-1] ... [image-N]\nwhere 1 <= N < 256" );  /* 1 */
b2 threshold image [image] [threshold-value] <absolute-value= flag>" );  /* 1
*/
b2 trim-effect image [image] [sigmoid | square] <effect-size= float> <mask=
mask>" );  /* 1 */
b2 worsley average-mr [image-list] <study= study-name> <path= path-name>" );
/* 1 */

? b2 fill brainseg mask [mask]
? b2 fill coronal mask [mask]
? b2 fill diagonal mask [mask]
? b2 fill internal mask [mask]
? b2 fill mask [mask]

b2 color surface masks [surface_index] {mask_index, ...} {{red green blue
alpha}, ...}
b2 color surface normals [surface_index]
b2 color surface standard-depth [surface_index] <effect-size= value>
b2 compose transform [head-transform-to-modify] [new-previous-transform
(which may be -1 to clear previous)]"

----------------------------------Greg-------------------------------
----------------------------------Greg-------------------------------
----------------------------------Greg-------------------------------
----------------------------------Greg-------------------------------
This set can be tested fairly easily with a series of measurements
b2 and masks [mask-1] [mask-2] ...
b2 clean mask [mask] <size-thresh= 2D-size-threshold> <x-loc= point-coord>
<y-loc= point-coord> <z-loc= point-coord>
b2 dilate mask [mask] [distance]
b2 erode mask [mask] [distance]
? b2 erode surface mask [mask] [image] [threshold]

? b2 majoritize masks [mask1] ... [maskN]
b2 not masks [mask]
b2 or masks [mask-1] [mask-2] ..."
b2 resample mask [forward | inverse] [mask] [transform]
b2 split mask [mask] [plane] [slice] [direction]
b2 sum masks [mask-1] ... [mask-N]\nwhere N < 256
b2 xor masks [mask-1] [mask-2]
? b2 zhou mask [image] [mask]

We should add generation of an enhanced MR5 and MR6 image set to test these
functions
b2 create image-table [T1-image] [T2-image] [PD-image] <Count-table= table
Sum-table= table> <mask= mask>
b2 finish image-table [Count-table] [Sum-table]
b2 generate table pseudo-image [T1-image] [T2-image] [Value-table]

This could run on any image in the regression test data and save a copy after
verification to be used for future tests
b2 create bounded-image [image] [xmin] [xmax] [ymin] [ymax] [zmin] [zmax]

Threshold and clip and image, then create boxed image for a T1 scan
b2 create boxed-image [image] <threshold= threshold>

Run this command and save results for future tests
b2 create bullet-image [foreground_byte] [background_byte] [xDim] [yDim]
[zDim] [xRes] [yRes] [zRes] [xPos] [yPos] [zPos] [xSize] [ySize] [zSize]

This could be run and compared to results which we have verified only
2D nmode currently works
b2 create roi-hull [roi] [2D | 3D]

? b2 convert code-image to mask-set [image] [mask-name-list]

This should be tested against a verified set of landmarks
b2 convert landmark to talairach-landmark [landmark] [talairach-parameters]

This should be tested against a verified set of landmarks
b2 convert talairach-landmark to landmark [from-landmark] [to-landmark]

Test a known location. Initial check should be against BRAINS
b2 convert location to talairach [location-list] [talairach-parameters]

Check this against a verified mask
b2 convert mask to surface-gm-mask [radius] [image] [mask] [surface-1] ...
[surface-N]

Check and verify an initial mask which is saved. Xor should give a 0 volume
b2 convert mask to talairach-mask [mask] [talairach-parameters]
? b2 convert mask-set to code-image [mask-list]
? b2 convert mask-set to surface-gm-mask-set [radius] [tissue-image]
[cerebrum-mask] [mask-list] [clipping-mask-list] [surface-list]

This should be tested and original verified against BRAINS
b2 convert talairach to location [location-list] [talairach-parameters]

This is tested in both modes in current regression test
b2 convert talairach-box to mask [talairach-box] [talairach-parameters]
<expand= expand-flag>

This should be tested and verified
b2 convert talairach-landmark to landmark [landmark] [talairach-parameters]

This shgould be tested with initial verification which is saved
b2 convert talairach-mask to mask [mask] [talairach-parameters]

? b2 transform boxed-image-set [transform] [cloud-image-list]

All measurements tested in current regreession script. We simply need to
verify outpout
and add surface measurements.
? b2 measure class surfaces roi set [class-image] [MR5-unclosed-cerebl-roi]
[cranmask.segment-mask] {[surface] ...} {[roi] ...}" );  /* 2 *//* Do we need
this command */
? b2 measure class surfaces mask set [class-image] [MR5-unclosed-cerebl-roi]
[cranmask.segment-mask] {[surface] ...} [greyMatter-mask]" );  /* 2 *//* Do we
need this command */
The remaining commands are not too difficult to test
b2 average landmarks [landmark-1] [landmark-2] ...

b2 check roi [roi]
b2 close roi [roi]
b2 extrude roi [roi] [x-length] [y-length] [z-length]
b2 thin roi [roi] <min= min-slice> <max= max-slice>
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------
-------------------------------------------------------

